---
title: JS之路 Day07 - 語法糖Class(下)
date: 2022-09-22 21:47:40
tags:
categories:
  - 2022 iThome 鐵人賽
---

## 前言

今天會來繼續介紹語法糖`Class`的語法部分，會介紹到的分別為:

- 「extends」、「super」 keywords
- static properties and methods

<!--more-->

## extends and super

首先昨天已經知道了，`class`可以依靠`constructor`跟`prototype`的原理來去實作出像是其他程式語言的繼承效果，但是`class`以及`class`之間的繼承還是一個問題，為了這件事情，`JavaScript`有提供在`class`中可以使用`extends`跟`super`來解決這件事情。

原本單純使用`class`來寫會是長這樣：

```javascript
class Parent
```

使用`extends`關鍵字的語法是：

```javascript
class Child extends Parent
```

這邊使用 MDN 上面的範例修改過後來做講解：

```javascript
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  speak() {
    console.log(`${this.name}說話了。`);
  }
}

class Dog extends Animal {
  constructor(name) {
    super(name); // call the super class constructor and pass in the name parameter
  }

  speak() {
    console.log(`${this.name}正在叫。`);
  }
}

const a = new Dog("Mitzie");
a.speak(); // Mitzie barks.
```

一步步去拆分`extends`跟`super`做了哪些事情。

1. 會發現說 Dog 使用 `extends` 指定 Animal `class`

Dog 這個新的`class`想要獲得 Animal 這個舊的`class`的繼承，相當於就直接繼承了 Animal 裡面所有的`Properties` 和 `Method`，那這邊會有一個問題出現，那`super`的作用何在？

2. 用 `super` 呼叫 `extends` 指定的 Animal `class`

沒有加`super`直接把`super(name);`給刪掉的話，會報錯，訊息如下：

> ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor

但如果是把:

```javascript
 constructor(name) {
    super(name);
  }
```

這段完全刪掉的話，不會報錯，然後結果也看起來一模一樣。
這是因為今天如果不需要透過 Dog 去新增屬性(就是寫在`constructor`裡面的東西)，只是增加方法，或是使用繼承而來的方法，那就可以把`super`省略掉也可以。

簡單來說，用到`super`可以讓`JavaScript`判斷說 `extends` 過的那個 class，有沒有需要替換掉那個繼承的東西，示意圖：

```javascript!
class Dog extends Animal {
  speak() {
    // 現在這個裡面的東西會被當成 Dog.stop()
    // 而不是被當成來自於 class Animal 的 speak()
  }
}
```

`JavaScript`沒辦法判斷到底要以誰的為準，所以創造出了叫做`super`的關鍵字，主要的功能如下：

- 使用 supe(...)的方式，來指定可以使用繼承的`constructor`
- 使用 super.method(...)的方式來直接呼叫那個方法

假如說，我想要讓 Dog 創造出來的實例在說話`speak()`時，多說一句你好`sayHi()`：

```javascript!
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  speak() {
    console.log(`${this.name}說話了。`);
  }
}

class Dog extends Animal {
  constructor(name) {
    super(name);
  }

  sayHi() {
    console.log("hi");
  }

  speak() {
    super.speak();
    this.sayHi();
  }
}

const a = new Dog("dog");
a.speak(); //dog說話了。 hi

```

這樣的話，就是讓 Dog 在繼承了 Animal 這個 class 所有的屬性之外，也可以去使用 Animal 的 speak()方法，然後在這個基礎之外，再去新增新的功能也是沒有問題。

透過這種使用`extends`跟`super`的搭配就可以做到讓彼此 class 之間的繼承。

## static methods and properties

`static methods`中文是叫做靜態方法，就是我可以在 class 裡面的`constructor`去進行呼叫靜態方法，但創造出來的實例是無法去取用的，舉例來說：

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }

  static sayHello(name) {
    console.log(`${name},How are you`);
  }
}

Person.sayHello("vic");
```

假如使用`static`這個關鍵字在 class 內的 Method 中，那個 Method 就會變成`static method`，像這邊來說，`Person`就變得可以使用`sayHello`這個方法，但同時創造出來的實例就將會變得無法執行，可以來試試看。

```javascript
const apple = new Person("apple");

apple.sayHello(); // TypeError: apple.sayHello is not a function
```

會報錯，找不到無法使用。

可以理解成，一般狀態下是動態的，創建出來的實例可以隨著自身的`class`動態使用它，可以用`static`使其變成靜態，在靜態時可以直接從`class`取用方法。

而關於靜態時候的屬性也是可以做得到的，靜態就屬性就代表可以直接從`class`取用的屬性，舉例來說：

```javascript!
class Apple {
  static color = "red";
}

console.log(Apple.color); // red
```

加上了`static`的屬性就可以直接在`class`去使用的，像上面就可以直接用 Apple 去取得 color 的屬性，就其實就相當於直接給 Apple 做一個賦值的動作。

## 總結

今天介紹了一些`Class`語法糖的使用方式，可能就算不會寫`class`也一樣可以寫`JavaScript`，但是學會了這個技巧可以幫助成為自己成為一個更棒的工程師，基本的 class 就先介紹到這邊～

## reference

[1] [MDN - Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)
[2] [JavaScript | ES6 中最容易誤會的語法糖 Class - 基本用法](https://medium.com/enjoy-life-enjoy-coding/javascript-es6-%E4%B8%AD%E6%9C%80%E5%AE%B9%E6%98%93%E8%AA%A4%E6%9C%83%E7%9A%84%E8%AA%9E%E6%B3%95%E7%B3%96-class-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-23e4a4a5e8ed)
[3] [Class inheritance](https://javascript.info/class-inheritance)
