{"pages":[{"title":"分類","text":"","link":"/categories/index.html"},{"title":"about","text":"這裡是 vic 的 blog，主要會分享前端技術的相關文章，目前主要以 html css javascript 為主在學習著， 現在目標是成為 javascript 大師。","link":"/about/index.html"},{"title":"標籤","text":"","link":"/tags/index.html"}],"posts":[{"title":"Selector Combinators 中的+跟~差別","text":"原文連結: https://appcs342.blogspot.com/2022/04/selector-combinators.html移植時的最後更新日期: 2022-04-04T05:40:13.467-07:00 介紹兩個很類似的選擇器，全名是Next-sibling combinator，簡稱加號(+)全名是Subsequent-sibling combinator，簡稱波浪號(~)加號是會影響到後方同層級的首次遇到元素波浪號則是影響後方同層級的全部元素加號跟波浪號都是目標為要影響後方同層級，語法使用方式也都差不多[選取對象A + 選取對象B] 及 [選取對象A ~ 選取對象B]。看起來非常的像，不過有一些差別：加號是只能選到A後面那一個B波浪號是選到A後面整串同層的B","link":"/2022/04/04/Adjacent%20and%20General%20Sibling%20Selector/"},{"title":"JavaScript 解構賦值解構什麼？","text":"解構賦值是 es6 之後出來的一個新語法，我的理解它是一種語法糖，語法糖意思也就是說它可以用更簡單的方式達到相同的效果。 至於它究竟解構了什麼？其實就是陣列或是物件裡面的值，原本我們假如要取出陣列跟物件裡面的值，可能會這樣來寫： 1234567let goodFruit = { name: '西瓜', color: 'green',};let name = goodFruit.namelet color = goodFruit.colo 但如果使用解構賦值的話，取用的方式就會變得稍微有些不同： 1234567let goodFruit = { name: '西瓜', color: 'green',};let { name, color } = goodFruit 有看見兩者之間的差別了嗎？下面的方式直接把取出的值骸需要再做宣告變數的步驟給取消了，直接就把物件裡面的值給取出來，一個步驟就把「宣告變數」及「變數賦值」的部分給完成。 而這種方式就可以減少很多代碼量，達到說優化可讀性的效果，另外除了物件以外，陣列也可以用解構賦值的方式： 1234567//基本用法const foo = ['one', 'two', 'three'];const [A, B, C] = foo;console.log(A);console.log(B);console.log(C); 小結 解構賦值能夠減少很多重複性的事情，也能提高代碼整體的可讀性 陣列跟物件的解構賦值取值順序不同，陣列是看索引值，物件則是屬性名稱 除了順序之外陣列跟物件所用的括號也不一樣，一個是中括號，一個是大括號 參考資料https://eddy-chang.gitbook.io/javascript-start-from-es6/part4/destructuring https://www.casper.tw/javascript/2017/12/25/javascript-destructuring/ https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E5%98%97%E8%A9%A6%E4%B8%80%E4%B8%8B https://www.796t.com/article.php?id=288105","link":"/2022/07/03/Destructuring%20assignment/"},{"title":"JS之路 Day01 - 開始與結束的序言","text":"大家好，我是 Vic，目前在台南的好想工作室學習，已經在這裡自學了幾個月時間。鐵人賽的開始，代表著我的 JS 學習的路也已經學到了一個段落，這一個階段要挑戰的就是三十天連續的技術發文，挑戰短時間內對JavaScript的理解程度，學習了三、四個月也是一段不短的時間，該來突破自我了！ 這段時間自學看了許多網路上資源跟書籍，列出一些我自己覺得很不錯的(各列前三個)。 學習網站： JS MDN提供了很多語法的說明跟相關的技術文件，正確性很高，而且每個語法都有很清晰的範例，是一個我後來當作 JS 字典的地方，會天天看天天查。 JS w3schools跟 MDN 是同個性質的學習網站，但相對來說會簡單些，優點是版面很乾淨，會讓人看了覺得很舒服，我覺得也很適合初學者去看。 Lidemy 鋰學院號稱是一個為初學者而生的線上程式課程平台，我覺得當之無愧，滿完整又便宜，就算不花錢上面也有一些免費的課程。之前花了一個月去訂閱，然後把想看的學習影片全部看完，我覺得很划算。 學習書籍： JavaScript 概念三明治：基礎觀念、語法原理一次帶走！簡稱三明治，看完後個人認為超適合初學者，裡面淺白好懂，去年才出的內容也很新，最棒的是還是全彩的，但可能內容不會很深入，有好有壞，不過是很棒的書。 0 陷阱！0 誤解！8 天重新認識 JavaScript！簡稱 008，很厲害的書，不過我看完後覺得對於完全新手的人會有些吃力，因為蠻多部分書裡面當作你已經知道然後省略掉，所以可能會需要邊看邊去查 MDN 幫忙理解，但有一定深度，是一本好書。 忍者：JavaScript 開發技巧探秘, 2/e簡稱忍者，完全不適合新手看的書，我覺得可能要上面兩本三明治跟 008 讀完再來挑戰，一本高手境界的書，要記得它，當你未來要更上一層樓時，閱讀忍者是一個好的方法，目前我正在看，還沒看完。 我的預想預想這次的系列會從個人認為 JS 最難的部分開始寫，系列文章順序理論上就是從困難=&gt;簡單，後面假如沒東西想法寫，就會開始挑戰當日找新東西馬上學馬上寫。目前還沒開始寫所以沒什麼概念，所以詳細的大綱會根據我個人寫的速度而跟著變化著。 開始與結束就如標題所講的，這是一段開始與結束的序言，鐵人賽開始的同時，一些事情也隨之跟著結束，而我要做的就是把握當下，用心的把我這階段該完成的事情給完成，這會是一段難忘的回憶，因為一些原因，我鐵人賽期間會有點忙，不過相信這也是練習同時應付多種重要狀況的好機會。 這次會抱持著鐵人就應該要現學現賣的精神，在能力所及的狀態之下，去選擇最困難的那條路，想辦法做到最好。 那就開始吧，三十天的 JS 之路 GOGOGO!!!","link":"/2022/09/16/JS01/"},{"title":"mac的esc沒有反應問題","text":"這個一直困擾我很久的問題，有時候用一用就突然失效，而到最近更是連 F3 也無法使用，三指往上滑也沒辦法，可惡這是剛買沒有到一年的 mac m1 呀，不過我最終找到了解決方式，記錄一下。 1. 重新開機重新開機就能恢復正常，缺點就是每次發生失效就得一直重新開關機。 2. 重啟 dock在終端機或是其他命令提示的地方下這一個指令： 1killall Dock","link":"/2022/08/23/Esc%20key%20does%20not%20work/"},{"title":"JS之路 Day03 - Prototype Chain(原型鏈)","text":"昨天Prototype世界的例子中，小白這種打電話讓別人再去打電話找的方式，其實就是一種Prototype Chain的概念。 畫一張示意圖會比較清楚一些，用一個空的陣列來做舉例。 首先，陣列也是一種物件，空陣列代表裡面什麼都沒有，不過不代表不能從空陣列去獲取東西。 當我要從物件裡面找一個不存在的屬性，JavaScript就會直接從它的原型物件去找，要是它的原型物件沒有，就會再往上找它的原型物件，直到最上面，都沒有那就是找不到。 而這個最上面的原型物件就稱作叫Object.prototype。真的就最上面了，再往上找就是null。 而這一個由下往最上尋找的過程，一層一層相依尋找，就是原型鏈。 Object.create這個可以拿來創造出一個擁有原型物件的新空物件，裡面的參數就帶要被繼承的原型物件，比如說: 12345const food = { eat: true,};const apple = Object.create(food); 這個新被創造出來的物件其實原型物件就會自動綁定是food了，所以現在的apple也可以去看eat的這個屬性。 1console.log(apple.eat); //true 除此之外，Object.create還有一個很厲害的地方，它可以藉由放第二個參數，直接為新的物件增加額外的屬性。 1234567891011const food = { eat: true,};const apple = Object.create(food, { red: { value: true, },});console.log(apple.red);//true Object.getPrototypeOf()昨天只講到如何設定原型，其實還可以獲取原型，那就是使用Object.getPrototypeOf()，這個語法會回傳物件中的原型物件。 用上面的例子來舉例: 12345const food = { eat: true,};const apple = Object.create(food);console.log(Object.getPrototypeOf(apple) === food);//true apple的原型物件就是food，所以答案是true，證明沒想錯。 __proto__其實也能做到相同的事情，不過使用__proto__來進行設定或是獲取都是件不太好的事情(詳情請看昨天)，所以請記得，現在主流的設定跟獲取方式: Object.getPrototypeOf() =&gt; 獲取 Object.setPrototypeOf() =&gt; 設定 但是__proto__真的就一無可取之處嗎?那倒也不是，有一個用法的情境是不會被反對的。 __proto__當作屬性時圖片來源: MDN 看起來MDN裡面比較偏向說，不要使用. __proto__的方式，但把__proto__當作屬性時算是一個還蠻OK的方式。 也有查到其他地方也有這種說法: The only usage of proto, that’s not frowned upon, is as a property when creating a new object: { proto: … }.說法出處:https://javascript.info/prototype-methods 讓我們來看看這方法是怎麼實作的吧。 創建一個新物件時，可以把__proto__當作是屬性，然後它的value直接設定成所想要的原型物件。 有一個重點是，__proto__的值必須是物件或是null，比如說值是字串就無法，其實蠻合理的，因為字串不能變成一個原型。 1234567891011121314const food = { eat: true,};const apple = { color: &quot;red&quot;, __proto__: food,};const coconut = { hardness: true, __proto__: apple,// 怕大家不知道所以講一下，coconut是椰子}; 在這邊有三個新創的物件，我利用__proto__當屬性設定的方式，讓這三個物件形成一個原型鏈，藉由把apple的__proto__設定成food，再把coconut的__proto__屬性設定成apple，這樣一來，理論上應該可以在coconut使用到food的屬性，我們來測試看看。 1console.log(coconut.eat); //true 看來結果沒有錯，確實已經藉由__proto__當屬性的方式，把這三個物件串個原型鏈。 不要做的事情現在已經提到了Object.setPrototypeOf以及obj.__proto__都可以直接的去更改原型物件，影響整體的Prototype Chain，但這是一件好的事情嗎？ 關於這點去研究後，發現有些文章會說這個行為其實不是一件很好的事情，如下：圖片來源：https://javascript.info/prototype-methods 大意就是，如果你今天覺得，速度很重要，就不要去修改已經存在的原型了，昨天有提到說，物件只能指定一種原型物件，要是去修改它，就會去覆蓋掉原本的原型物件，而這種行為，照那篇文章說，會去破壞掉object property access operations的內部優化，簡單說就會會讓javascript的執行速度變得很慢。 除非修改的重要程度比運行的速度還要重要，不然通常在創建物件時，就只會設置那麼一次，就不會再修改了，確實設計上是想改就改，但是除非有很確定自己在做什麼，不然我的理解是避免去做這件事情。 總結可能其它程式語言並不是如此，但在javascript中就是透過Prototype Chain來把上下關係給連接起來，藉此來達到繼承的方式，推薦大家可以去看huli的 該來理解 JavaScript 的原型鍊了，裡面講的很清楚好懂，那麼今天就是這些，我們明天見！ reference[1] Object.getPrototypeOf()[2] Native prototypes","link":"/2022/09/18/JS03/"},{"title":"JS之路 Day04 - Prototypal Inheritance(原型繼承)","text":"Array Methods繁多，許多人常常使用時會在去 MDN 看文檔，但如果你仔細看會發現奇怪地方，比如說你想要去查map的語法，你實際會看到Array.prototype.map()。 更奇怪的地方是，有些會有.prototype，有些沒有，當初我初學時百思不得其解。 其實這就跟今天主題的Prototypal inheritance有關，讓我們從一開始提到的map的Array Methods開始看起，寫一個簡單的例子: 12345const arr = [1, 2, 3, 4, 5];const arr2 = arr.map((n) =&gt; n + 1);console.log(arr2); 會發現說，我明明沒有寫這個方法，但是我可以用，why?arr 裡面明明就只有 12345。這就是原型繼承的奧妙之處。 arr = [1, 2, 3, 4, 5]其實可以看成是arr = new Array([1, 2, 3, 4, 5]) 其中Array就是內建的一個 Constructor Function，它自身的prototype會指向一個帶有 map(方法)跟其他一堆的方法的超大物件。 在這邊arr.map其實就會等於Array.prototype。 意味著arr會連結到它的原型物件，所以它可以使用它的原型物件所有的方法，就是剛剛提到的超大物件，如下圖： 可以理解成，這個arr的array繼承了map方法，在arr的array本身其實是沒有去定義方法的，全部都在它的原型物件上了，我們可以確認這件事情是不是真的，來驗證吧。 證明這件事情 =&gt; 原型繼承第一步是看arr.__proto__會不會跟Array.prototype相等 arr.__proto__代表的是 arr 這個 array 它的原型物件。Array.prototype是 Array 這個 constructor 的原型。結果是 true 那其實就代表他們是相同的。 12const arr = [1, 2, 3, 4, 5];console.log(arr.__proto__ === Array.prototype); // ture 第二步是看arr.map是不是跟Array.prototype.map相同。 這邊是為了要證明我上面所講的，arr.map其實就會等於Array.prototype這件事情。結果是 true 那其實就代表他們是相等的。 12const arr = [1, 2, 3, 4, 5];console.log(arr.map === Array.prototype.map); 第三步是看arr.map會不會跟arr__proto__.map一樣。繼承的概念，就是當這個物件找不到了，它會從它的上層原型物件去尋找，所以理論上當 arr 找不到它的 map 方法時，應該可以從arr__proto__這個 arr 的上層原型物件去拿到 map 方法。 結果還是 true，代表上面想法沒有錯誤。 12const arr = [1, 2, 3, 4, 5];console.log(arr.map === arr.__proto__.map); 最後得出了一個結論，arr 確實成功了繼承了原型。 那些沒有.prototype的方法剛剛是講有的，現在來講沒有的。這邊用Array.isArray()來舉例。圖片來源：MDN 為什麼不是Array.prototype.isArray()，其實道理很間單，我的理解是因為不能確定我使用的對象是不是 Array，所以我不能使用 Array 的原型物件來繼承。 像是Array.isArray()這個方法就是用來判斷這個東西是不是 Array 的，所以結果可能是也可能不是，所以沒辦法斷定說就是 Array。 所以必須在寫的時候，不能使用.prototype的方式，要直接把 Array 給寫出來，我們來做個差異化比較： 123456789// 有.prototype =&gt; Array.prototype.map()const test = [1, 2, 3, 4];// test.map就會等於Array.prototypeconsole.log(test.map((a) =&gt; a * 2)); // [2, 4, 6, 8]// 沒有寫.prototype =&gt; Array.isArray()const test2 = [1, 2, 3, 4];// 判斷的東西，是放在參數裡面的概念。console.log(Array.isArray(test2)); // true Object.prototype原型繼承還有一個有趣的地方，就是剛剛講解的那個是Array的原型，但就算是Array，它的頂點原型也不是Array.prototype，而是Object.prototype。 也不只是Array而已，全部的內建原型的頂點通通都是Object.prototype。 所謂的頂點就是，上面已經沒有東西，高處不勝寒，想要再繼續往上的話只看的到null而已。 所以我會理解成，在JavaScript中所有的繼承都是由Object.prototype繼承而來，然後我去查詢相關爬文，也有一些人這麼說: All objects inherit the properties and methods of Object 這句話出處:JavaScript Prototypes and Inheritance – and Why They Say Everything in JS is an Object 意思是其實所有的物件都是繼承了 object 的屬性跟方法，null 不算，因為它沒有原型，只是充當原型鏈的最後一環。 增加更改原型繼承除了昨天講到不要用Object.setPrototypeOf以及obj.__proto__去指定變換原型物件之外，還有也不要去增加更改原型繼承。 像是上面有提到的Array.prototype.map()方法，它是內建寫好的，但其實也可以自己寫一個方法塞進去，像是： 12345String.prototype.good = function () { console.log(this + &quot;good&quot;);};&quot;apple&quot;.good(); // apple good 這好嗎？ 這不好。 原因有幾個： 假如是在跟別人協作，你弄了一個自己寫的方法放入自己的原型物件，然後自己繼承用的很開心，但是別人看到會一頭霧水，不知從何而來。 因為原型物件是 global 的，很容易造成衝突，像是說有兩個函式庫都添加了 String.prototype.good 這個方法，就會造成前面蓋後面。 自己需要用的話，那就直接寫一個方法給自己用就好，其實不太需要把這個方法，弄給全部人都能繼承，因為大部分javascript覺得你需要的方法都已經幫忙內建寫好了。 總結希望大家看完這篇有比較懂為什麼大部分方法都有加上.prototype，以及對於原型繼承的部分有更實務上的理解，之前比較偏向講原理，而實際有運用到原型繼承的我想就是這些族繁不及備載的內建方法了吧，以上就是今天的介紹。 reference[1] Inheritance and the prototype chain","link":"/2022/09/19/JS04/"},{"title":"JS之路 Day05 - Constructor Function(構造函式)","text":"前言Constructor Function也是Function，那它跟一般的Function差在哪裡，有什麼特別之處，就是今天主要介紹的部分。 構造函式剛剛有提到其實跟Function差不多，所以正常來說為了要區分這兩者的差別，構造函式在命名上都會以大寫字母來寫，而構造函式的誕生，是要經過一個叫做new這個關鍵字來創立。 意味著，使用new來生成的函式就是構造函式。沒有使用new來生成，可以直接呼叫執行的，就是普通函式。 那什麼是new？ new關鍵字new這個關鍵字其實是new operator，在 mdn 的解釋是： The new operator lets developers create an instance of a user-defined object type or of one of the built-in object types that has a constructor function. 我自己翻起來是：new可以創建一個定義物件類型，或者是具有構造函式的內置物件類型，它們的實例。 我的理解是new只可以拿來創造構造函式，沒有用new來創造就只會是普通函式。 接下來就來證明這件事情。 new從原理下手圖片來源：MDN 假如有個程式如下： 12345678const Food = function (fruit, color) { this.fruit = fruit; this.color = color;};const apple = new Food(&quot;apple&quot;, &quot;red&quot;);console.log(apple);// Food { fruit: 'apple', color: 'red' } 很明顯，我們後來可以創一個變數，使用new的方式把 apple 跟 red 的資訊，傳遞給上面構造函式，就可以成功創造一個實例。 照著 MDN 上面的解釋，一步步來解析 new 幫忙做了什麼事情： 首先一開始 new 會幫忙創造一個空的物件，可以當作是{}。 然後把 {} 的 __proto__ 指向 Food 的 prototype，這邊就是前幾篇講過的原型概念，這樣的方式是為了要繼承原型鏈。 接著下一步是呼叫這個構造函式，綁定{}是 this 的 context，可以理解成 this 就會指向這個空物件，構造函式裡面的 this 是什麼，這裡就會是什麼 =&gt; this={}。 所以在這個例子來看，現在這個 context 裡面就會有兩個新的屬性。 最後那個一開始創建出來的物件，就會自動回傳，回傳一個有兩個屬性的物件，這就會是new Food(&quot;apple&quot;, &quot;red&quot;)最後結果，它將會儲存在apple這個變數裡面。 以上就是new會在背後幫忙做的事情。 有一個蠻好理解的方式，我從這邊看來的 https://javascript.info/constructor-new。 先看這個程式： 123456function User(name) { this.name = name; this.isAdmin = false;}let user = new User(&quot;Jack&quot;); 這裡的 new User(...) 可以理解成這樣運行： 123456789function User(name) { // this = {};（隱式創建） // 添加屬性到 this this.name = name; this.isAdmin = false; // return this;（隱式返回）} 所以最後返回的結果都是相同的物件： 1234let user = { name: &quot;Jack&quot;, isAdmin: false,}; 另外，從這裡還可以衍生一件事情，上面有提到說，在創造new時就已經把所有重要的東西都放入 this 裡面，所以不會需要再return回傳結果，所以在這裡可以再做一個劃分： 普通函式會使用return 構造函式不會使用return 什麼情況不能用new？不是 function 的時候:我個人測試沒有 function 就會拋出異常： 12345var Apple = {};var newApple = new Apple();console.log(newApple);//TypeError: Apple is not a constructor Apple is not a constructor，我明明已經弄成物件了，卻還是不行，那假如用 function： 12345var Apple = function () {};var newApple = new Apple();console.log(newApple);//Apple {} 改成用 function 就不會報錯。我的理解是，空的也不會報錯，基本上全部的函式都可以當作構造函式來使用，除了箭頭函式之外(它沒有 this)，除此之外，都可以通過用 new 的方式來變成構造函式。 總結語法的產生都有其原因的存在，而構造函式的產生是來自於有許多情境會需要創造很多相似的物件。 在創造其他物件時，只需要 new ABC(“abc”)，除了更好閱讀之外，也可以少寫許多東西，讓整個程式變得乾淨許多。 這種寫一次就可以反覆使用，就是構造函式的精髓所在，大家也多使用構造函式來優化自己的程式碼吧。 reference[1] MDN - constructor[2] Constructor, operator “new”[3] MDN - new operator[4] JS 对象机制深剖——new 运算符","link":"/2022/09/20/JS05/"},{"title":"JS之路 Day07 - 語法糖Class(下)","text":"前言今天會來繼續介紹語法糖Class的語法部分，會介紹到的分別為: 「extends」、「super」 keywords static properties and methods extends and super首先昨天已經知道了，class可以依靠constructor跟prototype的原理來去實作出像是其他程式語言的繼承效果，但是class以及class之間的繼承還是一個問題，為了這件事情，JavaScript有提供在class中可以使用extends跟super來解決這件事情。 原本單純使用class來寫會是長這樣： 1class Parent 使用extends關鍵字的語法是： 1class Child extends Parent 這邊使用 MDN 上面的範例修改過後來做講解： 1234567891011121314151617181920212223class Animal { constructor(name) { this.speed = 0; this.name = name; } speak() { console.log(`${this.name}說話了。`); }}class Dog extends Animal { constructor(name) { super(name); // call the super class constructor and pass in the name parameter } speak() { console.log(`${this.name}正在叫。`); }}const a = new Dog(&quot;Mitzie&quot;);a.speak(); // Mitzie barks. 一步步去拆分extends跟super做了哪些事情。 會發現說 Dog 使用 extends 指定 Animal class Dog 這個新的class想要獲得 Animal 這個舊的class的繼承，相當於就直接繼承了 Animal 裡面所有的Properties 和 Method，那這邊會有一個問題出現，那super的作用何在？ 用 super 呼叫 extends 指定的 Animal class 沒有加super直接把super(name);給刪掉的話，會報錯，訊息如下： ReferenceError: Must call super constructor in derived class before accessing ‘this’ or returning from derived constructor 但如果是把: 123constructor(name) { super(name); } 這段完全刪掉的話，不會報錯，然後結果也看起來一模一樣。這是因為今天如果不需要透過 Dog 去新增屬性(就是寫在constructor裡面的東西)，只是增加方法，或是使用繼承而來的方法，那就可以把super省略掉也可以。 簡單來說，用到super可以讓JavaScript判斷說 extends 過的那個 class，有沒有需要替換掉那個繼承的東西，示意圖： 123456class Dog extends Animal { speak() { // 現在這個裡面的東西會被當成 Dog.stop() // 而不是被當成來自於 class Animal 的 speak() }} JavaScript沒辦法判斷到底要以誰的為準，所以創造出了叫做super的關鍵字，主要的功能如下： 使用 supe(…)的方式，來指定可以使用繼承的constructor 使用 super.method(…)的方式來直接呼叫那個方法 假如說，我想要讓 Dog 創造出來的實例在說話speak()時，多說一句你好sayHi()： 1234567891011121314151617181920212223242526272829class Animal { constructor(name) { this.speed = 0; this.name = name; } speak() { console.log(`${this.name}說話了。`); }}class Dog extends Animal { constructor(name) { super(name); } sayHi() { console.log(&quot;hi&quot;); } speak() { super.speak(); this.sayHi(); }}const a = new Dog(&quot;dog&quot;);a.speak(); //dog說話了。 hi 這樣的話，就是讓 Dog 在繼承了 Animal 這個 class 所有的屬性之外，也可以去使用 Animal 的 speak()方法，然後在這個基礎之外，再去新增新的功能也是沒有問題。 透過這種使用extends跟super的搭配就可以做到讓彼此 class 之間的繼承。 static methods and propertiesstatic methods中文是叫做靜態方法，就是我可以在 class 裡面的constructor去進行呼叫靜態方法，但創造出來的實例是無法去取用的，舉例來說： 1234567891011class Person { constructor(name) { this.name = name; } static sayHello(name) { console.log(`${name},How are you`); }}Person.sayHello(&quot;vic&quot;); 假如使用static這個關鍵字在 class 內的 Method 中，那個 Method 就會變成static method，像這邊來說，Person就變得可以使用sayHello這個方法，但同時創造出來的實例就將會變得無法執行，可以來試試看。 123const apple = new Person(&quot;apple&quot;);apple.sayHello(); // TypeError: apple.sayHello is not a function 會報錯，找不到無法使用。 可以理解成，一般狀態下是動態的，創建出來的實例可以隨著自身的class動態使用它，可以用static使其變成靜態，在靜態時可以直接從class取用方法。 而關於靜態時候的屬性也是可以做得到的，靜態就屬性就代表可以直接從class取用的屬性，舉例來說： 12345class Apple { static color = &quot;red&quot;;}console.log(Apple.color); // red 加上了static的屬性就可以直接在class去使用的，像上面就可以直接用 Apple 去取得 color 的屬性，就其實就相當於直接給 Apple 做一個賦值的動作。 總結今天介紹了一些Class語法糖的使用方式，可能就算不會寫class也一樣可以寫JavaScript，但是學會了這個技巧可以幫助成為自己成為一個更棒的工程師，基本的 class 就先介紹到這邊～ reference[1] MDN - Classes[2] JavaScript | ES6 中最容易誤會的語法糖 Class - 基本用法[3] Class inheritance","link":"/2022/09/22/JS07/"},{"title":"JS之路 Day02 - Prototype (原型)","text":"前言我相信每個語法的發明都有它意義存在，以我看來Prototype的存在，是為了要讓JavaScript 也能實現物件導向，準確點來說，可以用來做到物件的繼承，透過Prototype的方式。 Prototype 的產生是為了 JavaScript 的繼承而所謂物件的繼承，就是可以從其他地方拿到本身沒有的方法或是屬性，藉由去繼承有方法跟屬性的物件，來獲得使用那些方法跟屬性的權利。 在JavaScript中，每個object都會去連結到Prototype object =&gt; 每個object都可以看得到裡面有Prototype(null是例外～)。 這個Prototype是[[prototype]]也是原型物件。 舉例來說，創造一個空物件，會看見[[Prototype]]: 但是用Object.create使用null當原型的這個新物件是會看到no properties，很乾淨的那種。 Prototype object 包含了 properties(屬性) 跟 methods(方法)簡單解釋一下什麼是properties跟methods。首先要先知道物件會有key-value pairs，接著看下方程式碼： 12345678const fruit = { name: &quot;apple&quot;, // name =&gt; properties weight: &quot;300g&quot;, // weight =&gt; properties callSell: function () { console.log(&quot;好吃的蘋果，快來給我買&quot;); },}; // callSell =&gt; methods value 是一般值 =&gt; propertiesvalue 是一個函式 =&gt; methods 意思是連結到這個Prototype的所有 object，都可以去使用這個Prototype object的properties以及methods，這就是Prototype的奇妙之處，我沒有但我可以還是用。 再說一次，這種我沒有，但是我還是可以用的行為，其實是一種繼承的概念，因為是用原型來達成的，所以會把它稱為原型繼承。 如何設定Prototype為什麼要設定，要如何設定，讓我用一個例子來舉例： Prototype世界的小白家有餅乾，小紅家有花朵，他們住在不同的地方，要去拿到小白的餅乾，就沒辦法拿到小紅的花朵，反之也是一樣。 想要從小白那邊獲得餅乾，又能拿到花朵，這時候需要電話，比如説小白吃著餅乾，又想要手上拿著花朵，但這時候小白家沒有花朵，但是可以打電話給小紅，叫她把花給速速送過來。 這個電話號碼其實就是Object.setPrototypeOf。 這個語法會需要兩個參數，如下用 A 跟 B 來表示: 1Object.setPrototypeOf(A, B) 第一個參數 A 代表的是要設定原型的物件，第二個參數 B 代表的是參數 A 的新原型物件。 所以在這邊可以藉由小白獲得了小紅的電話號碼，獲得可以拿到小紅花朵這個概念，拿來比擬小白透過 Object.setPrototypeOf() 將「小紅指定為原型」。 用這個例子的範例來說，程式會長這樣: 12345678910111213// 小白擁有很多餅乾const white = { cookies: true };// 小紅擁有很多花朵const red = { flowers: true };// 小白獲得了可以打給小紅的電話號碼// 指定 red 為 white 的 PrototypeObject.setPrototypeOf(white, red);// 真是太好了，現在去找小白也能獲得花朵console.log(&quot;flowers&quot; in white); // true//這是不太嚴謹的例子，因為現實中可能多試幾次後小白那邊就拿不到花朵，因為電話打太多次小紅會把小白封鎖。 在上面的程式裡面，小白就是物件，小紅就是原型物件，小白可以指定原型物件(打電話)，來獲得原型物件的東西。 那假如我今天又想要在小白家拿到披薩呢? 現在知道說，小綠家有很多披薩，一樣把他的電話新增到小白手機裡，讓小白打電話給他。 123456789101112131415const white = { cookies: true };const red = { flowers: true };Object.setPrototypeOf(white, red);// 小綠擁有很多披薩 (小知識:pizza是不可數名詞，可以不用加s)const green = { pizza: true };Object.setPrototypeOf(white, green);// 又多一個朋友，今晚我想來點餅乾+花朵+披薩console.log(&quot;cookies&quot; in white); // trueconsole.log(&quot;flowers&quot; in white); // falseconsole.log(&quot;pizza&quot; in white); // true// 從小白家竟然拿不到小紅的花朵，難道小紅生氣了嗎? 小白家拿不到小紅的花朵，其實是因為Prototype世界的電話，一次只能存取一個電話號碼，小白手機裡面原本是存小紅電話號碼，但後來新增了小綠電話號碼，小紅的就消失了。 小白沒有在記別人電話號碼的，手機裡號碼不見了就不見了，現在只剩下小綠電話號碼，所以只能從小白家獲取小綠披薩。 重點 : 物件只能指定一種原型物件。 小白苦思著，竟然一次只能存取一個電話號碼，突然，小白靈光乍現，他想到了，只要叫小綠去用他的手機存取小紅電話不就好了嗎? 他打電話給小綠，小綠再打電話給小紅，之後再全部拿到小白家。 123456789101112const white = { cookies: true };const red = { flowers: true };const green = { pizza: true };Object.setPrototypeOf(white, green);// 小綠獲得了小紅的電話號碼，可以打電話給小紅Object.setPrototypeOf(green, red);// 太好了，現在從小白家就能拿到花朵跟披薩，大家都很開心console.log(&quot;cookies&quot; in white); // trueconsole.log(&quot;flowers&quot; in white); // trueconsole.log(&quot;pizza&quot; in white); // true 透過這個友善的故事，希望能讓大家對於原型這個概念有個初步的理解，另外我還有在學習時看到一些不錯的比喻，寫得很棒歡迎去看 : 藉由洛克人打贏 boss 就會獲得 boss 新武器的機制來做原型的比喻。來自於重新認識 JavaScript: Day 24 物件與原型鏈 藉由猜謎問問題，遇到不會的問題就問其他人，來做原型的比喻。來自於忍者：JavaScript 開發技巧探秘, 2/e 設定Prototype其他方式除了setPrototypeOf()之外其實也有一個方法可以去設定原型物件，就是__proto__，一樣可以讓小白拿到小紅的花: 1234567const white = { cookies: true };const red = { flowers: true };white.__proto__ = red;// 設定 小白的原型物件是小紅console.log(&quot;flowers&quot; in white); //true 雖然它可以也可以拿來設定，不過我們一般不會使用它，因為它已經被認為過時以及超級不推薦使用，現在都會建議使用setPrototypeOf()，我會發現是因為研究時 MDN 上看到，要是你在 MDN 上面有查過__proto__這個語法的話，你會發現點開映入眼簾的是很多的警告，很可怕，有興趣可以研究。圖片來源:MDN 構造函式的原型我快寫不完，最後簡單介紹一下構造函式的原型，構造函式創個一個新的物件時，這個新的物件會被設定原型，原型物件就是構造函式，可能有些人不知道什麼是構造函式，但今天再詳細解釋會有點太長，所以關於這個以後會專門做一期文章給大家講解。 簡單一個小範例介紹: 1234function Food(name) { this.name = name;}const apple = new Food(&quot;apple&quot;); Food 就是建構函式，然後藉由 new 去實例出 apple，這個新創造出來的物件，會被存到這個變數 apple 裡面。 然後這個 apple 它的原型物件就會是 Food，我們可以來驗證一下這件事情。 1console.log(apple.__proto__ === Food.prototype); // true 結果沒錯，相當於就是這個新的物件會繼承構造函式的原型。 明天會繼續接著講原型鏈的 reference[1] MDN - Object prototypes[2] W3Schools - JavaScript Object Prototypes[3] JS 原力覺醒 Day21 - 原型","link":"/2022/09/17/JS02/"},{"title":"JS之路 Day08 - What is Set ?","text":"前言這兩天會來講Set/Map，這是ES6後才新增的兩種資料結構，主要是用來處理一些array跟object沒辦法完全顧及的領域，也因如此，其實許多地方跟array跟object非常相似，那今天就從set開始吧！ set是集合的意思，在JavaScript裡是唯一值的集合，意思就是說，set裡面的每一個值都只能出現一次。 什麼是集合？set 的中文翻譯是集合的意思，在 JavaScript 裡這個語法是唯一值的集合，而數學上的集合定義，去爬了維基百科，得到以下結論： 指具有某種特定性質的事物的母體，集合裡的事物稱作元素。 下圖就是一個有一些多邊形的集合。關於集合我的理解是可以把它當作一堆類型差不多的東西，而在JavaScript就是一堆值，而在array確實就只有一大堆值，跟Set的差別就在於，JS 的Set值是獨一無二的。 出處: https://zh.wikipedia.org/zh-tw/%E9%9B%86%E5%90%88_%28%E6%95%B0%E5%AD%A6%29set常用方法與屬性 new Set() =&gt; 創建一個set add() =&gt; 往set裡面新增一個元素 delete() =&gt; 從set裡面刪除一個元素 has() =&gt; 判斷set有沒有存在指定的元素 clear() =&gt; 刪除set裡面所有東西 size =&gt; 回傳整個set裡面元素的種類量 以下簡單實作一次： 123456789101112131415161718192021222324252627const vicSet = new Set([1, 2, 2, 3]);console.log(vicSet); // Set(3) { 1, 2, 3 }// ↑一開始創建出來，set裡面是空的set.add(4);console.log(vicSet); // Set(4) { 1, 2, 3, 4 }// ↑幫set新增加了4這個元素進去set.delete(1);console.log(vicSet); // Set(3) { 2, 3, 4 }// ↑把1這個元素從set完整的刪除console.log(vicSet.has(1), vicSet.has(2)); // false true// ↑判斷set裡面有沒有這些指定的元素console.log(vicSet.size); // 3// ↑這個屬性將會找出set裡面元素的種類set.clear();console.log(vicSet); // Set(0) {}// ↑把map裡面所有東西都清空 拿不出的值，跟沒有 index 的Set我嘗試從set裡面拿到值，但發現拿不出來，why? 12345let vicSet = new Set([1, 2, 3, 4, 5]);console.log(cicSet[0]);// undefined 因為set實際上就沒有 index，所以沒有辦法從set獲取值，可能也沒有必要，不然就會發明出一個叫做 get()的方法對吧？ 我想只需要知道，某一個值是不是還存在於集合裡面，所以有 has()的方法可以檢查，畢竟set的特點是獨一無二的值，都是唯一的，順序沒有意義。 沒有必要在set獲取值的原因是，如果目的是為了按照順序存取值，然後去獲取它，**那就應該要去用array，而不是Set**。 可以想像成是，假如我有五顆蘋果要塞入一個盤子集合裡面： 用set的方式 =&gt; 盤子裡有一個種類 - 蘋果 (不知道誰先誰後)。用array的方式 =&gt; 蘋果陸陸續續地進到了盤子裡面 (知道誰先誰後)。 123456const plate = [&quot;apple&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;apple&quot;];console.log(plate[3]); // apple, 第四顆進去的蘋果const plate2 = new Set();plate2.add([&quot;apple&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;apple&quot;]);console.log(plate2); //Set(1), 一個種類 蘋果 那我又想要有set的特性，又想要有array的 index 使用方式要怎麼做？用set把資料都處理完後，再轉成array，就可以了。 12345let vicSet = new Set([1, 2, 3, 4, 5]);let arrVicSet = Array.from(vicSet);console.log(arrVicSet[0]); // 1 Set 可以被迭代這代表著使用 for..of 或 forEach 来遍歷 Set。基本上跟array都一樣，因為都是 Iterable(可迭代)。 12345678910111213141516let set = new Set([&quot;apple&quot;, &quot;vic&quot;, &quot;book&quot;]);for (const order of set) { console.log(&quot;for..of 方法: &quot; + order);}set.forEach((order) =&gt; { console.log(&quot;forEach: &quot; + order);});// for..of 方法: apple// for..of 方法: vic// for..of 方法: book// forEach: apple// forEach: vic// forEach: book Set迭代方法 set.keys() =&gt; 遍歷 set set.values() =&gt; 遍歷 set entries() =&gt; 遍歷 set 後再返回一個實體 1234567const vicSet = new Set([1, 2, 2, 3, 4, 5]);console.log(vicSet.keys()); //[Set Iterator] { 1, 2, 3, 4, 5 }console.log(vicSet.values()); //[Set Iterator] { 1, 2, 3, 4, 5 }console.log(vicSet.entries()); //[Set Entries] { [ 1, 1 ], [ 2, 2 ], [ 3, 3 ], [ 4, 4 ], [ 5, 5 ] } Set 實際上使用時機=&gt; 刪除 arr 的重複值這邊會用到一個概念 Spread Operator(展開運算符)。 Spread Operatores6 才出來的一個新語法，來介紹一下它的作用。其實就是展開的概念，看下面我寫的簡單範例應該就能了解。 12345const A = [4, 5, 6];const B = [1, 2, 3, ...A];console.log(B); //[ 1, 2, 3, 4, 5, 6 ] ...在當Spread Operator時，後面一定接著一個陣列，然後功用就是會把這個陣列給展開，像是上面範例那樣，常常用於來連接陣列，但是還有另外一種方法。 只要...前面沒東西時，後面也是會展開，但因為前面沒東西，就像是直接複製的感覺，所以也可以來當作陣列的淺拷貝(淺拷貝意思是改 arr2 不會影響到 arr)。 1234const arr = [1, 2, 3];const arr2 = [...arr];console.log(arr2); //[1, 2, 3] 方法一使用剛剛前面講到的Spread Operator，搭配set的特性，先把陣列裡面的值都變成set獨一無二的值之後，再用Spread Operator複製起來到一個新的陣列，大功告成。 123456789function unique(arr) { return [...new Set(arr)];}let values = [1, 2, 2, 2, 3, 4, 4, 4, 5, 5];let newValues = unique(values);console.log(newValues); // [ 1, 2, 3, 4, 5 ] 方法二首先要先了解Array.from是什麼，在這裡要知道的是它可以把set的東西轉成陣列，所以一樣是先把陣列裡面的值都變成set獨一無二的值之後，再轉成一個新的陣列，完成。 123456789function unique(arr) { return Array.from(new Set(arr));}let values = [1, 2, 2, 2, 3, 4, 4, 4, 5, 5];let newValues = unique(values);console.log(newValues); // [ 1, 2, 3, 4, 5 ] WeakSet最後來講講跟Set長得很像的WeakSet，其實不會差太多，但還是有一些差異。 像是會習慣在Set使用array但是在WeakSet使用時會報錯，這是因為在WeakSet只能增加object。 123let set = new WeakSet([1, 2, 3, 4, 5]);console.log(set); //TypeError: Invalid value used in weak set 而跟WeakSet一樣的地方是會保留Set的一些方法： add() delete() has() 但是size就沒辦法使用要特別注意。 那Set要變成WeakSet的用意在哪裡？從字面意思上來看，weak是虛弱的意思，而虛弱的Set也沒辦法讓人直覺想到東西。 從 MDN 的解釋來看： The WeakSet is weak, meaning references to objects in a WeakSet are held weakly. If no other references to an object stored in the WeakSet exist, those objects can be garbage collected. 來源：MDN 後面那段大意是說如果不存在對儲存在物件的其他引用，就可以把這些物件進行垃圾回收。 意思是如果有個物件使用 WeakSet之後，如果其他物件都不再引用這個物件，那就會有一個垃圾回收的機制，這個機制可能就是把這個對象所佔用的內存通通消滅掉，丟到垃圾桶。 這樣做有一些好處，首先變成Weak(弱)狀態的同時，可以想像成多了一個空間，可以拿來檢查，同時因為有Set的特性，獨一無二沒辦法重複。 主要用來判斷是跟否，而不是拿來做使用，所以是沒辦法拿出來獲取的。 12345678910111213let weakSet = new WeakSet();let a = { a: 1 };let b = { b: 1 };let c = { c: 1 };weakSet.add(a);weakSet.add(b);console.log(weakSet); // WeakSet { &lt;items unknown&gt; }console.log(weakSet.has(a)); // trueconsole.log(weakSet.has(c)); // false 要直接清除掉只要再使用null就好。 12a = null;console.log(weakSet.has(a)); // false 簡單來說，WeakSet可以做的幾件事情： 幫其他地方的物件做一個額外的存取空間(集合)。 將物件弱連結(weak)到集合中 =&gt; add() 。 判斷這個物件有沒有成功有連結(佔用)了 =&gt; true、false。 從集合中刪除這個物件 =&gt; null 。 什麼情境會使用到呢？個人覺得是很怕犯錯，需要避免錯誤時，可以在這個被「隔離」的集合內做檢查。 而 MDN 上面有提到說，可以用來檢測循環引用，這個我看起來也因為需要避免錯誤(迭代時涉及循環引用的錯誤)，有興趣可以去研究看看。 reference[1] MDN - Set[2] W3Schools - JavaScript Sets[3] The Modern JavaScript Tutorial - Map and Set[4] JS 原力覺醒 Day29 - Set / Map[5] PJCHENder -JavaScript 集合（Set）[6] 前端工程師用 javaScript 學演算法 - 集合 Set[7] 維基百科 - 集合 (數學)[8] How to get index based value from Set","link":"/2022/09/23/JS08/"},{"title":"JS之路 Day06 - 語法糖Class(上)","text":"前言在介紹完prototype之後，該是來理解JavaScript的class，之前有提到說，JavaScript的繼承依靠的是Prototypal inheritance，但並不是所有的程式語言都是如此，我覺得要理解class的話要從這裡下手，那就開始吧。 其他程式語言的繼承之前有提到過繼承，其實道理差不多，一個物件可以將自己的屬性跟方法給其他人使用，換句話說，一個物件可以去取用別人物件的屬性跟方法。 在JavaScript中，這種可以被取用屬性跟方法的物件是原型物件，透過原型鏈來找到跟綁定，但是在其他語言中，像是java或是c++就會直接把這個可以被取用屬性跟方法的物件視為class，一個類別的概念。 關於類別的比喻，有一個我覺得很不錯，出處是在：JavaScript 概念三明治。 class其實就是像建築物的設計圖一樣，而建築物就可以透過裡面所描述的概念來寫現做出來。 class(類別) =&gt; 設計圖。object(物件) =&gt; 建築物。 然後有了 class(類別)就可以創造出許多的instance(實例)，透過用new的方式，非常合理，但是JavaScript做不到。 原因如下： JavaScript 完全沒有設計 class 的概念。 此 class 非彼 class書上看到有這樣寫，不過沒寫原因不太懂，為了探究真相，我開始上網 google，下了一些像是what javascript no class？或是What are classes in Javascript?的關鍵字。 其中有一篇在 stackoverflow 上的Does JavaScript have classes?看到很多高手在談論這個議題，最後的結論是確實在JavaScript是沒有實作class的機制的。 對，然後你會發現今天的主題也是class，但這其實沒有衝突，因為都沒有錯，確實是沒有class但因為想要模擬其他程式語言可以使用class的特性，所以在 es6 之後，JavaScript特別添加了叫做class的關鍵字。 所以難道這就代表著JavaScript就此獲得了class?我的答案是否定的，沒有的東西就是沒有，JavaScript從來就沒辦法靠著類別的方式來繼承東西，是依靠原型的，所以就算 es6 之後有了 class 的關鍵字，那也是用原型的實作，來看起來很像類別的實作而已，還是不一樣的。 而別的程式語言都用類別方式繼承好好的，為什麼JavaScript要特立獨行，使用跟別人不一樣的方式(原型)，我的猜測是作者最初開始在設計JavaScript不想要把它設計的太難，這也是它為什麼看起來這麼不嚴謹的原因，這點從 JavaScript 僅用了 10 天就創造出來就可以看出。 雖然因為不想要弄的太複雜所以沒有引入 class 的機制，但還是需要有東西去把所有的物件連接再一起去運作，為此依舊得需要「繼承」的概念。 而上面有提到說，其他很多的程式語言，都是透過 new 的方式把一個 class 的東西給創造出來變成 instance。 但是JavaScript沒有 class，但是它想到了一個辦法。 那就是使用我們昨天才講到的 Constructor Function(構造函式)，利用 constructor 當作像是 class 一樣，然後藉由去 new 它一樣可以創造出 instance。 可是不會完全跟 class 繼承一樣，會非常的不完全，因為利用 constructor 所創造的 instance 根本沒有辦法共享所有的 properies 跟 methods。 所以才會後來才會創造出，原型這個概念，藉由讓 constructor 獲得原型的這個屬性，真正的讓 constructor 所創造的每一個 instance 都可以共享這個原型物件裡面所有的 properies 跟 methods。 剛剛在那篇高手討論JavaScript到底有沒有 class 的文章中，最佳回答是這樣回答的，我覺得蠻合理的： echnically, the statement “JavaScript has no classes” is correct. Although JavaScript is object-oriented language, it isn’t a class-based language—it’s a prototype-based language. There are differences between these two approaches, but since it is possible to use JavaScript like a class-based language, many people (including myself) often simply refer to the constructor functions as “classes”. 大意是說，雖然JavaScript是一種 oop 的程式語言，但是不是基於class的語言，而是基於prototype的語言，雖然這兩種的方式有著差異的存在，但是其實可以把JavaScript也當作是基於class的語言(實際上不是)，因此許多人也會把constructor簡單的看做是class。 小結：JavaScript沒有class但是有object，大家所說在JavaScript的「class」實際上是object(constructor)。 好，那開始進入這篇文章的主題，Class(類別) =&gt; es6 新增關鍵字。 class 與語法糖第一件事情，JavaScript中的Class是一個語法糖，然後語法糖其實我第一次聽到也不知道，所以我有去研究，先來解釋這個部分。 根據維基百科上面的解釋，語法糖是： 語法糖（英語：Syntactic sugar）是由英國電腦科學家彼得·蘭丁發明的一個術語，指電腦語言中添加的某種語法，這種語法對語言的功能沒有影響，但是更方便程式設計師使用。語法糖讓程式更加簡潔，有更高的可讀性。出處： https://zh.m.wikipedia.org/zh-tw/%E8%AF%AD%E6%B3%95%E7%B3%96 好的，其實就是一個可以用更簡單的方式來表達語法的做法，所以話拉回來，Class 這個語法糖確實也可以做到原型繼承的部分，但是它的原理依舊是使用原型的方式，然後其實也會使用到 Constructor 的概念，很高興這些前幾天都講過了，還沒看的可以回去前幾天複習再往下看，那馬上開始今天的介紹！ 直接來做例子來了解其原理。 由於ES6之後才有Class，所以之前沒有Class時，會比較常使用Constructor來實現原型繼承，ES6之後有了Class會用Class，畢竟是語法糖，方便直覺很多，接下來就來兩種都做做看。 Constructor VS Class由Constructor先攻： 12345678910111213function Food(fruit, color) { this.fruit = fruit; this.color = color;}Food.prototype.saySell = function () { console.log(&quot;快來買蘋果！！！&quot;);};const apple = new Food(&quot;apple&quot;, &quot;red&quot;);apple.saySell();//快來買蘋果！！！ 我首先寫了一個準備要被new建立的函式，第一個英文字母記得大寫(細節)，然後透過原型的方式，把方法指定給Food這個原型裡面，接著用new來建立構造函式，讓我的apple這個新的變數，也可以使用saySell這個方法 =&gt; 快來買蘋果！！！ 換Class的回合： 1234567891011121314class Food { constructor(fruit, color) { this.fruit = fruit; this.color = color; } saySell() { console.log(&quot;快來買蘋果！！！&quot;); }}const apple = new Food(&quot;apple&quot;, &quot;red&quot;);apple.saySell(); 這是一個使用了ES6 Class的神奇方法，跟上面差不多，不過仔細上可以發現許多優點。 先來說明使用Class的流程，一開始使用Class這個關鍵字來創，然後Class後面是名稱，一樣要細節大寫，不同的是，內部就會直接塞一個constructor的函式，而這個函式的方法，就直接寫在了裡面。 需要方法的話，就直接把方法給塞進去Class裡面就好了，就在constructor的函式下方。 這是一件十分酷的事情，因為我就不需要自己再寫什麼.prototype把方法塞進去，Class就會自動幫我完成這件事情，語法糖，讚。 因為實驗精神的關係，來證明吧： 12console.log(apple.__proto__ === Food.prototype);// true 結果是 ture，確實有原型繼承到。 這一切都跟單純使用Constructor的方法差不多，但是使用Class會簡單一些，直覺一些，乾淨一些，結論就是多多使用Class。 基本 Class 要知道今天的部分來做一個小總結，由上面可以知道，其實Class的語法有一個固定模式，把它列出來的話會長這個樣子： 12345678910111213141516class MyClass { //就是你想的那個構造函式 constructor() { ... } //這邊直接寫class的方法 method1() { ... } method2() { ... } method3() { ... } ... //剛new就會自動調用constructor() const vic = new MyClass( ... ); //方法要用自己new後再調用 vic.method1();} class後面的名字不用()，它是用來創造instance不是用來執行的。 不用()但是名字要大寫，跟之前constructor差不多概念。 new 之後會自動調用 constructor()裡的方法，所以可以藉由 constructor()初始化所創造出來新的instance。 其他的方法不會自動調用，要用自己再 new 之後去調用它。 reference[1] 原型基礎物件導向[2] 維基百科 - 物件導向程式設計[3] What is the difference between classical and prototypal inheritance?","link":"/2022/09/21/JS06/"},{"title":"JS之路 Day09 - What is Map ?","text":"前言昨天把set講完，今天換Map，首先要注意不要跟array的方法Array.prototype.map()搞混，這是不一樣的東西，那就 let’s go 今天的主題。 Map跟object一樣都是key-value pairs，不同的是Map的key可以是任意類型。 map 的基本方法跟屬性 new Map() =&gt; 創造 map。 set() =&gt; 為 map 裡面設定 key 跟 value。 get() =&gt; 取出 map 裡面的 key 跟 value。 delete() =&gt; 刪除 map 裡面的 key。 has() =&gt; map 裡存在指定的 key。 clear() =&gt; 刪除 map 裡面所有東西。 size =&gt; 會回傳 map 裡面元素的數量。 有些其實跟set來使用看看吧： 12345678910111213141516171819202122232425262728293031323334const map = new Map();console.log(map); // Map(0) {}// ↑一開始創建出來，map裡面是空的map.set(1, &quot;a&quot;);map.set(2, &quot;b&quot;);map.set(3, &quot;c&quot;);console.log(map); // Map(3) { 1 =&gt; 'a', 2 =&gt; 'b', 3 =&gt; 'c' }// ↑幫map新設定了三組key跟valueconsole.log(map.get(1)); // a// ↑從map裡面取出key是1的valuemap.delete(1);console.log(map); // Map(2) { 2 =&gt; 'b', 3 =&gt; 'c' }// ↑把map裡面key是1的那一個key-value pairs刪除console.log(map.has(1)); // falseconsole.log(map.has(2)); // true// ↑判斷map裡面有沒有叫做1跟2的keyconsole.log(map.size); // 2// ↑map裡面數量有兩個map.clear();console.log(map); // Map(0) {}// ↑把map裡面所有東西都清空 除了用set()添加元素外，也能透過array添加先創立一個Map的空間出來，再set()是比較直覺添加元素的方式，但其實也可以直接在創建時就添加完畢，只要最開始創建的new Map()就直接塞array就可以達成。 12345678const fruits = new Map([ [&quot;apple&quot;, 10], [&quot;banana&quot;, 5], [&quot;orange&quot;, 10],]);console.log(fruits);// Map(3) { 'apple' =&gt; 10, 'banana' =&gt; 5, 'orange' =&gt; 10 } set()除了可以添加元素外，也可以重新設置現有元素set()在完全沒有東西時，是添加元素的功能，但在已經有東西的地方上，假如又在使用set()添加在同一個key東西上去，會直接覆蓋上一個key的value，因為同一組key只能同時擁有一組value，而這種方式也能達到重新設置現有元素的功能。 1234567const fruits = new Map();fruits.set(&quot;apple&quot;, 10);console.log(fruits); // Map(1) { 'apple' =&gt; 10 }fruits.set(&quot;apple&quot;, 5);console.log(fruits); // Map(1) { 'apple' =&gt; 5 } 創立 map 是使用new Map()，那我不想new行不行？不行，Map一定只能用new operator來建立，JavaScript就是這樣規定的，不這樣做就會送你報錯。 123const map = Map();//TypeError: Constructor Map requires 'new' 可以理解成一些特別的內建物件會需要用構造函數的方式來進行物件的實體化。順帶一提，Set也是一定要用new operator，不然會送報錯。 Map 用途當希望物件的key不會重複時，可以使用Map，或者是想要讓物件的key是各種型別的時候。 還有順序如果很重要的話，就會考慮使用Map，因為使用Map時元素的使用順序會被保留。 reference[1] MDN - Map[2] W3Schools - JavaScript Maps[3] The Modern JavaScript Tutorial - Map and Set[4] JS 原力覺醒 Day29 - Set / Map[5] PJCHENder -JavaScript Map[6] 前端工程師用 javaScript 學演算法 - Map","link":"/2022/09/24/JS09/"},{"title":"JS之路 Day10 - What is Date ?","text":"一種用來處理特定的日期時間會用到的特殊物件，可以用來印出時間，修改時間或是設定時間。 要注意的一點是，JavaScript當中，使用Date就會一次把日期跟跟時間創造出來，不能只單獨創造出今天日期。 最簡單的使用方式就是直接new Date()就能直接創造出當前的時間。 12const time = new Date();console.log(time); // 印出當前時間 隨時放入參數的不同可以印出各種不同狀態的時間。new Date()是一種，另外還有三種創建時可以創建時的方式: 123const time = new Date(milliseconds); //第二種const time = new Date(dateString); //第三種const time = new Date(year, month, day, hours, minutes, seconds, milliseconds); //第四種 獲取時間中某個值有一些Date內建的方法，可以幫助獲取時間的某個值，可以分成以下幾種。 現在時間是 2022 年 9 月 25 日(星期日），使用此時此刻來做舉例，先從取全部開始。 123const time = new Date();console.log(time); // 2022-09-25T02:40:23.378Z getFullYear():可以獲取年份，四位數的那種。 1234const time = new Date();const year = time.getFullYear();console.log(year); // 2022 getMonth():可以獲取月份，範圍從 1~11(沒有 12)。實際是 9 月，但是顯示抓取會是 8 月，這點要特別注意。 1234const time = new Date();const month = time.getMonth();console.log(month); // 8 getDay():可以獲取目前是為一週裡面的第幾天，從星期日開始，所以 0 是星期日，直到 6 是星期六。 1234const time = new Date();const day = time.getDay();console.log(day); //0 getDate():可以獲取目前是一月裡面的第幾天，從 1 到 31。 1234const time = new Date();const date = time.getDate();console.log(date); //25 比較不直覺的有getMonth()跟getDay()，它們回傳出來的值不能直接是真正的月份跟星期，還需要再透過其他方式來轉換，不過仔細想想也蠻合理，因為月份跟星期在不同地區可能都有不同的規劃，像是說台灣會叫做「星期」其他地方不一定這樣叫，所以Date在這一塊只給一個回傳值，會從 0 開始應該是為了搭配陣列的方式，所以拿到這個回傳值，再搭配自己設定好名字的陣列，就可以取得真正的月份跟星期的值，比如說 1 月=&gt;array[0]=1 月。 還有一些要取得更小單位的時間值，像是幾時幾分幾秒，都有相對應的方法，跟上面使用方法都大同小異，如下： getHours() getMinutes() getSeconds() getMilliseconds() 設定時間除了獲取時間訊息的「get」之外，有也相對應的「set」，專門用來設定某種時間的格式，例如getDate()是獲取回傳的是第幾天，setDate()就是設定目前時間是第幾天，常用的語法如下： setFullYear(year, [month], [date]) setMonth(month, [date]) setDate(date) setHours(hour, [min], [sec], [ms]) setMinutes(min, [sec], [ms]) setSeconds(sec, [ms]) setMilliseconds(ms) setTime(milliseconds) 設定之外的東西就會維持原來的設定，舉個例子，一樣先用new Date()創造出當前的時間，再用set修改： 123const time = new Date();time.setFullYear(2000);console.log(time); //從2022變成2000 其他方式就大同小異，想改什麼就直接改。 本地化本地化的意思，是根據本地的文化或是語言來顯示印出的東西。必要性可以從完全沒經過本地化的案例來看，一樣使用new Date()就能直接創造出當前的時間： 12const time = new Date();console.log(time); // 2022-09-25T03:17:31.197Z 直接出來的東西是 2022-09-25T03:17:31.197Z，而使用本地化的方式像是console.log(date.toLocaleString()) 就會是：2022/9/25 上午11:18:54。 看起來會更好辨認，日期，時間，貨幣都可以使用這種本地化的方式，但今天主要聚焦在Date這一塊。 12345const date = new Date();console.log(date.toLocaleString()); // 2022/9/25 上午11:22:28console.log(date.toLocaleDateString()); // 2022/9/25console.log(date.toLocaleTimeString()); //上午11:22:28 Autocorrection當不小心把時間使用set的方式設定超過範圍，Date就會自動進行一個Autocorrection的動作，也就是自動校準，這非常實用。 也不會需要主動去使用，因為這是一個Date的特性。 比如說： 12let time = new Date(2022, 0, 50); // 原本 2022 01 50console.log(time); // ? 一個月不可能有那麼多天，就會把剩餘超過的Autocorrection到下一個月，所以最後出來的結果會是2022-02-18。 總結在JavaScript中要處理到時間跟日期就會碰到Date，像是可能網頁上需要做一個時鐘，或是倒數計時器，使用方法上看起來都蠻直覺，但還有很多小地方需要注意，今天其實還有蠻多Date部分還沒講到，像是Date.now()、 Date.parse，或是一堆還沒講到方法，有興趣可以再去看 MDN 的文檔，連結有放最下面。 最後有一個蠻有趣的現象，就是可以試試看new Date() + 1跟new Date() - 1這兩種方式個別印出來的結果，我個人是一頭霧水，知道原因的高手可以在下方留言告訴我，那我們明天見。 12console.log(new Date() + 1); // ??console.log(new Date() - 1); // ?? reference[1] MDN - Date[2] Date and time[3] JavaScript Date Objects[4] 日期與時間","link":"/2022/09/25/JS10/"},{"title":"JS之路 Day14 - Promise(承諾)","text":"前言Promise在程式中非常好用，是因為很多操作都需要使用到非同步的概念，而要處理非同步，除了使用callback function之外，就是會使用Promise。 這篇講述我是如何理解這個概念。 今天主要講Promise的狀態跟呼叫。 Promise是一個constructor function，假如需要自己寫一個Promise時，語法如下： 1234const promise = new Promise((resolve, reject) =&gt; { resolve(value); reject(error);}); 它的參數resolve以及reject是它自己所提供的callback，不用自己額外寫，而這兩個的名稱可以自己定義像是： 1234const promise = new Promise((a, b) =&gt; { a(); b();}); 效果也一樣，但是不建議這麼做。 而會設定這兩個參數，是有它的意義存在，從承諾來談吧。 Promise 狀態可以把它想像成一個承諾，答應了某件事情，不管最後有沒有成功，都會有一個結果。 所以兩個參數的意義在於，成功跟失敗時會獲得什麼結果，所以當程式正在進行一個Promise的非同步時，如果成功就會呼叫resolve如果失敗就會呼叫reject，這裡要注意的是假設已經呼叫成功的結果了，那就回不去還沒決定的狀態，這是不可逆的，成功以及失敗只能選一個，回傳了這個結果之後，Promise就會結束。 最初的時候，是未確認的狀態，也就是pending，接著成功的話會變成Fulfilled的狀態，失敗就會是Rejected。 舉例來說，小白跟小紅告白了。 前情提要，因為promise的特性一定得非同步的方式進行，代表著被告白的時候，就算遇到白馬王子，也沒辦法馬上秒答應，同樣的就算遇到非心儀對象，也不能馬上送出一張好人卡。 也就代表說，使用了promise的狀態，任何人都會一模一樣的以非同步的方式一致得到結果，像是小白也不會以同步的方式馬上被拒絕，這種藉由讓大家用統一的方式處理非同步就是promise的好處之一，而接下來小白就要開始行動了，讓我們看下去。 小白： 「我喜歡妳！」 =&gt; promise 事件開始，現在狀態是 pending。 小紅： 「let me think think.」 =&gt; 非同步開始排隊等待了，答案醞釀。 小白： 「你慢慢想！」 =&gt; 等待非同步時間結束。 — 兩天後 — 小紅： 「deserving of better people.」=&gt; 被拒絕，現在狀態是 rejected。 小白： 「……」 =&gt; 小白 catch 到了這個 reject。 小紅： 「you are friends forever.」=&gt; 小紅傳入 rejected 函式。 小白： 「好吧，那就還是朋友。」 =&gt; 小白知道回不去了(狀態不可逆)。 Promise 呼叫當寫好了一個Promise，裡面已經定義好了失敗以及成功的結果後，但要取出這些結果，還需要一些方法，主要如下： then() catch() finally() 把上面的例子寫成程式： 123456789const mission = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&quot;you are friends forever&quot;); }, 200);});mission.catch((answer) =&gt; { console.log(answer); //you are friends forever}); then會捕獲成功的結果，catch則相反是失敗的，像是在這邊就可以利用catch去抓到reject裡面的函式。 使用then時會捕獲成功的結果，語法會像這樣： 1234promise.then( (result) =&gt; {}, (error) =&gt; {}); 第一個參數是成功的結果，第二個參數是失敗的，所以也可以用then去抓失敗的結果，像是這樣： 12345678910const mission = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&quot;you are friends forever&quot;); }, 200);});mission.then( (result) =&gt; console.log(result), (error) =&gt; console.log(error)); // you are friends forever 最後一個是Finally，這個方式不會有任何參數，因為不需要，可以用這個方式來確認整個promise已經結束了。 1234567891011121314151617const mission = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&quot;you are friends forever&quot;); }, 200);});mission .then( (result) =&gt; console.log(result), (error) =&gt; console.log(error) ) .finally(() =&gt; { console.log(&quot;小白:一切都已經結束了&quot;); });// you are friends forever// 小白:一切都已經結束了 總結執行的函式最後一定會回傳值，就算沒有寫也是回傳undefined，而在Promise來說，設計Promise物件最後的結果要不是回傳一個成功的值，不然就是失敗的值， fulfilled或是rejected，最後再複習一次，Promise的狀態只會有這三種。 pending(等待中) fulfilled(已實現) rejected(已拒絕) 就算是非同步，也是有需要一個接著一個執行的狀況，其實Promise後面也是能繼續連著Promise的，就是所謂的Promises chaining，明天的文章主題，明天見。 reference[1] 淺談 JavaScript 的 Promise[2] MDN - Promise[3] 你今天 Promise 了嗎？","link":"/2022/09/29/JS14/"},{"title":"JS之路 Day15 - Promise Chain(承諾鏈)","text":"前言有時候很常見會有情況是需要很多的非同步操作，每一個非同步的後續操作都建立在前面的非同步操作的成功，所以會繼續上一步的結果，在使用callback處理這種狀況的時候，就會產生可怕的callback hell，而Promise Chain可以很好的改善這個問題，就讓我們看下去。 ​ promise chain 的使用方式​從看一個例子來了解使用方式。​ 12345678910111213141516171819202122const promise = new Promise(function (resolve) { resolve(1);});​promise .then(function (result) { console.log(result); // 1 return result + 1; }) .then(function (result) { console.log(result); // 2 return result + 1; }) .then(function (result) { console.log(result); // 3 return result + 1; }) .then(function (result) { console.log(result); // 4 return result + 1; });​ ​這是使用了promise方式來處理的promise chain，藉由.then會回傳一個新的 promise，讓每一個在promise chain的promise都代表上一個非同步的步驟已經完成。​注意，return之後的東西是新的promise，所以上一個流程已經結束了，就像是有人等烤吐司機烤完吐司，才去啟動微波爐加熱便當，那麼當他已經走到微波爐準備加熱便當時，就代表烤土司機已經烤完吐司了，雖然這兩個步驟都需要等待，但是不會一起等是獨立的，上一個等完才換下一個等。​而在這個例子中，promise chain運行的流程如下： 初始 promise 會直接把 resolve 結果為 1。 然後 .then 開始作用，會創建一個新的 promise，以上一個的 return 作為值，在這裡是 1。 下一個.then 就會獲得上一個.then 的值(2)，再進行處理之後，會將值傳遞給下一個處理階段。 … 以此類推。​這邊其實會比較沒有非同步的感覺沒有等待，可能用setTimeout的方式似乎比較好，但只要使用promise就一定會使用非同步的方式去進行的，內部的狀態還是會從pending未確認的狀態，變成Fulfilled，而每一次的.then就相當於重新判定一次。​再次強調，這樣做之所以可行的核心是因為每一個 then()後都會回傳一個新的promise。​A 做完後，使用 then()會回傳新的 B，然後再用 B 去做事，做完後再用 then()回傳一個新的 C，這種一層一層傳遞下去，就像是一個鏈子一樣，所以會稱之為Promise Chain。​這裡會引申出一個新的問題，那就是如果把很多的 then()都寫在同一個promise那還叫做Promise Chain嗎？​像是這樣： 123456789101112131415161718let promise = new Promise(function (resolve, reject) { setTimeout(() =&gt; resolve(1), 500);});​promise.then(function (result) { console.log(result); return result * 3;});​promise.then(function (result) { console.log(result); return result * 5;});​promise.then(function (result) { console.log(result); return result * 10;}); ​這樣的話依舊是Promise，依然使用著非同步的方式，但其實就不是Promise Chain，它們沒有連再一起，就只是各自做各自的事情，互不關聯，沒有延續所以也就不會互相傳遞result，所以在這個例子來說，會發現全部印出來的東西都是 1。​我有想到了一個例子：​​Promise Chain 如果吃完蘋果的話，休息五分鐘就去吃香蕉 如果吃完蘋果後跑去吃完香蕉，休息五分鐘就去吃西瓜 如果吃完蘋果後跑去吃完香蕉又去吃了西瓜，休息五分鐘就準備去廁所​​Promise 如果吃完蘋果的話，休息五分鐘就去吃香蕉 如果吃完蘋果的話，休息五分鐘就去吃西瓜 如果吃完蘋果的話，休息五分鐘去去廁所​​​​​ 回傳解決與拒絕前面一直在用 then()來當作Promise Chain的下一個回傳，但其實連接的概念除了 then()之外還有 catch()，差別在於Promise有沒有被拒絕，當一個Promise被解決時，也就是狀態是fulfilled，那麼就會使用 then()返回已經解決的Promise，如果是被拒絕時，也就是狀態rejected，那麼就會使用 catch()來回傳，舉一個例子：​ 123456789101112131415161718192021222324252627282930313233function promise(a) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { if (judge) { resolve(`成功`); } else { reject(&quot;你失敗了謝謝&quot;); } }, 0); });}​promise(1) // 第一次成功，因為是true .then((number) =&gt; { console.log(number); return promise(1); // 第二次成功，因為是true }) .then((number) =&gt; { console.log(number); return promise(0); // 失敗，下面的就不會去看，會直接跳catch }) .then((number) =&gt; { console.log(number); return promise(1); }).then((number) =&gt; { console.log(number); return promise(1234567890); // 不會有反應了 }) .catch((number) =&gt; { console.log(number); });​ 首先，要在自己寫的promise同時存在成功跟失敗的結果，要用成判斷式的型態，因為狀態是不可逆的，pending只要到了fulfilled或是rejected其中一個就再也回不去了。​然後這裡我寫的判斷是，要是值是 true 的時候就會成功，false 的話就會你失敗了謝謝，而正數的時候值會是 true，負數時值會是 false，下方的呼叫寫了三個 then()跟一個 catch()，這裡要測試的是當不管是幾個 then()，只要有一個條件不成立，值是 false，那麼就直接會跳到 catch()那裡去，所以會發現這個程式的結果是： 123成功成功你失敗了謝謝 ​第一個 then()那裡回傳出去的值就已經是負數了，代表會是 false，所以後面的 then()都不用看，會直接到最後的 catch()結果，而如果想要再 catch()再開始繼續也是可以，就直接再傳一個新的promise結果即可。​ 1234567.catch((r) =&gt; { console.log(r); return promise(1); }) .then((r) =&gt; { console.log(r); // 成功 }); ​ 總結除了用then來串鏈形成Promise Chain的方式來處理很多個連續的非同步操作外，也有一種Promise的語法糖，叫做 async/await 的方式，因為原理還是Promise，所以是語法糖，關於這個以後會專門做一期文章給大家講解。​​ reference[1] MDN - Using Promises[2] Promises chaining","link":"/2022/09/30/JS15/"},{"title":"JS之路 Day11 - Callback Funtion(回呼函式)","text":"這其實不是難懂的概念，但卻是非同步程式設計中最基礎的螺絲釘，我自己在學習這 JS 非同步領域這系列的順序是這樣排的： Callback =&gt; Promise =&gt; Async/Await 確保自己了解之後，再往下一個階段邁進，對於認知非同步反而會顯得更加輕鬆，不然容易變成拆東牆補西牆。 這個概念是我從 huli 的JavaScript 中的同步與非同步（上）：先成為 callback 大師吧！學習到的，也是這篇讓我意識到callback的重要性，推薦可以去看。那麼就開始進入今天的主題。 Callback Funtion定義學習一個新的名詞術語，想知道它究竟是什麼，有很多方式，Callback來說的話我覺得可以看 MDN 文檔的定義，寫的蠻好理解： A callback function is a function passed into another function as an argument 中文來說的話就是，當一個函數，作為參數傳遞給另一個函數，就是callback。 舉例來說：小白、小紅、小黃三個人在工作，可以這樣寫。 123whiteWork();redWork();yellowWork(); 雖然程式會確實的從上到下執行，所以看起來沒有問題，但卻不能保證執行的順序，但今天如果使用Callback就可以，像是我想要小白做完後小紅再開始工作，那我就可以把小紅放到小白的Callback裡面。 1234whiteWork(function () { redWork();});yellowWork(); 這樣子的好處，是讓程式的某個函數執行完，再接著執行其他的函式。 那換來看看 MDN 的例子： 12345678910function greeting(name) { alert(`Hello, ${name}`);}function processUserInput(callback) { const name = prompt(&quot;Please enter your name.&quot;); callback(name);}processUserInput(greeting); 這段程式執行後會像是這個樣子。 跳出一個視窗詢問名字。 輸入名字(vic)，按確定 跳出”Hello,vic” 正常沒有使用Callback的版本如下。 123456789function greeting(name) { alert(`Hello, ${name}`);}function processUserInput() { const name = prompt(&quot;Please enter your name.&quot;);}processUserInput();greeting(); 但會發現跟上面不一樣，輸入名字後，卻找不到名字。 這個就是Callback很重要的地方，這種呼叫後順序不一致的狀態，我想要哪個先呼叫，有時候不是先放前面就沒事了，像是在這邊我雖然把processUserInput()放前面，但不代表後面的greeting()就會乖乖的等上面的問題問完才顯示，在JavaScript的世界裡面，會越快完成的事情會先做完，有一件要等待的事情，一件馬上顯示出來的事情時，不管排序都會先去做那馬上可以完成的，那要是有很多件不確定時間的事情，就會完全無法確認順序。 但是有了Callback就不一樣，可以藉由某個做完再呼叫的機制，確保順序，在這種單執行緒的環境下，JavaScript沒辦法像是其他程式語言可以直接多工去同時做很多事情，所以需要有一種「被呼叫才做事」的功能，這也是我理解為什麼需要一個函數，作為參數傳遞給另一個函數的原因。 其他比喻在其他地方有看到一個用工人來解釋Callback Funtion很好懂的比喻，在JS20min Day — 18 關於回呼生活化 (Callback)看到的。 假如小白跟小黃都是工人。 小白是一個正在睡覺的工人，被叫時才會起來工作。而小黃是勤奮型工人，他會去工作，也會去叫小白起來工作。 12345678910function whiteWork() { console.log(&quot;被小黃叫，來去工作&quot;);}function yellowWork(call) { console.log(&quot;先工作，叫小白&quot;); call();}yellowWork(whiteWork); 這樣的執行順序會是： 1.工作，叫小白 2.被小黃叫，來去工作 就是當一個函數，作為參數傳遞給另一個函數，在這邊小白會作為一個參數去傳遞給小黃這個函數，而本身小白也是一個函數。 Callback Hell假如事情一定要一個做完才接著下一個，後面的Callback會需要使用到前面Callback的結果，也就是必須在Callback中再Callback，那整體的架構就勢必沒辦法是平行的，會很複雜，像是這樣。 出處：https://github.com/explooosion/emoji-comment-collection/issues/6 就這是多層環環相扣後所產生的波動拳，不只看起來很是複雜，維護起來時也會很麻煩，這也是為什麼後面還需要使用到promise的原因，關於這部分後續幾天會提到，那今天的介紹就到這邊。 下一篇會講述在JavaScript中的非同步程式設計是怎麼一回事，明天見～ reference[1] MDN - Callback function[2] W3Schools - JavaScript Callbacks[3] The Modern JavaScript Tutorial - Introduction: callbacks[4] You Don’t Know JS - Callbacks[5] 你懂 JavaScript 嗎？#23 Callback[6] 重新認識 JavaScript: Day 18 Callback Function 與 IIFE","link":"/2022/09/26/JS11/"},{"title":"JS之路 Day12 - Asynchronous Programming (非同步程式設計)","text":"前言Asynchronous的中文翻譯是非同步、異步，Synchronous的中文翻譯是同步，以下都會直接用同步、非同步來介紹。 非同步程式設計是JavaScript在學習時一個很大的重點，不光是容易誤解，不好理解，也因為實際上要常常使用到。 這一篇不講太多專業術語跟程式範例，會試著用很白話的方式把非同步這件事情給講清楚，那就直接開始進入今天的主題！ JavaScript是單一執行緒這是我覺得在了解同步跟非同步之前要先理解的第一個點，先完全不要管什麼是同步，什麼是非同步，一開始請先知道這個： Javascript 程式執行，一次只能執行一件事情。 就像是一家餐廳，就只有一個廚師，那他就只能一次煮一道菜，假如有兩個廚師，就是同時煮兩道菜，很多廚師可以同時煮很多菜那就是多執行緒，可以一次同時進行很多事情。 無論如何，要記住這家叫做「Javascript」的餐廳，永遠只有一個廚師(執行緒)。 JavaScript 同步跟非同步剛開始學習時，同步會讓人感覺是，全部的動作同時開始進行，所以容易誤會(誤會同步=同時)。後來去查閱一些資料後發現其實同步是 =&gt; 一次做一件事情。既然同步是一次做一件事情，那非同步不就是一次做很多事情？ 所以會發現到說很多教學文章會這樣寫： 同步：一次就只做一件事情非同步：一次同時做很多件事情 使用”同時間”能處理事情的多寡來區分 JS 的同步跟非同步的文章真的很多。可能這講法也沒有錯，但就會發生衝突，對剛學習沒多久的人造成心靈打擊，造成懂的人看得懂，不懂的人看不懂。 而我的理解 =&gt;單執行緒的JavaScript就像是餐廳的只有一個廚師，假如要說非同步是一次同時做很多件事情，就好似說突然冒出一堆廚師一樣，最主要發生的衝突，就是上面說的： Javascript 程式執行，一次只能做一件事情。 也許可以用很多個廚師，同時做很多事情的方法來做到非同步，但我JavaScript就只有一個廚師，怎麼辦呢？ 先來看看另一個概念吧。 平行(Parallelism)與並行(Concurrency)這個概念是我從執行資料平行處理的效能考量看到的，我覺得可以很好的解釋JavaScript如何在自身只能是單執行緒的情況下，達成到非同步的效果，同時又不會跟單執行緒的特性(一次做一件事情)發生衝突。 以下節錄文章概念： 平行（Parallelism）與並行（Concurrency）不同，如果兩個任務分配到一個 CPU 核心，在取得的時間片段中交互執行，稱之為並行。如果有兩個核心，兩個任務各分配到其中之一同時執行，稱之為平行。現今開發者對於並行設計應不陌生，利用並行運算處理多個流程，讓客戶端以為任務「同時」執行，或者是某任務被阻斷（Block）之時，切換另一任務執行，避免等待而浪費 CPU 執行時間，用以提升整體任務執行效率。 很好的解釋了一些盲點區域，上面有提到很多教學會講說非同步是一次同時做很多事情，其實那就是一種平行處理，確實也是一種非同步，但卻永遠不可能是JavaScript的非同步。 因為JavaScript這間餐廳的廚師就只有一個，要有很多人才能平行耶，我畫示意圖比較清楚。 多人廚師 =&gt; 平行處理 =&gt; 同時做很多菜 =&gt; 大家都很開心： 只有一個廚師 =&gt; 平行處理 =&gt; 同時做很多菜 =&gt; 廚師不開心 ： 那就一個個慢慢做如何？客人不開心。而且中間要是過程有一個卡住，之後的菜也就都不用做了。 欸，那該怎麼辦，我大JavaScript餐廳就是只想請一個廚師，但又不想要廚師只能一個個做，那會花超久時間，聰明的大JavaScript餐廳想到了一個好辦法，剛剛那個是平行處理，那何不來試試並行處理？ 並行處理:交互執行，稱之為並行，要怎麼辦到這件事情，簡單來說就是不卡住，那是什麼意思？比如來說小白今天要做兩件事情，一個是烤土司一個是倒牛奶，而小白今天就只有一個人，所以沒辦法使用平行處理，除非小白會影分身。 除了慢慢來，先烤完吐司再倒牛奶之外，還有另外一種選擇，你可以先把你的吐司塞到烤土司機之後，不要在那邊傻傻等它，按下按鈕開始烤後，就衝去冰箱拿牛奶出來倒，倒完再看吐司好了沒。 這種做完後不停留到完全結束，就直接去做下一步的處理方式其實就是並行處理。 也因為這樣，所以看起來結果會很像是同時開始做，但是並沒有，可以來比較差異時間，請小白為我們示範一下，示意圖有請： 為什麼有一堆人會覺得 JS 非同步就是「同時」做很多事情，我覺得關鍵這就是在這邊，但因為單執行緒的觀念，就勢必不可能同時(平行處理)，所以 JS 所謂的「非同步」操作，其實是比較偏向示意圖的第三種，也就是並行處理，這也是我個人所理解的 Asynchronous Programming (非同步程式設計)。 阻塞與非阻塞根據上面的想法，我認為同步在處理事件的流程會被「卡住」，卡住的意思是說，當遇到沒辦法馬上執行完成的東西，就會整個停住，下一件要做的事情就會停擺。 而非同步在處理事件的流程不會被「卡住」，所以因為不會被卡住，所以看起來像是「一次同時做很多件事情」，但實際上沒有。 而這卡住不卡住其實比較跟阻塞(blocking)與非阻塞(non-blocking)有關，詳細的可以去看 Node.js 的官方文件有講到這一塊：Overview of Blocking vs Non-Blocking 這邊只簡單介紹： 阻塞（blocking）=&gt; 代表執行時程式會卡在那一行，直到有結果。 非阻塞（non-blocking）=&gt; 代表執行時不會卡住，沒有看到結果也會繼續執行下去。 很像剛剛在描述同步跟非同步吧？其實在JavaScript當中，可以把兩個劃上等號，剛剛 Node.js 的官方文件有一段是這樣講的：圖片來源：Node.js 官方文件這段的意思就是，阻塞的方法會同步的方式執行，而非阻塞的方法會非同步的方式執行，所以我會把兩種當作是同一種東西，注意僅限於JavaScript，其他語言可能不一定，要是全部都一模一樣那幹嘛分兩個不一樣的名稱對吧？ 總結準備要來下結論了，前面有提過到的一次做很多事情，看完上面的文章，相信你已經知道那並不是JavaScript非同步的特色，JavaScript永遠不會一次做很多事情，而實際上是怎麼在JavaScript做到非同步這件事情的，這就是明天要來講的主題，我們明天見啦～ reference[1] MDN - Introducing asynchronous JavaScript[2] W3Schools - Asynchronous JavaScript[3] You Don’t Know JS - Asynchrony[4] Javascript 非同步 &amp; Event Loop！10 分鐘輕鬆圖解學習！[5] 你懂 JavaScript 嗎？#22 非同步：現在和以後[6] 重新認識 JavaScript: Day 26 同步與非同步[7] 所以說 event loop 到底是什麼玩意兒？| Philip Roberts | JSConf EU[8] JavaScript 中的同步與非同步（上）：先成為 callback 大師吧！[9] 異步程式設計與事件迴圈","link":"/2022/09/27/JS12/"},{"title":"JS之路 Day13 - Event Loop (事件循環)","text":"前言昨天提到了JavaScript可以利用「並行的方式」去做到非同步這件事情，而關於這到底是怎麼辦到的，就是今天的主題，然後今天主要的內容都是以這個影片為基礎=&gt; 所以說 event loop 到底是什麼玩意兒？| Philip Roberts | JSConf EU，這影片對於JavaScript如何進行非同步的操作講得很清楚，推薦看。 出自影片的圖： 而以下是我看完影片，研究之後的自己見解。 Call Stack每段程式的執行都會有call stack，可以用來紀錄執行的順序，只要函式在呼叫的時候，就會把它丟進去最下面，後面進來的就會再疊上去，而當函式處理完之後，再從最上面去拿走，這是一種後進先出的概念。 可以想像成一個洋芋片罐，最先放進去的洋芋片，會在洋芋片罐的最下方，當洋芋片都放完要拿的時候，先拿的那片洋芋片就會是洋芋片罐最上方的那個洋芋片。 之前有提到說JavaScript只有一個執行緒，所以不能做很多事情，其實是因為只有一個Call Stack，因此一次只能做一件事情。 Web Apis意思是瀏覽器所提供的 api，我覺得最簡單的話，setTimeout其實就一種 Web Apis，專門做網頁計時器的功能，setTimeout它主要的核心其實就是非同步的概念，它會延遲的特性註定會跟同步不合，要是在同步延遲的話，就一定要一直等在那邊，直接延遲結束才能繼續下去。 所以在呼叫 Web APIs 時，很常會使用非同步的方式，我呼叫一個請求，但我不一定要馬上得到回覆。 Callback Queue我自己把它當作一個等待排隊的地方，它跟Call Stack特性有點不一樣，是一個先進先出的概念，但這也蠻合理的，想像一下先進去排隊的人，因為他比要早去排隊，所以理所當然可以先結束排隊的這個狀態，非常合理。 為什麼有這個的存在，是因為不可能永遠一次只處理一個callback funtion，當有很多個callback funtion已經丟到Call Stack，時間先結束的就會先丟到Callback Queue等待排隊。 Event LoopJavaScript執行非同步的方式，會使用到非同步的callback，假如有很多個，這些很多個的callback funtion就會進去到Callback Queue排隊，然後在執行階段的時候，會去判斷現在的callback裡面有沒有東西，當callback是空的時候，Callback Queue排隊的東西就會被丟進去，一次只能一個。 所以說，這也是一種一次做一件事情的方式，也是JavaScript如何使用並行的方式來執行非同步。 而因為非同步的東西會通通給丟去排隊的原因，所以非同步的函式永遠都會比同步的慢，同步的函式在執行call stack時就會把它結束掉，不會有進去到Callback Queue的機會。 總結而關於JavaScript難道永遠就只能單執行緒，沒有例外嗎？研究過後，有一種新的技術，它叫做Web Workers，據說是可以使用到其他的執行緒，不過我個人還沒有使用過，有興趣的可以依據這個關鍵字研究看看。 雖然非同步要用到callback，但之前要提到會有很可怕的callback hell問題，所以關於非同步的用法，JavaScript之後有一種更好的寫法，叫做promise，這個就是下一次要講的主題，我們明天見。 reference[1] The event loop[2] 異步程式設計與事件迴圈[3] JavaScript 中的同步與非同步（上）：先成為 callback 大師吧！[4] JS 原力覺醒 Day13 - Event Queue &amp; Event Loop 、Event Table[5] Javascript 非同步 &amp; Event Loop！10 分鐘輕鬆圖解學習！","link":"/2022/09/28/JS13/"},{"title":"JS之路 Day17 - async&#x2F;await(Promise語法糖)","text":"前言async/await的方式提供了promise一種新的寫法，至於有沒有更方便及更高的可讀性，我覺得使用了async/await是更容易進行編寫的，至少可以不用一直.then下去，使用了async/await之後，就跟.then說再見。 今天會介紹的順序： 這兩個好用的關鍵字分別代表的意思。 async/await 所達成的「同步」效果。 錯誤處理的應對措施。 async這是一個加在function前面的關鍵字，沒有加就是普通的function，加了之後就會變成async function就會代表著現在這個function是一個非同步的function。 123456789// 普通的functionfunction add(num) { return 10 + num;}// async functionasync function add(num) { return 10 + num;} 而會說加上async後function會變成非同步的原因主要是因為async會讓function在回傳的時候會返回一個promise，所以因為是promise，所以也可以使用.then來取出結果。 12345async function add(num) { return 10 + num;}add(10).then(console.log); // 20 所以跟這樣也是會相同的，不加上async的function： 1234function add(num) { return Promise.resolve(10 + num);}add(10).then(console.log); //20 加了async的async function除了可以讓整體變成非同步的function之外，還可以使用一種名為await的招式。 await這些從它的單字意思其實就能略知一二，await是等待，在這裡當關鍵字的就是就是讓這個async function進行等待。 這邊很重要的一點就是，一定要是async function，沒有的話就沒辦法使用，可是說是有async才有await(但沒有await也可以用async)。 123function add() { let result = await promise;} // SyntaxError 沒有async的狀態下直接使用await就會報錯給你看。 等待主要是讓Promise的運行先暫停一下，直到接受了回傳值才會繼續運行，而await這種藉由等待，暫停了非同步的執行的方式，是讓使用了async/await的function看起來很像同步的關鍵。 明明是非同步，為什麼會看起來很像同步呢？ 看過來。 async/await的「同步」1234567891011121314const promise = new Promise(function (resolve) { setTimeout(() =&gt; resolve(&quot;五秒到了&quot;), 5000);});async function sec() { console.log(&quot;在 await 之前&quot;); let result = await promise; console.log(result); console.log(&quot;在 await 之後&quot;);}sec(); //? 在講這段程式之前，先來談談順序的問題。 一般來說，程式碼看下來的流程，會先去執行同步的程式，因為不會有需要等待排隊的問題，而非同步的因為沒辦法馬上完成，所以要等待後才能執行，等待的時間不知道，但能知道的是一定同步的東西先跑完。 程式碼的寫法順序： 1234同步1非同步1同步2同步3 實際上的執行順序: 1234567同步1同步2同步3...... =&gt; 確保同步都跑完非同步1 基本上有兩個概念在執行順序這一塊： 會由上而下執行 同步先執行，才是非同步執行 回到程式碼，照著剛剛的概念來看，應該會是先跑出來在 await 之前之後是在 await 之後，而經由了setTimeout而造成需要等待幾秒才會執行的promise非同步理論上應該是最後才會跑出來，但是如果你把上面那段程式碼拿去執行，你會發現順序是： 123在 await 之前五秒到了在 await 之後 怎麼跟上面講的不一樣呢？這其實就是async/await的神奇之處，使用了await就會等待，就算它本身是一個非同步的運行，在整體的async function之中，也會逐行的執行，不會有某一行被抓去排隊(事件佇列)而執行跳到下一行的狀況，看起來就可以達成是非同步的，但我用同步的方式去跑。 錯誤處理await後面接的promise會直接回傳結果，而結果有兩種可能性。 成功 =&gt; resolve 失敗 =&gt; reject 在原本使用promise的時候，會使用.then跟.catch去獲取這兩種結果，但是async/await不用。 我研究之後發現在async/await時會使用try..catch的方式來處理錯誤的結果。 try..catch它會分成兩個區塊，一個 try 一個 catch，主要就是正常是 try 區塊，在 try 區塊碰到錯誤，直接跳到 catch 區塊。 123456try { // 要執行的程式} catch(error) { // ... // 錯誤發生時，上面的就不會執行，改執行這邊} 舉例時間： 12345try { console.apple(&quot;apple不是正確的使用方式喔&quot;);} catch (e) { console.log(&quot;我錯了&quot;);} 這段 code 的結果會印出我錯了，如下： 為什麼會發生這樣的結果？這是因為如果 try 區塊裡面的程式碼假如沒有任何的錯誤，就會直接忽略掉catch區塊裡面的程式碼，反之有錯的話，就會以catch裡面的程式碼為主，而錯誤的try就會中斷執行，所以在這個範例來說，因為try寫錯了，所以會以try裡面的程式碼為主。 另外如果catch區塊如果接受了一個參數，就可以直接利用這個參數獲取錯誤資料，一般都會是直接在後台輸出資料，這邊來試試看： 12345try { console.apple(&quot;apple不是正確的使用方式喔&quot;);} catch (e) { console.log(&quot;錯誤訊息 :&quot;, e);} 這段 code 的結果會印出錯誤資訊，如下： async/await遇錯時使用剛剛講的方式，先把全部的async function都用try..catch包起來，然後錯誤的話自然就會跑到catch區塊自動去抓取失敗的結果。 1234567891011121314151617181920212223242526function promise(a) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { if (a) { resolve(&quot;五秒到了&quot;); } else { reject(&quot;錯誤發生&quot;); } }, 5000); });}async function sec() { try { console.log(&quot;在 await 之前&quot;); let result = await promise(0); console.log(result); console.log(&quot;在 await 之後&quot;); } catch (error) { console.log(error); }}sec(); 最後結果印出： 12在 await 之前錯誤發生 第一行的在 await 之前還是會出現，只是經過了下方await的promise，因為裡面帶入的參數是負數，所以是false，結果會跑去else 的reject(&quot;錯誤發生&quot;)，而最終會進到catch區塊直到結束，所以try區塊後面的在 await 之後就不會看到。 要注意一件事情，try區塊可以因為錯誤而進到catch區塊，但沒辦法反向，也就是說無法在失敗之後再度執行原本程式。 總結async function的奇妙之處： 內部可以使用名為await的招式。 內部最終總是會回傳一個promise。 整體會變成非同步的狀況。 await這個招式使用之後的兩種下場： 強制promise等待直到完成。 有錯誤的話，拋出reject的錯誤結果。 沒錯誤就直接回傳resolve的成功結果。 什麼時候可以用？ 基本上當你想要使用promise的.then時，都可以把它改成async/await的方式，就不用一直.then，處理非同步的程式時又多了一種寫法，看完這這篇後，大家也多嘗試用看看async/await來寫 code 吧。 reference[1] MDN - async function[2] MDN - await[3] w3schools - JavaScript Async","link":"/2022/10/02/JS17/"},{"title":"JS之路 Day18- What is Biglnt?","text":"其實我不知道Biglnt的中文可以叫什麼比較好，直接翻成「大整數」似乎不太精確。 今天會從以下這些角度來介紹： Biglnt為何而來 定義及如何使用 可能會踩的雷區 數字類型 =&gt; Biglnt跟Number在JavaScript中，Biglnt也是其中的一種primitive，也就是基本型別。 複習一些有哪些基本型別，基本上可以由字串、數字、布林值含括： String Number Boolean Null Undefined Symbol 除了這些，其實還有一種基本型別叫做Biglnt，也是用來處裡數字的部分，就跟Number一樣的領域。 主要是因為光是Number處理數字會有一些無法顧及到的部分，所以才有了需要Biglnt的誕生。 舉例來說，只要數字太大，Number就沒辦法顯示精準，而這個範圍大致是2**53-1，從Number.MAX_SAFE_INTEGER裡面描述的最大安全整數範圍來判斷，也就是說超過了這個數字，Number就沒辦法維持準確性。 不精確的意思是代表說明明兩個不一樣，但判斷不出來，舉一個例子是在JavaScript當中的2 ** 53 + 1 跟2 ** 53 會一樣，非常奇怪。 12345678const A = 2 ** 53 + 1;const B = 2 ** 53;console.log(A, B);// 9007199254740992 9007199254740992console.log(A === B);// true 為了要解決這個問題，JavaScript才會需要可以支持任意長度整數都保持精確度的Biglnt。 創建 Biglnt 方式把數字變成Biglnt的狀態很簡單，有兩種做法： 在數字後面直接加上 n 使用 BigInt() 就是字面上的意思，加上一個 n 跟把數字給()起來。 123const number = 123;const bigInt1 = 123n;const bigInt2 = BigInt(123); //跟bigInt1一模一樣 跟Number一樣可以使用各種的運算子，可以把Biglnt當作一個後綴加上了n的Number。 1234567console.log(1n + 1n); // 2nconsole.log(2n * 2n); // 4nconsole.log(10n / 2n); // 5nconsole.log(50n % 10n); // 0nconsole.log(10n &gt; 5n); // trueconsole.log(20n &gt; 30n); // false 跟Number有一個不一樣的地方，一般來說當只寫出值，像是10，那它可能是String也可能是Number，而這時候可以使用在這個值前面加上一個+的方式，讓這個值確認變為是Number型別。 1console.log(typeof +10); //number 但在Biglnt不支援這種方式，可能是為了避免搞混，如果在Biglnt就會直接報錯給你看。 1console.log(+10n); // TypeError **什麼時候使用Biglnt**？ 值超過了最大安全數字的時候，就是值大於2^53再使用Biglnt，正常狀態下好好的可以繼續用Number沒問題。 Biglnt 踩雷區域以下問題都知道的話就可以直接跳過囉。 BigInt可以跟其他常規數字混合使用嗎？ BigInt跟Number一直切換是好是壞？ 直接講結論，沒辦法混合使用，BigInt跟Number加再一起送你報錯。 123console.log(1 + 1); // 2console.log(1n + 1n); // 2nconsole.log(1n + 1); // TypeError 如果有需要兩者的狀況，應該是要想法把轉換他們，有兩種情況： 將number轉換成bigint 1console.log(10n + BigInt(10)); // 20n 將bigint轉換成number 1console.log(Number(10n) + 10); // 20 而BigInt跟Number一直切換好嗎？MDN 文件裡面說這樣不好，不建議在BigInt值和Number值之間進行強制轉換。 因為Number值和BigInt值之間的強制轉換會導致精度損失。 總結Biglnt是一個新的數字基本型別,用來處理一些Number沒有辦法處理的數字，像是Number能夠表示的安全整數範圍之外的，就只能夠靠Biglnt來精準顯示。 reference[1] MDN - BigInt[2] JavaScript 之旅 (22)：BigInt[3] w3schools - ECMAScript 2020","link":"/2022/10/03/JS18/"},{"title":"JS之路 Day19 - What is symbol?","text":"前言ES6 才加入的primitive type，我個人覺得是primitive type當中最難理解的。 object的key在 ES6 之前都只能是字串，就算寫成數字也會被轉成字串，所以之前我會說，object的key只能是字串，但這個說法被symbol打破了，它也可以拿來當作object的key，而它為什麼可以，以及symbol是處理什麼領域的問題，讓我們看下去吧。 特性：獨一無二symbol可以直接跟獨一無二的值劃上等號，只會有一個保證是唯一的，這其實就是可以拿來當作object的key的原因，不會重複很適合拿來幫物件取名。 這樣記：只要透過symbol建立的值，都會獲得特性：獨一無二。 建立：symbol建立symbol的方式很簡單，只要使用Symbol()即可，不需要用new。 1234// 語法const fruit = Symbol();console.log(typeof symbol); // symbol 可以給Symbol裡面加名字，在Symbol()的()裡面，可以當作它是這個變數fruit的描述，而它的類別是Symbol。 由於特性：獨一無二，所以當名字都是取一樣的，實際上值也是不同的，名字僅供參考，像是： 1234const fruit = Symbol(&quot;apple&quot;);const fruit2 = Symbol(&quot;apple&quot;);console.log(fruit == fruit2); // false 招式：Symbol.for()、Symbol.keyFor()所有的Symbol都是不同的，就算名字都取的一樣，但有時候還是會想要說相同名字的Symbol能夠擁有相同的實體，為了做到這件事情，需要一個名為global Symbol registry的概念。 想像有一個神秘的空間(註冊表)，創建了Symbol會註冊在裡面，想去看的時後可以隨時訪問，但不是想看就看的，需要名為招式Symbol.for()才辦到的。 要在註冊表裡讀取symbol，需要使用Symbol.for()。 Symbol.for()相當於創立Symbol，只是這個創立Symbol是把它放到註冊表當中。 1234const fruit = Symbol.for(&quot;apple&quot;);const fruit2 = Symbol.for(&quot;apple&quot;);console.log(fruit == fruit2); // true 比較一下：Symbol() =&gt; 每個創立都不相同(就算同名字)，全域無法找到。Symbol.for() =&gt; 創立時會放到註冊表，同名字就當作相同創建，在全域可以被Symbol.keyFor()找到。 而我要怎麼去拿到已經放到在註冊表裡面的symbol？就會需要另一個招式=&gt; Symbol.keyFor() 12345const fruit = Symbol(&quot;apple&quot;);const fruit2 = Symbol.for(&quot;apple&quot;);console.log(Symbol.keyFor(fruit)); // undefinedconsole.log(Symbol.keyFor(fruit2)); // apple 一樣直接創立的話，就不存在於global Symbol registry，自然Symbol.keyFor()就無法找到。 這兩個招式其實就是symbol的Static methods(靜態方法)。 排擠：symbol可能是symbol太有個性了(獨一無二），在某些場合，會發生symbol被無視的狀況，比如說for..in： 12345678const fruit = Symbol(&quot;apple&quot;);const user = { name: &quot;vic&quot;, age: 23, [fruit]: &quot;this is a apple&quot;,};for (const key in user) console.log(key); // name, age 沒有 fruit 不過還是能找到它裡面的值： 1console.log(user[fruit]); // this is a apple 跟for..in同個系列的for..of也會被略過。 另外一個會排擠symbol是Object.keys: 遇到就直接無視。 123456789const fruit = Symbol(&quot;apple&quot;);const obj = { a: 1, b: 2, [fruit]: &quot;this is a apple&quot;,};console.log(Object.keys(obj)); // [ 'a', 'b' ] symbol在for..in、for..of、Object.keys都會被跳過。 可以反過來利用這個特性，當你想要隱藏某一些物件的屬性時，用symbol當object的key就對了，它在上面那些狀況都不會與其他属性一起被處理。 reference[1] MDN - Symbol[2] JS Symbols 的使用[3] ECMAScript 6 入門","link":"/2022/10/04/JS19/"},{"title":"JS之路 Day21 - recursion(遞迴)","text":"今天假如要寫一個求 1 + 2 + … + n 的總和，一般人可能很直覺的就想到說，要用迴圈的方式把所有值都加在一起。 123456789function add(n) { let result = 0; for (let i = 1; i &lt;= n; i++) { result += i; } return result;}console.log(add(5)); // 15 但除了迴圈之外，還有另外一種名為遞迴的技巧也能達成相同的效果。 123456789function add(n) { if (n === 1) { return 1; } else { return n + add(n - 1); }}console.log(sum(5)); //15 我們先來看一下遞迴(recursion)在mdn上面的定義： The act of a function calling itself, recursion is used to solve problems that contain smaller sub-problems. A recursive function can receive two inputs: a base case (ends recursion) or a recursive case (resumes recursion). 簡單來說，就是一種自己呼叫自己的意思，利用自己呼叫自己來解決問題，通常需要被遞迴的問題是一個可以被分成很多小問題的大問題。 函數在運行時，有時會呼叫很多其他的函數來達到目的，在一些特殊的情況下，甚至會呼叫自己，而這種函數運行時會呼叫自己的技巧，就是遞迴。 而通常可以使用迴圈解決的問題，也可以用遞迴來做解決，原本只會使用迴圈的我，想不通幹嘛要用遞迴，後來想想其實多了一種新的解決問題的方式是一件好事，而且其實遞迴的程式碼通常比迴圈少， 會想要特別寫遞迴是因為一開始看不太懂，但突然看著看著就有了一些概念覺得蠻特別的，所以就來試著講解做個紀錄。 一個基本的遞迴會需要有： 終止條件 遞迴條件 第一個是因為假如沒有終止條件，那函式不斷的呼叫自己，最後就會變得沒完沒了，程式將無窮無盡不會結束。 而遞迴條件就是呼叫自已的條件，沒有終止條件就會無限循環然後當掉，但是沒有遞迴條件就沒辦法呼叫自己，程式就不知道怎麼呼叫。 舉個例子:小白跟他朋友講一個故事，故事裡面是一個人跟他朋友講一個故事，而這個故事裡面是一個人跟他朋友講故事…… 而在程式中，遞迴有一個經典的例子。 費氏數列以費波那契數為邊的正方形拼成的近似的黃金矩形。圖片來源：https://zh.m.wikipedia.org/zh-tw/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0 在數學上，費波那契數是以遞迴的方法來定義： f0=0 (1) f1=1 (2) Fn = Fn-1+Fn-2 (3) 其中(1)跟(2)就是上述提到的終止條件，而(3)是遞迴的定義。 簡單來說，費式數列是從零開始，之後的數字都是由前面的數字兩者相加而成： 11、 1、 2、 3、 5、 8、 13、 21、 34、 55、 89、 144、 233、 377、 610 寫法會像這樣: 123456function fibonacci(n) { if (n &lt; 2) { return n; } return fibonacci(n - 1) + fibonacci(n - 2);} 總結可能實際在寫程式時不會使用到遞迴，因為其實沒有非遞迴就不能解決的問題，它比較像是解決問題的另一種思路而已，所以多了解是沒有壞處的。 我個人認為遞迴有兩個優點，第一個是使用後的程式碼會看起來很少，程式碼看起來簡潔舒服，第二個是感覺比較專業，因為大部分人都用迴圈，用遞迴直接變得與眾不同了起來，大家也可以在寫程式中嘗試看看遞迴這個技巧。 reference[1] mdn - 遞迴[2] JavaScript 學演算法（二十二）- 遞迴 Recursion[3] Javascript 的遞迴(Recursive)[4] JavaScript 演算法之遞迴[5] 維基百科-費波那契數","link":"/2022/10/06/JS21/"},{"title":"JS之路 Day22 - Logical operators (邏輯運算子) OR篇","text":"今天要來介紹的是Logical operators，最主要有這三種常常使用 =&gt; || =&gt; OR 運算子 &amp;&amp; =&gt; AND 運算子 ! =&gt; NOT 運算子 學習在這邊的時候可能會有疑問，運算子(operators)是什麼? 拿去 google 會發現它似乎會常常被跟運算式(Expressions)一起談論。 Expressions and operators可以用一個簡單的 1+1 來了解這個概念。 1const X = 1 + 1; //2 1+1會等於2應該沒問題，而這個X = 1+1其實就是Expressions，這個Expressions會產生一個2的值，那麼operators在哪裡？ 在這個X = 1+1的Expressions裡面，=是一個operators，+也是一個operators，實際上，Expressions就是透過operators來進行運算的，透過operators的運算獲得最後的「值」。 是的，加、減、乘、除都是operators，除了計算之外，operators也可以用來賦予值，像是上面提到的=，它把1+1得出2的這個值賦予到這個 x 的變數之中，其他也有許許多多的不同的類型operators，像是我們今天的主題Logical Operators。 想要更了解的話可以去看MDN Expressions and operators。 接下來進入Logical operators個別介紹，會儘量用白話的方式來講述。 ||介紹||可以念做 OR 運算子，如它其名，這是一個用來判斷 OR 邏輯的operators，但什麼是 OR 邏輯判斷？ 來看一個小故事。 肚子痛的故事有一天小白穿得很帥的在路上走來走去，突然肚子一陣劇痛，小白心想這事情不太妙，這種感覺是沒辦法撐到回家的，好在他所在的位置附近剛好有兩個有廁所的建築物，一個是右側方過去有公園，另一個則是左邊過去有一間麥當勞。 時間已經等不了他了！ 小白要馬上做出選擇，最後他選擇的是…… A 世界線 =&gt;小白選擇了去公園，他步履蹣跚的向著公園廁所走去，路上小心翼翼的躲避著那些橫衝直撞的小孩，跟一群追著飛盤的狗，千辛萬苦來到廁所，裡面有三間，此時小白已經到了極限，他一間間的敲，第一間有人，第二間有人，第三間也有人，小白頓時留下兩行清淚，他失敗了。 B 世界線 =&gt;小白選擇了去麥當勞，趕到之後裡面一瞧，發現竟只有兩間廁所，小白吞了吞口水，拿起他那雙顫抖的手「叩叩叩」第一間廁所門，發現沒有反應後試探性地打開那廁所門，小白笑了，他知道他不用再去看下一間。 只要是遇到了true就馬上回傳true剛剛的故事裡，小白在 A 世界線裡選擇到了公園的廁所以及 B 世界線到麥當勞的廁所，我們可以使用 OR 運算子的方式來表示： 123公園廁所 = 廁所1 || 廁所2 || 廁所3;麥當勞廁所 = 廁所1 || 廁所2; 廁所沒人的話，小白可以順利解決肚子痛的問題，我們稱為ture。 廁所有人的話，小白會很悲慘，我們稱為false。 123公園廁所 = false || false || false; // false麥當勞廁所 = true || 廁所2; // ture 公園的廁所每間都有人，全部false，所以最後結果也是false。 麥當勞的廁所小白只去看了第一間，發現裡面沒有人ture，就直接進去沒有再去看第二間了，最後結果是ture。 上面這些其實就是 OR 邏輯判斷，當全部失敗的時候就全部失敗，但只要有其中一個成功，那麼就直接成功，不用看其他的。 列舉一些實際上範例的組合會更了解一些： 1234console.log(true || true); // trueconsole.log(false || true); // trueconsole.log(true || false); // trueconsole.log(false || false); // false 可以發現到說，除了全部都是false之外的，其他通通都是true，這基本上就是 OR 運算子的概念。 但我們實際上不會只用true跟false這種方式來做判斷，我們可以用其他各種類型的值，它們會自動轉換成true跟false的型態，比如說： 12345let age = 5;if (age &lt; 10 || age &gt; 65) { console.log(&quot;你可以買優惠票&quot;);} age &lt; 10及age &gt; 65都會被轉換，有成立就會true沒成立則是false，數字方面也一樣，像是說: 123if (1 || 0) { console.log(&quot;有true&quot;);} 數字1會被當作true，數字0會被當作false，會發現到說要是今天操作的值不是一個「boolean」值，也會被轉換成一個「boolean」的型態。 以上是基本的 OR 運算子會做到的事情。 了解這塊之後，接下來再來探討在javascript中，一些比較特別的特性。 尋找第一個真值，找不到就回傳最後一個回到上面小白在 A 世界線悲慘的遭遇。 123公園廁所 = 廁所1 || 廁所2 || 廁所3;公園廁所 = false || false || false; // false 三個廁所都沒有人，所以都是false，會回傳false，但是前面有提到說，除了「boolean」值之外，其實結果可以是任意類型，代表著回傳的東西不一定只能是false。 在查閱了 MDN 關於Boolean的章節跟一些相關文章後，發現可以被當作false的初始值如下： 0 null undefined ‘’ false(本身) (空值沒東西) 假如用這些值塞滿三個原本false的地方，最後肯定是會回傳false，但三個false值假如不一樣，那麼 OR 運算子會怎麼運作呢？ 1三個不同值 = null || &quot;&quot; || 0; // 三個都是false的值 如果最後傳回來的值，是需要轉換之後才會變成「boolean」值的，那回傳的值會是直接最後一個初始的值。 從上面來說，就是||先從最左邊開始找，第一個看到null不是true所以繼續往下找，下一個是''也不是true，所以繼續找，下一個0也不是true，但已經是最後一個了，所以||就會想說好吧，那就回傳0。 於是，假如今天順序是null || '' || 0就會回傳0。 1console.log(null || &quot;&quot; || 0); // 0 假如順序是0 || '' || null就會回傳null。 1console.log(0 || &quot;&quot; || null); // null 遇到是true的值，就會馬上回傳，否則回傳最後的false值。 最後再來利用剛剛的所學，改寫一次小白的例子。 使用三個變數代表三間廁所，空字串代表false，字串裡面有寫東西代表true，用||的方式來選擇是true的那一樣，並且顯示出來，代表廁所裡面有人。 利用這種技巧就可以來獲取一群變數排列中，裡面的第一個真值。 12345let firstBathroom = &quot;&quot;;let secondBathroom = &quot;&quot;;let thirdBathroom = &quot;裡面有人&quot;;console.log(firstBathroom || secondBathroom || thirdBathroom || &quot;沒人可以進去&quot;); // 裡面有人 小結今天的介紹就到這邊，明天會繼續把&amp;&amp;跟!講完的 reference[1] MDN - Expressions and operators[2] MDN - Boolean","link":"/2022/10/07/JS22/"},{"title":"JS之路 Day20 - What is this?","text":"前言今天要來講的主題是this，在JavaScript中的this可以在呼叫函式時，透過不同方式決定它要指向哪一個物件，而關於什麼時候會指向什麼地方，這就是this的困難之處。 理解this來由一開始自己的猜測理解是，有些很冗長的名字，假如有一個代名詞，去代替它會很好很多。 比如說，我要描述在一家便利商店打工的小白擁有的東西： 在便利商店打工的小白擁有著一台機車，在便利商店打工的小白還有隨身攜帶一個水壺，而且在便利商店打工的小白手中現在還拿著一個過期的超商飯糰。 假如把「便利商店打工的小白」用「他」來替換掉的話： 在便利商店打工的小白擁有著一台機車，「他」還有隨身攜帶一個水壺，而且「他」手中現在還拿著一個過期的超商飯糰。 程式碼寫起來概念會像這樣： 這邊變數名稱就不要太長單純是white就好，但可以想像成叫做SuperWhiteWorkingInAConvenienceStore比較符合概念。 1234567891011const white = { transportation: &quot;motorcycle&quot;, thing: &quot;kettle&quot;, describe: function () { console.log( &quot;小白擁有一台&quot; + white.transportation + &quot;,小白還隨身攜帶&quot; + white.thing ); },};white.describe(); // 小白擁有一台motorcycle,小白還隨身攜帶kettle 程式加上了this的概念會變成這樣： 1234567891011const white = { transportation: &quot;motorcycle&quot;, thing: &quot;kettle&quot;, describe: function () { console.log( &quot;小白擁有一台&quot; + this.transportation + &quot;,小白還隨身攜帶&quot; + this.thing ); },};white.describe(); //小白擁有一台motorcycle,小白還隨身攜帶kettle 這兩種結果都是一樣的，this會去指向這個物件的變數名稱，不管呼叫的東西有很長，最終都只需要四個字母的this就能取代掉，這是我一開始所對this的理解。 用「這個」來當代名詞，利用「這個」來呼叫所指的對象。 然後去看看比較正確的定義是什麼，這裡推薦去看： ECMAScript 標準規範 MDN - this 官方文件 先來看看 ECMAScript 標準規範 對 this 的定義： 「The this keyword evaluates to the value of the ThisBinding of the current execution context.」 翻中文： 「this 這個關鍵字代表的值為目前執行環境的 ThisBinding。」 好，我當初也看不太懂什麼是ThisBinding。 ThisBinding 是什麼有去研究了一下 有看到一篇文章有講述，整理一些重點。文章是這篇：帶你徹底搞懂執行上下文 在es5 Execution Context的時候 生命週期包括三個階段。 建立階段 → 執行階段 → 回收階段 而在建立階段會去做三件事情： 確定 this 的值，也被稱為 This Binding LexicalEnvironment（詞法環境） 元件被建立 VariableEnvironment（變數環境） 元件被建立 code 大致長這樣=&gt; 12345ExecutionContext = { ThisBinding = &lt;this value&gt;, // 確定this LexicalEnvironment = { ... }, // 詞法環境 VariableEnvironment = { ... }, // 變數環境} 所以說 ThisBinding 是和Execution Context綁定的，也就是說每個執行環境都有一個 this，與 es3 的this 並沒有什麼區別，this 的值是在執行的時候才能確認，定義的時候不能確認。 可以理解成，一個新的函式執行環境被建立時，JavaScript就會自動幫建立一個新的this，所以這邊解開了一個盲點，不是呼叫了一個東西才創造this，而是函式只要創建，就會創造執行環境，而執行環境的建立階段就會去做This Binding的這個動作，確認有this的值。 然後來看看 MDN 對 this 的定義： 「In most cases, the value of this is determined by how a function is called.」 翻中文： 「在大多數的情況下，this 會因為 function 被呼叫的方式而有所不同。」 意思是this所指向的值，不是在被定義的當下決定的，是在被呼叫的時候決定的，這個部分會跟Scope Chain完全反過來，而今天主要談論是this，關於Scope Chain的部分，以後會專門做一期文章為大家講解。 所以在這裡MDN告訴了我們一件事情，隨著執行的方式不同，this所指向的值也都會不同，而注意到了一個細節，這邊是講說In most cases，在大多數的情況下，所以不是所有情況，這種狀況我理解是無意義的情況。 this 無意義的情況無意義的情況是指物件之外的this就沒有意義去討論，沒有意義的意思是，在這種狀況this是什麼都沒關係，不重要。 比如說要去探討一個function裡面的this是會指向哪裡。 12345const func = function () { console.log(this);};console.log(this); //window 會發現說在瀏覽器環境下會指向Window的物件。也不是指向func這個function，就像是我在介紹一個人，他很帥，什麼人？ 世界上的某一個人，感覺沒有什麼意義。 這個指向的Window物件也只是因為沒意義的狀況下給的預設值，通常會分成幾種狀況，我做了一個表格。 預設狀態下的this值： 瀏覽器環境 node.js 環境 嚴格模式 undefined undefined 非嚴格模式 window global 整理一下，MDN講的In most cases是指在物件導向內，this所指的東西就是物件裡面的instance，而只要脫離了物件導向，就不用去管this的值是什麼，因為沒有意義。 而this到底是如何覺得要怎麼指向哪裡，MDN是說因為被呼叫的方式，在這邊當作this有綁定指向的四個招式來解釋： Default Binding (預設綁定) Implicit Binding (隱含綁定) Explicit Binding (顯示綁定) new Binding (new 綁定) 然後第一種的預設綁定已經講完了，就是在沒意義的狀況下，this會有預設的值。 接下來講其他三種。 隱含式綁定 (Implicit Binding)關鍵字：透過 . 1234567var vic = { name: &quot;vic&quot;, getName: function () { return this.name; },};vic.getName(); // vic 隱含就是沒有明確說出this正式綁定的對象是什麼，用一個.可以取出物件屬性的特性，同時也告知this是可以指向哪裡。 最前面介紹小白擁有東西的程式就是利用Implicit Binding來綁定this。 顯式綁定 (Explicit Binding)關鍵字： 透過call apply bind 123456function main(a, b) { console.log(this, a, b);}hello.call(&quot;call&quot;, 1, 2); // call 1 2hello.apply(&quot;apply&quot;, [1, 2]); // apply 1 2 你第一個參數傳什麼，裡面this的值就會是什麼。儘管原本已經有 this，也依然會被這種方法給覆蓋掉。 123456function main() { console.log(this);}const Mainmain = main.bind(&quot;test&quot;);Mainmain(); // main bind 會回傳一個新的 function，這邊把 main 這個 function 用 test 來綁定。 「new」關鍵字綁定關鍵字： 透過new 12345678function Vic(name) { this.name = name; this.getName = function () { return this.name; };}var main = new Vic(&quot;vic&quot;);main.getName(); // vic 當用 new 來建立一個先的物件，這個新的物件會被設為 this 綁定的目標。 最後做一個小小的綁定整理 vic 定義 補充 預設綁定 this 指向外面沒東西 function 被呼叫的當下如果沒有值,this 會自動指向全域 隱式綁定 透過 . 隱含指出 使用 . 可以取用到物件底下的屬性 顯式綁定 call(), apply(), bind() 直接強制給的，很明確 關鍵字綁定 this 指定新 new 出的物件 透過 new 來創造物件比較不常見 reference[1] MDN - this[2] 淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂[3] What’s THIS | 淺談 Javascript 中令人困擾的 this[4] What’s THIS in JavaScript ? [上][5] JavaScript 深入之从 ECMAScript 规范解读 this[6] JS 原力覺醒 Day17 - this 的四種繫結[7] 帶你徹底搞懂執行上下文","link":"/2022/10/05/JS20/"},{"title":"JS之路 Day16 - Promise methods(承諾方法)","text":"前言前幾天講的Promise的 then()、catch()、finally()也是Promise的 methods，從 MDN 的定義上會把這三種 methods 稱之為Instance methods，而今天要講的是Static methods，中文叫做靜態方法，大致上可以分成六種，這些的方法都是為了更好的使用Promise而被發明出來，可能用不到但懂了沒壞處。 哪六種： Promise.all() Promise.allSettled() Promise.any() Promise.race() Promise.resolve() Promise.reject() 會嘗試用好理解的方式介紹，let’s go。 Promise.all()執行很多的Promise會用到，簡單來說，全部都達成才會成功，不然就會失敗。舉一個例子，小白願意去找工作，但他有著前提條件，只要他擁有了一台車，然後有了房子，還擁有 100 萬的存款，他就會去找工作。 12345678Promise.all([ new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;獲得車&quot;), 100)), new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;獲得房子&quot;), 200)), new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;獲得100萬&quot;), 300)), new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;=&gt; 好! 去工作&quot;), 400)),]).then(console.log);// [ '獲得車', '獲得房子', '獲得100萬', '=&gt; 好! 去工作' ] 會等到全部的結果都成功，才會全部都 resolve， 會發現說它回傳的會是一個 array，這個 array 裝的東西就是所有的結果。 只要有一個失敗，就直接失敗，就像是只要有一個前提條件沒達成，小白就沒辦法去找工作。 123456789101112Promise.all([ new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;獲得車&quot;), 100)), new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;獲得房子&quot;), 200)), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(&quot;沒有一百萬，沒人要給你&quot;)), 300) ), new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;=&gt; 好! 去工作&quot;), 400)),]) .then(console.log) .catch(console.log);// Error: 沒有一百萬，沒人要給你 其中有一個被reject就會導致全部整個Promise.all都被reject，最後的結果就是reject裡面寫好的Error訊息。 Promise.allSettled()情境是使用在都每種Promise都想知道結果的時候。 代表說成功或是失敗的結果都會被記錄下來，這兩種都會被裝在一個陣列裡面。 成功： 1{status:&quot;fulfilled&quot;, value:成功的訊息} 失敗： 1{status:&quot;rejected&quot;, reason:失敗的訊息} 繼續上方的例子，小白做好準備要出發去找工作，他的策略是履歷海，什麼都投，投完後開心地坐在家中等消息。 1234567891011121314151617Promise.allSettled([ // 找工作是一個包著promise的函式，裡面就會放失敗跟成功的訊息 找工作(&quot;第一間公司&quot;, 100), 找工作(&quot;第二間公司&quot;, 200), 找工作(&quot;第三間公司&quot;, 300),]) .then((value) =&gt; console.log(value)); .catch((err) =&gt; console.log(err));// 結果=&gt;[ { status: 'fulfilled', value: '第一間公司：發來面試請求！' }, { status: 'rejected', reason: '第二間公司，無聲卡' }, { status: 'fulfilled', value: '第三間公司：發來面試請求！' },] 其中有一個被reject，也會把其他結果通通跑完，跑完之後會能看到所有的結果，無論結果是如何，都會全部都被settle，所以叫做allSettled。 Promise.any()假如成功就馬上成功，直到全部都失敗。 而在全部都失敗的狀態下，會回傳一個叫做AggregateError的物件裡面，把失敗的訊息都放進去。 小白出發前往面試，他只要有上就好，成功了就不會繼續下一間。 123456789Promise.any([ new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(&quot;失敗，下一間&quot;)), 100) ), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(&quot;成功找到工作&quot;), 200) ), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(&quot;回家睡覺&quot;), 300)),]).then(console.log); // 成功找到工作 假如完全都沒有任何公司是面試成功的話： 12345678910111213141516171819202122Promise.any([ new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(&quot;失敗，下一間&quot;)), 100) ), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(&quot;失敗，下一間&quot;)), 200) ), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(&quot;失敗，下一間&quot;)), 300) ),]) .then(console.log) .catch((error) =&gt; { console.log(error.constructor.name, error.errors); });// 會出現：AggregateError [ Error: 失敗，下一間 Error: 失敗，下一間 Error: 失敗，下一間] Promise.race()跟Promise.any有點像，當一個promise有結果，就回傳跟結束。 剛剛提到小白找到了工作，他很開心想要慶祝，所以打算去吃一間豪華的餐廳，他還沒想要要吃什麼，抱著不想找太久的心手舞足蹈的前往。 1234567891011Promise.race([ new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(&quot;吃牛排&quot;), 200)), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(&quot;吃拉麵&quot;), 300)), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(&quot;吃火鍋&quot;), 400)),]) .then(console.log) .catch((error) =&gt; { console.log(error); });// 吃牛排 小白看到了牛排，然後裡面就有位子不用排隊，二話不說就直接開吃了。 到這邊跟Promise.any幾乎一模一樣，有了一個成功，其他都就不會去看直接結束。 但是要是第一間要去的不是牛排店，而是人很多的燒賣店呢？讓我們看下去。 12345678910111213Promise.race([ new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(&quot;人太多，不吃了&quot;)), 100) ), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(&quot;吃牛排&quot;), 200)), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(&quot;吃拉麵&quot;), 300)), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(&quot;吃火鍋&quot;), 400)),]) .then(console.log) .catch((error) =&gt; { console.log(error); });// Error: 人太多，不吃了 小白第一間到了燒賣店，看到了那人山人海的群眾，內心湧入一陣倒胃，突然就沒有吃飯的慾望了，於是就直接回家結束了這回合。 這就是Promise.race的特性，不管是成功還是失敗，Promise.race都會被解決。 Promise.race() 和 Promise.any() 比一比來複習一下這兩者的差別： Promise.race:不管是成功還是失敗，都會直接完成。 Promise.any:當成功了，或是全部都失敗，才會完成。 兩個都會有拒絕的狀況，Promise.race的拒絕狀況是因為碰到了第一個Promise拒絕後就馬上拒絕，而Promise.any是全部都被拒絕後，回傳一個，AggregateError。 要如何使用它們兩個，要依照情境而定，可以知道的是他們兩個很相似但是依舊是不同的東西。 Promise.resolve()我的理解是設定Promise成功後的訊息。 12345const promise = Promise.resolve(1);promise.then((value) =&gt; { console.log(value);}); //1 Promise.reject()而reject就是Promise失敗後的訊息，所以要用 catch()去抓。 12345const promise = Promise.reject(1);promise.catch((value) =&gt; { console.log(value);}); 小結每一種方法都有它適合的情境，在使用promise可以試著用用看這些方法～說不定會發現方便又好用，而我個人體感跟爬文看到來說，Promise.all這個方法是實際上會使用最多的，所以可以考慮先從這個開始下手認識，那麼今天就是這些，謝謝明天見。 reference[1] MDN - Promise[2] What is the difference between Promise.any() and Promise.race()","link":"/2022/10/01/JS16/"},{"title":"JS之路 Day23 - Logical operators (邏輯運算子) AND、NOT篇","text":"今天來講昨天沒講完的兩個Logical operators。 Logical AND (&amp;&amp;) Logical NOT (!) Logical AND (&amp;&amp;)會用&amp;&amp;來判斷&amp;&amp;兩邊的值，最基本的判斷是兩邊只有true跟false值的話，全部為true才會是true，只要有一個false就會直接回傳成false。 舉例來說，假如小白他想要合法的騎車，他就必須滿足以下條件: 滿 18 歲 獲得機車駕照 有一台車 有安全帽 其中，假如有一項沒有達成也就是false，那麼最後的結果也會是回傳false，沒有辦法騎車。 123目前狀況 = 已滿18歲 &amp;&amp; 已有駕照 &amp;&amp; 已有車 &amp;&amp; 沒有安全帽;可以騎車嗎? =&gt; 不行 同等於 123const condition = true &amp;&amp; true &amp;&amp; true &amp;&amp; false;console.log(condition); // false 而跟||一樣，有著操作的值不是一個「boolean」值，也會被轉換成一個「boolean」型態的特性。 尋找第一個假值，找到就馬上回傳&amp;&amp;在全部只有true跟false只有回傳這兩者其中之一很單純，但要是每一種的值都不一樣時，那回傳是哪一個呢? 答案是按照順序從左到右，遇到第一個false的值，就直接回傳，要是到了最右邊都沒有false的值，就會回傳最後一個的true。 來證明這件事情。 已知1,2,3,4,5都是true，而 0,null,undefined,''會是false。 回傳第一個false: 1console.log(0 &amp;&amp; 1 &amp;&amp; 2 &amp;&amp; 3 &amp;&amp; null); // 0 第一個遇到的0就是false所以就會直接回傳，就算最後一個是null也不會碰到，從左到右的規則下，遇到0之後就停止比較了。 可以把0拿掉看看。 1console.log(1 &amp;&amp; 2 &amp;&amp; 3 &amp;&amp; null); // null 把0拿到之後，null就會變成最後一個false，所以會被回傳。 回傳最後一個的true: 1console.log(1 &amp;&amp; 2 &amp;&amp; 3 &amp;&amp; 4 &amp;&amp; 5); // 5 從左到右都碰不到false直到最後一個的5，那麼就會把最後一個的5這個true的結果給回傳。 再試一組看看。 1console.log(5 &amp;&amp; 4 &amp;&amp; 3 &amp;&amp; 2 &amp;&amp; 1); // 1 最後一個的true變成了1，且完全沒有false的值，所以會回傳1。 Logical NOT (!)我個人認為最好懂的Logical operators。 原理就是加上了一個!，true會變成false，false會變成true，一個反向的概念。 1console.log(!true); // false 1console.log(!false); // true 而對於不是「boolean」值的其他值，會變成反向的轉換成「boolean」型態。 12console.log(!&quot;小白&quot;); // falseconsole.log(!null); // true 所以有一種用法，就是我想要把一個值，變成「boolean」值的時候，可以使用兩個!。 12console.log(!!&quot;小白&quot;); // tureconsole.log(!!null); // false 想要的話，也可以用很多很多個!，不過通常只會用到兩個，之後的效果也都一樣。 3 個! 同等於 1 個! 。 優先級首先，要是||跟&amp;&amp;跟!比較起優先順序，那麼!是最大的。 無論何時，!都會在||跟&amp;&amp;之前被執行。 就像是先乘除，後加減。在邏輯運算子裡面是先 NOT，後其他操作。 其實還蠻合理的，沒有先用!轉完的話，根本沒辦法比較。 接下來是||跟&amp;&amp;。 &amp;&amp;會比||更優先執行，在執行||會先把&amp;&amp;都解決。 1console.log((false &amp;&amp; true) || (false &amp;&amp; true)); //false 也可以看成 1console.log((false &amp;&amp; true) || (false &amp;&amp; true)); //false reference[1] MDN - Expressions and operators[2] MDN - Logical AND (&amp;&amp;)[3] MDN - Logical NOT (!)[4] MDN - Operator precedence","link":"/2022/10/08/JS23/"},{"title":"JS之路 Day24 - nullish coalescing operator (空值合併運算子)","text":"前言之前講的是常用的邏輯運算子，而有一個比較特別的，寫法是兩個問號。之前看不太懂，趁著今天研究出來順便寫自己的理解，接下來就直接開始。 ??根據 MDN 的解釋，當左邊的值是null或是undefined時，會回傳右邊的值，假如不是null或是undefined就會回傳左邊的值。 還記得前天講的||嗎？ ||是碰到第一個真值就回傳。 而當一個值，如果它不是null也不是undefined，那它就會是defined，意思是一個已經定義的值。 所以||跟??來做比較的話： ??會回傳第一個已經定義的值 ||會回傳第一個遇到的真值(true) 來試試看 =&gt; 左邊是null時，會回傳右邊的值，左邊不是null或是undefined，就會直接回傳左邊的值。 12console.log(null ?? 100); // 100console.log(50 ?? null); // 50 MDN 只有說左右兩側，測試看看假如兩組值以上的狀況。 12console.log(null ?? null ?? 100 ?? 50); // 100console.log(50 ?? null ?? null ?? 100); // 50 也是一樣效果，會回傳第一個已經定義的值，讓我想到一個問題，如果全部都沒有定義的值呢？ 12console.log(null ?? undefined); // undefinedconsole.log(undefined ?? null); // null 結果來看會回傳最後一個沒定義的值。 還有就是 MDN 裡面有提到說，不能跟||及&amp;&amp;共用。 12console.log(null ?? &quot;1&quot; || null); // SyntaxErrorconsole.log(null ?? &quot;2&quot; &amp;&amp; null); // SyntaxError 把目前的資訊整理一下。 ??主要用來邏輯判斷定義的值及未定義的值。 要是遇到第一個已經定義的值就直接回傳，否則就一直向右尋找，要是都沒有的話，就回傳最後一個未定義的值，然後不能跟其他邏輯運算子共用。 使用情境可以用在需要提供默認值的場合。 比如說，如果fruit的值不是不是null也不是undefined，就會顯示fruit的值，不然就顯示字串水果。 在這裡字串水果就是fruit的默認值。 12let fruit = &quot;蘋果&quot;;console.log(fruit ?? &quot;水果&quot;); // 蘋果 12let fruit = undefined;console.log(fruit ?? &quot;水果&quot;); // 水果 假如今天有一家水果店，開放標一顆蘋果，就可以利用??來判斷是誰搶到了，不買的人就用null表示，會按照順序問下去。 12345let first = null;let second = null;let third = &quot;Angela&quot;;console.log(first ?? second ?? third ?? &quot;流標&quot;); // Angela 有人可能會問說，那幹嘛不用||就好？ 依據碰到第一個真值就回傳的特性，在上面的例子使用||結果也會完全一模一樣。 12345let first = null;let second = null;let third = &quot;Angela&quot;;console.log(first || second || third || &quot;流標&quot;); // Angela 這邊要先從發展的角度來說。 過去的||，現在的????是很後期大約在ES11才出現的新語法，代表著是先有||，才有??的誕生。 而會有這種狀況的產生，我的理解是因為有些||沒辦法顧及的狀況，所以才需要有一個跟||很像但又不完全一樣的語法。 而這個答案其實前面就有暗示了。 ||會回傳真值，而??會回傳已定義的值。 這邊代表一件事情，那就是||只能判斷真值跟假值，也就是說，全部的假值都不會被回傳。 不論是0,“”,NaN,null,undefined，全部都不會被回傳。||沒有辦法區分它們。 這樣會造成很多麻煩的點在於，假如我今天想要的值就是0，那麼使用||將會沒辦法達到我想要預期的結果。 123let scope = 0;console.log(scope || &quot;默認值&quot;); // 默認值console.log(scope ?? &quot;默認值&quot;); // 0 我的變數值想設定成0，但是會發現說使用||會沒有辦法顯示出來，會直接跳到默認值，因為對於||來說，0是假值，不會回傳。 但如果使用??就不會發生這種問題，它會先判斷是不是有定義的值，如果不是非定義的值(null,undefined)，那就會是有效值，就不會被替換成默認值了。 reference[1] MDN - Nullish coalescing operator (??)","link":"/2022/10/09/JS24/"},{"title":"JS之路 Day28 - Currying (柯里化)","text":"柯里化是一個函數的運用技術，不只是JavaScript裡面，它可以運用在很多的地方，簡單來說就是幫忙做了轉換。 原本的函式可能是長這樣的： 1fnc(A, B, C); 柯里化後會變成這樣： 1fnc(A)(B)(C); 這兩種方式最後出來的結果都是會一樣的，而怎麼實現的等等就會提到，今天會從幾個角度介紹這個主題 =&gt; 介紹與原理 目的與好處 介紹與原理柯里化主要的用途是用來簡化呼叫函式的過程，像是說把呼叫 f(a,b)變成呼叫 f(a)以及 f(b)，就可以達成說，把一個很多參數的函式，切分成很多只有一個參數的函式。 舉例來說：這是一個簡單的相加，它是一個有很多參數的函式。 12345function plus(a, b, c) { return a + b + c;}console.log(plus(1, 2, 3)); //印出6 使用柯里化的方式改寫，讓它變成很多只有一個參數的函式。 12345678910function plus(a) { return function (b) { return function (c) { return a + b + c; }; };}// 一次性的呼叫多個console.log(plus(1)(2)(3)); //印出6 使用柯里化的方式後，可以一次性的呼叫多個，也可以讓最後只呼叫一個參數 1234567891011function plus(a) { return function (b) { return function (c) { return a + b + c; }; };}let plusThree = plus(1)(2);//最後呼叫裡面只放一個參數console.log(plusThree(3)); //印出6 其實最主要的概念就是這樣而已，這邊要記得兩件事情 柯里化不會去呼叫函式，只會對函式進行轉換 柯里化一次只會接受一個參數 而柯里化其實是藉由把函式當作參數，帶到另一個參數之中，讓傳遞到的最後一個函式回傳之前所有的結果。 目的與好處可以用來拆分程式碼，把比較重要的部分給保留，固定住一部分，只要改另外一部分就好，不用每次都全部寫出來。 比如說如果兩個數字需要相乘： 123function multiply(a, b) { return a * b;} 每次都需要填入兩個參數，但如果今天假如第一個數字是固定時，使用柯里化的方式就能夠，只填入一個參數達到相同的效果。 12345678910111213const multiply = (num) =&gt; { return (x) =&gt; { return num * x; };};const multiplyByTwo = multiply(10);console.log(multiplyByTwo(1)); //10console.log(multiplyByTwo(2)); //20console.log(multiplyByTwo(3)); //30console.log(multiplyByTwo(4)); //40console.log(multiplyByTwo(5)); //50 不僅是減少重複的寫入，提高複用性，整體看起來的可讀性也會跟著上升。 同時也代表著不用在想著要傳入多少參數，一次就只要專心地傳遞一個，出現錯誤時可以更好的找出問題所在，那麼今天就介紹到這邊，明天見～ reference[1] Currying - Wikipedia[2] Currying[3] Currying in JavaScript（柯里化）","link":"/2022/10/13/JS28/"},{"title":"JS之路 Day26 - Strict Mode(嚴格模式)","text":"前言JavaScript的嚴格模式，如其名會讓程式碼的檢視變的嚴格，嚴格意味著不讓你錯，寫起來會更加安全嚴謹。 今天會照以下幾個角度來講解： 嚴格模式由來 使用方式 禁止事項 使用情境 嚴格模式由來JavaScript寫法規則相對來說不嚴謹，像是弱型別的轉換特性，就算沒有寫清楚，JavaScript也會自動幫忙補完，不會報錯，好處是很容易上手，不會被一大堆語法的限制給綁手綁腳，不過同時壞處也是十分明顯的，有時候寫錯也不會報錯，那麼將會很難避免一堆潛在錯誤，在寫的時候也完全發現不了。 為了應付這種狀況，JavaScript在 2009 年 ECMAScript5 有新推出了這個叫做Strict Mode的語法，創造出一個模式，是很嚴格嚴謹的，提供一個給開發者改善上述提到不嚴謹導致出錯的問題，讓開發者可以自由選擇。 舉例來說，在嚴格模式下，沒有辦法使用一個沒有宣告的變數。 沒有嚴格模式: 12apple = 10;console.log(apple); //10 使用了嚴格模式： 123&quot;use strict&quot;;apple = 10;console.log(apple); //ReferenceError 接下來介紹在JavaScript要如何使用。 使用方式要讓程式知道是嚴格模式的話，首先要加上這段指令：&quot;use strict&quot;; 假如說是放在程式碼的最前面，會使整個JavaScript的檔案都變成了嚴格模式。 而也可以只放在函式裡面，那麼就只有函式會生效。 12345678function A() { &quot;use strict&quot;; // apple = 10; // console.log(apple);}// A();apple = 10;console.log(apple); 函式外面的範圍就不會被嚴格模式給影響到，所以可以理解成嚴格模式有分成兩種的作用域。 一種是Global Scope，在程式的開頭宣告，那麼它將會有全局的範圍都會變成是嚴格模式。 另一種是Function Scope。 在函式的開頭宣告，那它只會存在於函式的{}裡面是嚴格模式。 另外假如不是在開頭宣告，那在宣告了&quot;use strict&quot;;之上的所有程式碼，都不會被嚴格模式影響到。 所以假如要使用嚴格模式的話，很重要的一點是確保&quot;use strict&quot;;出現在最頂部，不論是Global Scope或是Function Scope。 還有一個使用上要注意的小地方是，當使用&quot;use strict&quot;;之後，就沒辦法取消，沒有指令可以再返回沒有&quot;use strict&quot;;的狀態，所以假如用了嚴格模式後，不想要使用了，就只能在當初寫的&quot;use strict&quot;;給刪除或是註解掉。 禁止事項除了上面有提到過的沒宣告的變數沒辦法使用之外，如果變成了嚴格模式將會有這些限制： 不能使用 delete 刪除變數或是函式 刪變數 =&gt; 123&quot;use strict&quot;;let apple = 10;delete apple; // SyntaxError 刪函式 =&gt; 12345&quot;use strict&quot;;function apple() { return 10;}delete apple; // SyntaxError 不能重複參數名稱 12&quot;use strict&quot;;function apple(A, A) {} //SyntaxError 不能使用八進制數字 12&quot;use strict&quot;;const apple = 010; //SyntaxError 不能使用eval跟arguments當變數名稱 123&quot;use strict&quot;;const eval = 10; // SyntaxErrorconst arguments = 10; // SyntaxError 不能使用with 1234&quot;use strict&quot;;with (Math) { x = cos(2);} // SyntaxError 以下的關鍵字為了將來版本的保留，所以在嚴格模式下也通通不能拿來當變數名稱：implements、interface、let、package、private、protected、public、static、yield 嚴格模式時，this 的預設狀態都會指向undefined 瀏覽器環境 node.js 環境 嚴格模式 undefined undefined 非嚴格模式 window global 使用情境什麼時候會用到，該不該去使用嚴格模式，我的看法是要是一個專案或者是程式碼已經很龐大了，也許可以先從Function Scope的方式去使用嚴格模式，因為假如在一個專案中直接改成嚴格模式的話，可能會直接無法運作且一時之前有點難改完。 而在寫程式的一開始就直接使用嚴格模式就不會有這個問題，而且也會幫助養成好習慣，寫出來的程式碼也會好維護，而有些新的結構其實就內建了嚴格模式，像是之前有講到過的class，以及module，使用它們的時候沒有設定嚴格模式也會有嚴格模式的效果。 關於嚴格模式的介紹就到這邊，各位明天見。 reference[1] MDN - Strict Mode[2] W3C - JavaScript Use Strict","link":"/2022/10/11/JS26/"},{"title":"JS之路 Day25 - Arrow Function (箭頭函式)","text":"前言今天要來介紹什麼是Arrow Function，這個是一個看起來非常簡單的語法，因為=&gt;就像是箭頭一樣所以叫做Arrow Function，它可以直接把函式的建立變成簡化版，看起來像是這樣： 1let arrow = (a, b) =&gt; a + b; 會叫做Arrow Function也是因為=&gt;就像是一個箭頭的關係，雖然看起來很簡單，但其實我自己在寫時常常忘記怎麼寫,利用這次寫文章的機會來複習一下。 過去與現在Arrow Function是 es6 之後才出來的新語法，意味著在此之前都是只能用以下這些方式。 一般做法： 12345function past() { return &quot;過去做法&quot;;}console.log(past()); // 過去做法 匿名做法： 12345let past = function () { return &quot;過去做法&quot;;};console.log(past()); // 過去做法 es6 之前只能用上面那兩種方式，之後多了一種箭頭函式可用。 而箭頭函式有點像是匿名的進階版： 123let now = () =&gt; &quot;箭頭函式做法&quot;;console.log(now()); // 箭頭函式做法 省略了很多東西變成了匿名更短的版本，最主要的變化以上面那個例子來看： 省略了function 省略了大括號 {} 省略了寫return 但其實不是每一次都可以省略那麼多，還是需要看狀況，以下就介紹箭頭函式的語法以及使用情境。 寫法注意事項關於省略function的部分，只要用了=&gt;，那就代表說function不用寫，目前還沒遇到非寫不可的狀況，假如直接多寫的話還會報錯。 1let A = function() =&gt; &quot;A&quot;; // SyntaxError 而{}則是需要跟return綁在一起來做說明。 可以理解成，有return就一定要用{}，不能直接使用return，而單獨使用{}時，箭頭函式也不會自動幫忙return，這點要注意。 可以省略的情境是如果函數只有一個語句，而且只回傳一個值的時候，{}跟return就可以同時被省略，比如說像是這樣： 12345let A = () =&gt; { return &quot;A&quot;;};console.log(A()); // A 可以變成這樣: 123let A = () =&gt; &quot;A&quot;;console.log(A()); // A 省略時，不就代表沒有作用，會變成箭頭函式自動幫忙做，所以其實還是會有{}跟return的效果。 而帶參數的那個小括號其實也是可以被省略的。 省略的情境是只有一個參數時： 123let A = (a) =&gt; a + 10;console.log(A(5)); // A 只有一個參數的箭頭函式實際上就可以把那個小括號直接省略掉。 123let A = (a) =&gt; a + 10;console.log(A(5)); // A 但不是所有情況都可以省略小括號，當不只有一個參數，或是根本沒有參數的時候，小括號就沒有辦法去省略。 用法限制箭頭函式雖然很方便，但還是有許多情境只能依靠傳統函式才能做到。 像是說在箭頭函式是沒有自己的this跟arguments跟super，因為沒有自己的this代表說需要去找它時，只能夠從外部去獲取。 而沒有自己的this也表示說，箭頭函式不能當作構造函式來用，也沒辦法使用new來調用它們，同時也不適用 call跟apply跟bind的方法。 所以還是可以用this，只是跟傳統函式不一樣，不是由呼叫的方式來綁定，所以this的方法沒辦法使用。 最後箭頭函式也無法作用於生成器函式使用(generator function)，不能使用yield這個關鍵字。 可以發現說箭頭函式雖然遠比傳統函式來得方便許多，但同樣限制也很多，不能在所有的情況下使用，所以假如有箭頭函式很方便，那就全部都用箭頭函式這種想法的話，是行不通的。 總結透過箭頭函式的各種省略，可以使用更短的語法寫出一樣的效果，不只會讓整體的程式碼看起來很精簡，可讀性也會跟著增加，是我覺得好處多於壞處的一個語法，只是要注意有些情境沒辦法使用，總之建議適量的在程式碼中使用，讓程式碼便得簡潔乾淨吧！ reference[1] MDN - Arrow function expressions","link":"/2022/10/10/JS25/"},{"title":"hexo 有部署沒顯示問題","text":"狀況問題如下：我的其中一篇”Selector Combinators 中的+跟~差別”，已經部署上去的文章，明明已經成功部署了，但是點進去看時會出現這個畫面 剛看到時毫無頭緒，後來思考了幾種拯救的方式來試試看能不能救回來 重新做部署的動作12hexo g // 建立靜態頁面hexo d // 部署到github 還是沒辦法 修改 code那我在想有可能是因為 code 的部分有寫錯的問題，仔細檢查了程式碼之後的確有不尋常的地方 試試看把標題裡那個有藍色波浪號拿到後，是不是就正常了 也不是這個問題，排除 結論經過多次的比對之後，發現了原因source 裡 posts 文件的命名中我有使用到～及＋看來名稱的使用上要注意一些符號雖然本地端預覽使用 hexo server 看都沒問題，不過推到遠端就會發生 404 最後改過後就又恢復正常了～","link":"/2022/05/30/blog%20not%20showing/"},{"title":"JS之路 Day27- JSON Methods(JSON 方法)","text":"今天要來介紹JSON的兩個靜態方法： JSON.parse() JSON.stringify() 會從什麼是JSON開始介紹起，直接開始吧。 JSONJSON的全名是JavaScript Object Notation，它是一種輕量型的數據交換格式，就是可以用來儲存跟方便傳遞的一種格式，跟物件的樣子很像，但其實不太一樣，會有著JSON的出現，主要還是單純物件的話，還不夠簡單跟容易閱讀。 跟使用物件的格式有一些差別。 第一JSON它只能用雙引號，不能用單引號，不論是key還是value，物件沒有這種限制，可以用單引號，甚至key不要加引號也沒有關係。 第二JSON 支持 object、array、string、number、boolean 和 null，基本上除了undefined之外其他全包了。 不過雖然支持，但是大部分的JavaScript都不是JSON，主要原因還是上面第一點，不論是key還是value都需要雙引號。 簡單說，JSON 是用來表示在JavaScript物件的一種格式，比單純的物件格式更好閱讀，有更高的相容性。 JSON的範例： 1234567{&quot;fruit&quot;:[ {&quot;fruitName&quot;:&quot;apple&quot;, &quot;customer&quot;:&quot;Rex&quot;}, {&quot;fruitName&quot;:&quot;banana&quot;, &quot;customer&quot;:&quot;Vic&quot;}, {&quot;fruitName&quot;:&quot;orange&quot;, &quot;customer&quot;:&quot;Dan&quot;}]} JSON.parse()當想把JSON轉換成物件的時候，可以使用的一個方法。 可以用型別的方式去想像，從string轉換成object。 1234567let one = &quot;[1,1,1,1,1,1]&quot;;console.log(typeof one); // stringone = JSON.parse(one);console.log(typeof one); // object JSON.stringify()當想把物件轉換成JSON的時候，可以使用的一個方法。 型別來說的話，是從object轉換成string。 12345678910111213let fruit = { name: &quot;apple&quot;, color: &quot;red&quot;, delicious: true, customer: [&quot;vic&quot;, &quot;tom&quot;, &quot;while&quot;], price: &quot;1000&quot;,};console.log(typeof fruit); // objectfruit = JSON.stringify(fruit);console.log(typeof fruit); // string 但是有一些特別的地方。不是總是能轉換成string，只能確定object會轉換成string，其他假如像是數字或是布林，那經過JSON.stringify()也不會發生改變。 用 10 來轉換的話，數字還是數字，不會變成”10”。 1console.log(JSON.stringify(10)); // 10 字串的話轉換還是字串，只是單引號會變成雙引號。 1console.log(JSON.stringify(&quot;apple&quot;)); // &quot;apple&quot; 陣列轉換出來還是陣列。 1console.log(JSON.stringify([1, 1, 1])); // [1,1,1] 布林值轉換出來還是布林值。 1console.log(JSON.stringify(false)); // false 但以上這些去觀察它們的型別會發現通通都還是string。 1234console.log(typeof JSON.stringify(10)); // stringconsole.log(typeof JSON.stringify(&quot;apple&quot;)); // stringconsole.log(typeof JSON.stringify([1, 1, 1])); // stringconsole.log(typeof JSON.stringify(false)); // string JSON.parse() + JSON.stringify()可以把一個物件，把它轉換成JSON，再轉換回來。 123456let programmer = { name: &quot;vic&quot;, age: 23,};let programmer2 = JSON.parse(JSON.stringify(programer)); 這舉動看似毫無意義，但其實非常有用。 利用這個方式，可以達到物件的深拷貝。 拷貝的意思是複製一個東西出去，拷貝出來的那個東西，不會影響到原來的東西。 正常來說物件因為是傳址的緣故，所以如果只是單純的 A = B 這種賦值，是沒辦法達到拷貝的效果，這樣改 B 就會改到 A。 物件想要獲得拷貝的效果，有幾種方式可以達成。 一種是使用 Object.assign的方式，也可以使用 spread operator的方式去進行物件的拷貝。 但這種方式其實也只能保持，物件的複製一層的效果，要是再更改到裡面的層，會發現說還是會有改 B 就改到 A 的現象，所以會把這兩種方式稱之為淺拷貝，有拷貝的效果，但是只有表層有。 而JSON.parse() + JSON.stringify()卻是深拷貝，用了這個方式，就可以達成說物件複製後完全不會改變到原來的物件，這也是我唯一知道的深拷貝方式。 最後前面有提到說，今天介紹的這兩個方法都是屬於靜態方法，那會有動態方法嗎？ 其實在JSON之中，就只有動態方法的存在，不只是方法，JSON的所有屬性跟方法都是靜態的。 關於要如何區分，可以這樣理解，動態方法是需要要先創建實例才能使用，而靜態方式就直接使用就可以，像是Math，我們可以直接從JavaScript去做取用，不用再new出一個實例。 而動態方式就像是date還需要先new Date之後，才能去使用它底下的方法。 在JSON中的所有方法通通都是靜態的，代表說都可以直接取用，同時也沒有辦法。 因為JSON不是一個構造函式，所以也沒辦法使用new，那麼今天對JSON Methods介紹就到這邊，明天見～ reference[1] MDN - JSON[2] W3C - JavaScript JSON[3] MDN - Working with JSON","link":"/2022/10/12/JS27/"},{"title":"JS之路 Day29 - Destructuring assignment(解構賦值)","text":"解構賦值是 es6 之後出來的一個新語法，我的理解它是一種語法糖，語法糖意思也就是說它可以用更簡單的方式達到相同的效果。 至於它究竟解構了什麼？其實就是陣列或是物件裡面的值，原本我們假如要取出陣列跟物件裡面的值，可能會這樣來寫： 123456789101112// 陣列的情況const goodNum = [10, 20, 30, 40];// 我想要取出裡面的數字，各個分別取出來const one = goodNum[0];const two = goodNum[1];const three = goodNum[2];const four = goodNum[3];console.log(one, two, three, four); // 10 20 30 40 123456789101112// 物件的情況const goodFruit = { name: &quot;西瓜&quot;, color: &quot;green&quot;,};// 我希望把個別key內中的value給取出來const name = goodFruit.name;const color = goodFruit.color;console.log(name, color); // 西瓜 green 但如果使用解構賦值的話，取用的方式就會變得稍微有些不同： 123456789// 陣列使用了解構取值的情況const goodNum = [10, 20, 30, 40];// 我想用a,b,c,d 這四個變數去取到這些從陣列之中解構出來的值const [one, two, three, four] = goodNum;console.log(one, two, three, four); // 10 20 30 40 原本取出值之前，還需要宣告變數的部分取消了，直接可以把陣列裡面的值給解構出來變成一個獨立的變數。 左邊陣列裡面變數會把右邊陣列裡面的值給裝起來。 12345678910// 物件使用了解構賦值的情況const goodFruit = { name: &quot;西瓜&quot;, color: &quot;green&quot;,};let { name, color } = goodFruit;console.log(name, color); // 西瓜 green 物件的解構方式會有一些不一樣的地方，就是因為有 key 及 value 的關係，所以為了確定可以成功獲取物件裡面的 key 的 value，所以一定要是跟它一模一樣的 key 才能取到，跟陣列相比會有這種限制，如果用自創的變數來試圖取，沒辦法只依靠位置獲得。 123456789const goodFruit = { name: &quot;西瓜&quot;, color: &quot;green&quot;,};let { aaa, bbb } = goodFruit;console.log(aaa); //undefinedconsole.log(bbb); //undefined 會發現抓不到東西，沒有相對應的 value 值，所以會出現 undefined。 這邊會發現陣列跟物件在解構上的順序會有所差別，陣列的話會去依照它的索引值去抓取，而物件的話會依照物件的屬性名稱也就是 key 值來抓取，這是這兩者之間的差別。 上方講的一些基礎的方法，再來會介紹一些陣列跟物件一些特別的用法。 Array Destructuring因為陣列會照著索引值來去一個個抓值，所以當其中有想要跳過的部分時，會沒辦法直接跳過，所以可以利用空格的技巧，跳過那個索引值不需要的部分。 12345678//陣列的忽略某些值function f() { return [1, 2, 3];}const [a, , b] = f();console.log(a); //1console.log(b); //3 解構賦值也可以拿來做陣列的變數交換。 1234567891011//陣列的變數交換let a = 1;let b = 3;[a, b] = [b, a];console.log(a);console.log(b);const arr = [1,2,3];[arr[2], arr[1]] = [arr[1], arr[2]];console.log(arr); 陣列遇到字串時如果解構會自動變成字元的樣子。 123// 遇到字串會解構成字元let str = &quot;床前明月光&quot;;let [a, b, c, d, e] = str; Object Destructuring剛剛有提到說，因爲物件的解構是看 key 的值，所以如果直接在外部去定義子己想要設定的變數名，會找不到，但還是有需要自己定義變數名稱的場景，這時候可以利用在取變數時，在那邊 key 值旁邊增加一個：寫變數名稱的方式，來達到說改變變數名稱的效果。 12345678// 重新賦予變數名稱let value = { aaa : 111, bbb : 222, ccc : 333,}let {aaa: apple } =value 另外如果是物件需要預設值的狀況，直接在變數那邊使用等於就好，這點陣列也是相同的。 陣列預設值： 物件預設值： 總結 解構賦值能夠減少很多重複性的事情，也能提高代碼整體的可讀性 陣列跟物件的解構賦值取值順序不同，陣列是看索引值，物件則是屬性名稱 除了順序之外陣列跟物件所用的括號也不一樣，一個是中括號，一個是大括號 大家也多多使用解構賦值的方式來取值吧！明天將會進入這次鐵人賽的最終章。 reference[1] MDN - Destructuring assignment","link":"/2022/10/14/JS29/"},{"title":"JS之路 Day30 - 結束與開始的序言","text":"大家好，我是 Vic，目前已經寫到鐵人賽的最後一天，過程中受到很多好人的幫助指點，讓我獲得了不放棄的勇氣，今年的鐵人賽無論結果如何，我覺得至少我自己已經做到了堅持，而這不是單單靠我一個人就辦得到，是遇到了一堆好人後最終產生的結果，所以在開頭想感謝所有幫助過我的人事物。 感謝好想工作室的這個環境，感謝給我建議跟指點的每個朋友，也感謝團體賽中每個夥伴的互相包容，因為雖然當了團長，但我其實連自己都顧不太來，所以很多時候沒時間去關心其他人的進度，能夠順利平安結束真的是太好了。 這次的鐵人賽文章會同步發佈於: 我的部落格 接著就進入最後一次的序言時間。 預想與實際我是一個不囤稿派的。 我的想法是鐵人的精神就是要藉由每天迫使自己的產出，排除萬難來達成挑戰，藉此來磨練自身意志力，培養出持之以恆的習慣，若是通通都先寫好了，不過就只是一個無情的發文機器人，每天時間到就發，發完就去做其他事情，磨練在哪裡，鐵人精神又在哪裡，所以我都沒有準備文章。 只有一個念頭是，我應該從困難的開始寫，我有注意到之前鐵人賽其他參加者的狀況，很多半途而廢的人，蠻多有一個共同點，都是從簡單的開始寫，寫到後面開始越寫越難，最終很多人就選擇了放棄。 我就想說，假如我先把系列最難的部分給寫完了，那後面不就是越來越輕鬆？一種倒吃甘蔗的概念，於是我興奮的想著，那我一開始就要直接先來寫我覺得 JS 中最難理解的 Prototype、class，還有this 跟Promise，那時就這樣描繪著開賽後的美好藍圖，一邊等待著鐵人賽的開賽。 就如同第一天文章寫的，我的預想如下： 有著這些想法的我，在開始沒多久，就被現實的鐵拳打得眼冒金星。 計畫總是趕不上變化，鐵人賽開始前一天被交付了一個專案，那是個我不能放棄的機會，意味著大半時間要花在那上面，還有兩個正在持續進行的讀書會，那時每週一、三、五都要花兩小時參與讀書會，鐵人賽時間還有幾場需要導讀，真是壓力山大，本來還想在鐵人賽過程中再撥一些時間來完成我的 JS30 練習跟 todolist 練習，不過從我的第二天的鐵人賽文章寫到半夜都發不出來後，我就抹滅掉了這些想法。 後來剛開始的幾天，我發現我完全低估了每天發文的壓力，沒有整天的時間可以寫文章，跟害怕寫不出來的話會害得所有團賽的夥伴都一起失去團賽資格，恐懼與壓力交織堆疊，前面二十天大概是最痛苦的時候，中間還病倒休息半天差點文章完蛋，那陣子很懷念床，因為沒機會躺都在桌上睡覺，但那時每個禮拜會去全家買好好吃的買一送一霜淇淋，所以某種程度來說有取得一種平衡。 進入狀況後，會藉由捨棄掉一些不重要的東西，以及請別人幫忙當團長的小幫手，幫我注意其他人狀況，替我省下了不少時間，也發現到人的時間就像是牙膏一樣，想擠的時候還是多少能擠出來，不要小看人的潛力，寫這篇文章時，案子差不多進入結案階段，最困難的階段已經撐過去，真是開心。 雖然預想跟實際的狀況不太一樣，但整體上還是蠻順利的，如果問我說下次參加鐵人賽還會不會不囤稿，我的選擇會還是一樣，因為我是不囤搞派。 結束與開始就如標題所講的，這是一段結束與開始的序言，鐵人賽結束的同時，一些事情也隨之跟著開始，在下個階段開始之前， 我想去躺在我的床上睡個沒有壓力的好覺，然後去剪頭髮跟刮鬍子，整理這段時間所學習到的心得記錄下來，然後把自己的作息給調整回來。 而主題介紹的那個問句，鐵人賽完賽後就真的能往前邁進嗎？ 對現在已經快做完這一場挑戰的我來說，答案是肯定的，向前邁進的意思不意味著已經寫得很完美，我不覺得我這次系列的文章寫的有多好，但不是只有成功了才是有進步的。 我接受了挑戰，在我能力所及的範圍內，努力做到了最好，那麼不管結果如何，我覺得自己就已經往前邁進了，我沒辦法說自己已經比誰誰誰厲害，但我可以說下次寫的文章，一定會比之前寫的還要好。 這次的結束不是結束，而是下一個階段的開始，期許自己能變得更卓越，變成像是別人幫助我那樣，我也可以幫助其他人。 那就準備新的開始吧，三十天的 JS 之路，落幕 友情推薦最後我想分享一些邦友的系列文來結束我今年的鐵人賽，推薦大家可以去看～每篇都是用心撰寫的好文。 幫助 vue 新手認識 vue3 及避開各種的坑 =&gt; 真的好想離開 Vue 3 新手村 feat. CompositionAPI 搭配 ECMAScript 讓你從另外一個角度看 Array method! =&gt; 咩色用得好，歸剛沒煩惱 - 從 ECMAScript 偷窺 JavaScript Array method 手把手帶你練習 PixiJS 語法 =&gt; PixiJS 青銅玩家 利用學習的撞牆經驗讓你了解前端技術 =&gt; 前端蛇行撞牆記 從零重新帶你認識 JS 一遍 =&gt; [學習筆記] 邊學邊寫 JavaScript 30 天","link":"/2022/10/15/JS30/"},{"title":"css position 小心得","text":"原文連結: https://appcs342.blogspot.com/2022/04/css-position.html移植時的最後更新日期: 2022-04-08T21:36:10.985-07:00 &nbsp;最近有在研究position，在css中這算是一個非常重要的屬性，網頁中的定位全要靠它，在此整理一些研究時的筆記跟我的小小心得～首先，是我對position作用的理解對網頁上物件的屬性添加了position就可以改變物件的排列方式，改變其在網頁上位置，但其實就算都沒有添加，原本物件間也會有自己的排列，所以我會覺得說，position它其實是在對網頁上的物件做一個「改變定位參考對象」的動作，預設狀態下參考對象會是原本物件資料自己本身的排列狀態，position的值會改變定位參考對象，從而改變物件排列方式。position主要有的值大致分成以下五種：staticrelativefixedabsolutestickystatic這個值是假如都沒設position，預設就會是satic。幾個我覺得重要的點使用了這個值，其他的定位方式都會失效很少用到，因為預設就是static，我想要預設那我就不下就好relative相對定位，它的定位參考位置還是原本預設狀態的，但是可以讓顯示位子去做偏移，意思就是能在不改變網頁佈局的狀態下去改變物件位子，假如去做偏移的話，會依造原本預設狀態的基礎下再去改變absolute絕對定位，它的定位參考位置就直接脫離原本預設狀態，所以讓設定的物件做偏離之外，就不會佔據任何空間 ＝ 其他沒被absolute且還是原本預設狀態的物件也會被跟著影響。另外，它的參考對象會是最近的非static設定的父層空間，所以常常在使用absolute時它的父層會在設定一個relative就是此道理，除了relative之外，fixed跟sticky也可以作為定位參考對象fixed固定定位，它的定位參考對象一樣會脫離原本的預設狀態，不過跟absolute不同的是，所定位參考對象會是當前視窗，意思就是當在滑動視窗捲軸時，不管怎麼滾動，被設定了fixed的物件都能一直固定在相同位置，等等講完sticky會一起用示意圖來跟abosolute做比較sticky黏貼定位，擁有剛剛所講述的relative和fixed的特性，關於定位參考對象可以成在跨過特定值前為相對定位，之後為固定定位，那什麼是特定值呢？ 這就要來說到為什麼要使用黏貼定位：簡單來說，是想要在網頁畫面上有著固定的效果，但是滑到一定地方之後，就不想繼續固定時，就會使用sticky，關於上述所提到的特別值，也就是在設定黏貼定位，必須要指定top、right、 bottom 、left 這四個屬性值其中之一，否則sticky的行為就會變得跟相對定位一樣三者示意圖比較時間最後來講一些我自己覺得在學習position時一些重要的地方position有什麼值&nbsp; 為什麼要分這些值預設時跟有了position之後的狀態改變不同值所參照的容器層也不同，哪裡不同研究position的資料來源position org規範position mdnposition - 金魚都能懂的CSS必學屬性前端新手村 Position 定位","link":"/2022/04/09/css%20position/"},{"title":"grid的不同解讀","text":"繼 css flex 佈局出來之後，後來又出現了 css grid 的佈局方式，不過 grid 這個詞不是被新發明出來的，是之前就有的東西。 假如你想跟別人討論說要使用 grid，但沒講清楚是哪種「grid」的話，可能溝通上就會造成許多問題，這篇會提到有三種解讀方式： 格線系統(grid system)的 grid一種 ui 設計會使用到的概念，可以幫助設計師更好的在畫面上安排，另外前端框架 Bootstrap 也會使用到 grid system，這邊要注意到並不是指 css 裡面的那個 grid css 佈局方式的 grid屬於 css 裡面的佈局方式，使用時 display 會先變成 grid，如： 1display:grid 使用之後，這個使用的區塊元素就都會變成「grid」，只需再搭配一堆 grid 系列的語法，就能利用 gird 讓網頁排成自己想要的形狀～ 簡寫屬性的 grid剛剛上面提到，把區塊設成「grid」物件後，就能利用一堆的 gird 系列語法來完成佈局，這邊提到的簡寫屬性的 grid 就是它裡面的其中一種寫法，如： 123grid: auto-flow / 1fr 1fr 1fr;grid: auto-flow dense / 40px 40px 1fr;grid: repeat(3, 80px) / auto-flow; 小結一個 grid 各種解讀，蠻容易搞混的，就像我當初學習 Bootstrap 以為它的 grid system 主要是用 css 的 grid，但是並沒有，反而還跟 css 的 flex 相關度比較大。","link":"/2022/05/19/grid%20explanation/"},{"title":"HTML 內建範本的三個meta","text":"創建完.html 的檔案後，在開始把版面切出來之前，通常會使用!的方式把內建的範本給建立出來，使用內建範本會把一些基本的東西都先呈現出來，像是 html、head、body 的 tag。 雖然十分的理所當然，但也因為方便所以有時會忽略掉那些內建的東西是什麼，在內建範本之中，我覺得最容易被忽略掉，跟最容易經過時間遺忘的是其中的三個 meta tag，所以在此做個筆記讓之後遺忘可以複習。 &lt;meta charset=&quot;UTF-8&quot;&gt;這一段是跟編碼有所關聯，可以用來指定說這個網頁內容需要用什麼編碼。 一般來說會使用”UTF-8”來做編碼，HTML5 的規範也推薦所有開發人員都使用 UTF-8 字符集，因為它幾乎涵蓋了世界上所有的字符跟符號。 詳細可以參考這一篇文章，我覺得還不錯：[HTML][新手] 04. 中文編碼表示 meta charset &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;這一段主要是用到控制 IE 相容模式，可以用此來設定 IE 的版本。 讓在 IE 瀏覽器的時候，也能正常地觀看網頁，但現在因為 IE 已漸漸沒落，所以感覺這段的作用慢慢減少中，之後可能就會完全停用。 關於這塊的文章：IE 相容模式設定 X-UA-Compatible詳解 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;這段的作用是 rwd 響應式的設定，會需要 meta 裡面的 viewport 來指定瀏覽器怎麼渲染和縮放網頁畫面的的大小。 比較詳細的語法介紹：html viewport meta 淺見及說明","link":"/2022/10/24/html%20three%20meta%20tag/"},{"title":"JavaScript 請解釋「遞迴」的概念","text":"我們先來看一下遞迴(recursion)在 mdn 上面的定義： 函式呼叫函式自己的行為，稱為遞迴、或是遞歸。它主要用於解決含有子問題的問題。遞迴函式會收到兩個輸入：結束遞迴的基本情況（base case）或是延續遞迴的遞迴情況（recursive case）。 簡單來說，就是一種自己定義自己的意思，利用自己定義自己來解決問題，通常需要被遞迴的問題是一個可以被分成很多小問題的大問題。 可以使用迴圈解決的問題，也可以用遞迴來做解決，原本只會使用迴圈的我，想不通幹嘛要用遞回，後來想想其實多了一種新的解決問題的方式是一件好事。 會想要特別寫遞迴是因為一開始看不太懂，但突然看著看著就有了一些概念覺得蠻特別的，所以就來試著講解做個紀錄。 一個基本的遞迴會需要有： 終止條件 遞迴條件 第一個是因為假如沒有終止條件，那函式不斷的呼叫自己，最後就會變得沒完沒了，程式將無窮無盡不會結束。 而遞迴條件就是呼叫自已的條件，沒有終止條件就會無限循環然後當掉，但是沒有遞迴條件就沒辦法呼叫自己，程式就不知道怎麼呼叫。 遞迴小故事： 從前有座山，山裡有個廟，廟裡有個老和尚在給小和尚講故事，講的是從前有座山，山裡有個廟，廟裡有個老和尚在給小和尚講故事，講的是從前有座山。。。 出處：https://iter01.com/9337.html 遞迴裡面有個經典的例子：費氏數列以費波那契數為邊的正方形拼成的近似的黃金矩形圖片來源：https://zh.m.wikipedia.org/zh-tw/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0 在數學上，費波那契數是以遞迴的方法來定義： f0=0 (1) f1=1 (2) Fn = Fn-1+Fn-2 (3) 其中(1)跟(2)就是上述提到的終止條件，而(3)是遞回的定義 簡單來說，費式數列是從零開始，之後的數字都是由前面的數字兩者相加而成： 11、 1、 2、 3、 5、 8、 13、 21、 34、 55、 89、 144、 233、 377、 610 使用 JavaScript 迴圈的寫法來寫： 123456function fibonacci(n) { if (n &lt; 2) { return n; } return fibonacci(n - 1) + fibonacci(n - 2);} 小結寫的比較簡單，但是遞迴其實還有很多東西可以講的，待日後我懂更多後再回來補充吧 最後分享一下我有做了一個簡報然後上台分享，裡面寫得比較深，在這邊也分享一下：https://hackmd.io/@OjHi9LEySUSS8jl6WKL4ug/HJZNNa0tc#/ 參考資源 JavaScript 學演算法（二十二）- 遞迴 Recursion Javascript 的遞迴(Recursive) mdn 遞迴 岔路上的風景 - 遞迴 JavaScript 演算法之遞迴 維基百科-費波那契數","link":"/2022/06/22/javascript%20%20recursion/"},{"title":"什麼時候會用img , 什麼時候會用background-image","text":"原文連結: https://appcs342.blogspot.com/2022/03/img-background-image.html移植時的最後更新日期: 2022-03-26T01:01:42.352-07:00 一個是html標籤的img，一個是css的background-image，兩個都能讓網頁中顯示出圖片。我自己目前個人遇到的狀況會使用img &gt; background-image 。img:會使用img的情況通常是：網頁不只是需要單純的一張圖片而已，還需要像是超連結的功能，或是想讓圖片能夠縮小放大。有需要使用動畫的時候，因為img的動畫表現會比background-image更好。影印頁面時，圖片也想跟著被印出來。&nbsp;background-image:簡單來說，是像是網頁中當背景圖片的感覺，意味著background-image其實並沒有自己本身的意義存在，它沒有辦法去代表網頁中內容的任何事情。會使用的狀況：圖片不是內容的一部分（設計考量）。網頁需要有圖片當背景。影印頁面時，圖片不想跟著被印出來。小結：img是屬於頁面內容的一部分，它是擁有含義的圖片。background-image則是不屬於頁面內容的一部分，它是沒有含義，可以拿來單純當作背景的圖片。","link":"/2022/03/26/img%20and%20background-image/"},{"title":"javascript的throw用法","text":"js 在拋出錯誤的時候會使用到 throw 提到throw之前要先來介紹一下相同性質的try, catch try…catch它會分成兩個區塊，一個 try 一個 catch 123456try { // 要執行的程式} catch(error) { // ... // 錯誤發生時，上面的就不會執行，改執行這邊} 舉例時間： 12345try { console.apple(&quot;apple不是正確的使用方式喔&quot;);} catch (e) { console.log(&quot;我錯了&quot;);} 這段 code 的結果會印出我錯了，如下： 為什麼會發生這樣的結果？這是因為如果try區塊裡面的程式碼假如沒有任何的錯誤，就會直接忽略掉catch區塊裡面的程式碼，反之有錯的話，就會以catch裡面的程式碼為主，而錯誤的try就會中斷執行，所以在這個範例來說，因為try寫錯了，所以會以try裡面的程式碼為主 另外如果catch區塊如果接受了一個參數，就可以直接利用這個參數獲取錯誤資料，一般都會是直接在後台輸出資料，這邊來試試看： 12345try { console.apple(&quot;apple不是正確的使用方式喔&quot;);} catch (e) { console.log(&quot;錯誤訊息 :&quot;, e);} 這段 code 的結果會印出錯誤資訊，如下： throw接下來介紹這次的主題throw，它常常用於上面提到的try…catch結構，throw這個語句只要一出現就會直接中斷程式執行，代表說在它之後的語句都不會再被執行，簡單來說，在try的區塊時碰到throw就會直接中斷執行並且把控制權交給catch的區塊，所以說要是沒有catch的區塊，程式就會立刻停止 就如同最前面說的，throw可以拋出一個錯誤，這樣的好處是可以很清楚的知道說錯誤的具體位置，可以很方便去做判斷 舉例時間： 1234567891011try { console.log(&quot;這邊很多蘋果，準備開始賣給顧客！&quot;); throw &quot;等等有壞蘋果！終止交易！&quot;; // throw 會中斷進行 // 故意製造壞蘋果 console.BadApple(&quot;壞蘋果x5&quot;); // 假如沒有被中斷，可以正常賣蘋果的世界線 console.log(&quot;好吃蘋果，大賣特賣，大家快來買！&quot;);} catch (e) { console.log(e); console.log(&quot;有壞蘋果不准你賣！&quot;);} 這段 code 的結果順序會是 1231. 這邊很多蘋果，準備開始賣給顧客！2. 等等有壞蘋果！終止交易！3. 有壞蘋果不准你賣！ 如下： 首先，因為throw會中斷後面所有語句執行的特性，所以上面那段範例中還沒遇到壞蘋果x5就會直接跳到catch區塊的有壞蘋果不准你賣！，這邊我故意把壞蘋果x5弄成製造錯誤的方式，但是一樣被中斷跳過，於是可以發現一件事情： throw中斷了後面所有語句，包括了錯誤也一樣 所以這邊衍伸出了一個問題，如果錯誤是發生在throw語句之前，那會發生什麼事情呢，我們來試試看： 12345678910try { console.log(&quot;這邊很多蘋果，準備開始賣給顧客！&quot;); console.BadApple(&quot;壞蘋果x5&quot;); throw &quot;等等有壞蘋果！終止交易！&quot;; console.log(&quot;好吃蘋果，大賣特賣，大家快來買！&quot;);} catch (e) { console.log(e); console.log(&quot;有壞蘋果不准你賣！&quot;);} 結果如下： 從結果可以發現說，假如錯誤發生在throw語句之前，那麼錯誤還是會被正常的顯示出來，而throw語句傳送的東西就不會出現，所以就可以利用像是這種模式，慢慢的交替把程式碼錯誤的位置給尋找出來 以上是我在學習throw時研究的紀錄，有任何問題都歡迎指教～ 參考資料 MDN try…catch MDN 流程控制與例外處理","link":"/2022/06/14/javascript%20throw/"},{"title":"node.js 取得使用者輸入","text":"自己研究時的參考資源： -在 JavaScript 中獲取使用者輸入| D 棧Hans-Tsai/Node.js-Learn -Node.js 官網node.js 要取得使用者輸入會需要方法，我目前在使用的方式是用 readline 的方式，可以藉由它直接去做到使用者輸入 主要的幾種方式 readline =&gt; node.js 提供，可直接引用來幫助取得輸出輸入 prompt-sync =&gt; readline prompt-sync Text 非同步 同步 Text 不需要安裝 需要安裝 readline引用基於 callback and sync 的 API 1const readline = require('node:readline'); 引用基於 promise 的 API 1import * as readline from 'node:readline/promises'; CJS 範例版本 =&gt; commonJs 1234567891011const readline = require('node:readline');const { stdin: input, stdout: output } = require('node:process');const rl = readline.createInterface({ input, output });rl.question('What do you think of Node.js? ', (answer) =&gt; { // TODO: Log the answer in a database console.log(`Thank you for your valuable feedback: ${answer}`); rl.close();}); ESM 範例版本 =&gt; ES module 12345678910import * as readline from 'node:readline/promises';import { stdin as input, stdout as output } from 'node:process';const rl = readline.createInterface({ input, output });const answer = await rl.question('What do you think of Node.js? ');console.log(`Thank you for your valuable feedback: ${answer}`);rl.close(); prompt-sync首先，你需要使用 NPM 或 Yarn 安裝 prompt-sync 1npm install prompt-sync 1yarn add prompt-sync CJS 範例版本 =&gt; commonJs 12345const prompt = require(&quot;prompt-sync&quot;)();const name = prompt(&quot;你叫做什麼名字?&quot;);console.log(`您好 ${name}`);","link":"/2022/11/29/nodeJS%20readline/"},{"title":"建立sass環境(2022)","text":"此篇文章建立已經有 npm 的情況下。 如果是像我還有需要 node.js 的人，只要去安裝了 node.js，也會同時安裝 npm，至於如何安裝 node.js 可以去它的官網看=&gt;https://nodejs.org/en/ 。 回到這次主題。 環境分成兩種 全域的方式 本地端的方式 全域的方式代表只要裝了一次，整台電腦都會有 sass，而本地端則是範圍只限於一個專案之中，個人偏好使用本地端的方式，儘管可能每次都要裝一次，但會比較清楚使用了什麼。 全域安裝 sass 環境第一步打開終端機。 第二步直接打指令。 安裝的指令： npm install -g sass解除安裝的指令： npm uninstall -g sass 在這過程中可能會直接錯誤，畫面上會給出報醋，這是十分正常的，爬文後發現有一些權限問題，這時候只要最前面加上sudo，以及之後打上密碼就 ok 了。 例如：安裝的指令 =&gt; sudo npm install -g sass解除安裝的指令 =&gt; sudo npm uninstall -g sass 而要怎麼檢查安裝有沒有成功，或是有沒有成功卸載，可以透過查詢 sass 的版本來檢查，一樣在終端機的地方打上這段指令:sass --version。 要是你跟我一樣沒有在全域安裝的話就會出現這一段： 本地端安裝 sass 環境(自動編譯版)在創立一個專案後，進入到裡面開始以下步驟。 先 npm init -y他跟 npm init 幾乎一樣，只是它會幫你把預設選項全部跳過，產生一個空白的 package.json (懶人專用) 使用 nam install sass 加上 &quot;sass&quot;: &quot;sass --watch scss/style.scss:style/style.css&quot; 把 scss 的資料夾給創出來 成功編譯！之後之要寫npm run sass就可以一直幫忙自動編譯。","link":"/2022/11/27/sass%20build%20environment/"},{"title":"如何在vscode設定自己想要的使用者片段","text":"前端工程師在使用 vscode 這個編譯器進行切板剛開始時，通常開完一個叫做 index.html 的檔案後，就會開始在最初的頁面裡下一個驚嘆號。 這是預設的，所以完全不用做任何的設定，而當把這個驚嘆號給按下去之後，就會出現一套模板，包含了 html、head、body，這個模板節省了最初的撰寫時間，相信很多人沒有這個驚探號生成的模板可能剛開頭就不知道如何下手了。 而這個其實也能夠自己手動去做設定的，它是 vscode 其中的一個好用功能，叫做 User Snippets，也稱之為使用者自訂程式碼片段。 接下來就會教如何從零設定自己想要的使用者片段。 步驟一首先 vscode 頁面從最上面那一排找到一個叫做喜好設定的選項當中，會看到裡面有一個叫做==使用者程式碼片段==的區塊，點下去。 步驟二會出現一個視窗的選項在中央供選擇，這此請按新增==全域程式碼片段檔案==。 這個選項的意思是此檔案設定的使用者片段會讓你的所有檔案都可以使用，所以假如只由讓特定檔案使用而已的話，就不適合全域的方式，可以選擇只 for 一個專案去新增。 然後會跳出需要為這個程式碼片段取名字，假如不知道要取什麼的話可以跟我一樣先叫做 demo，當做測試的意思。 步驟三會進入到一個檔案當中，這個檔案就是用來設定你全域使用者片段的地方，裡面一開始就有一段註解的 code，這段 code 其實就是在說明要如何使用使用者片段，還附了一段簡單的範例。 在這邊先反註解它的範例 code，來做測試，把綠色字 Example:下面的都反註解。(mac 系列的使用者使用者反註解的方式就是 command + ?) 這邊解釋一下它範例裡面語法的個別意思。 scope指這個使用者片段可以使用的程式語言範圍，像是裡面 javascript 跟 typescript 就表示說，只有寫在兩種程式語言的檔案時才會生效，假如說在 html 的檔案中就不會生效。 prefix填寫時的關鍵字，就像是最前面說的那個驚嘆號，打出關鍵字就能成功引入自己設定的使用者片段。 單個關鍵字用字串直接寫就好，但如果需要多個關鍵字就需要用陣列包起來。 body使用者片段的內容本體，填寫在裡面的內容就會直接被當成使用者片段來輸出。 另外裡面假如只有單行的話，就可以包字串就好，但如果是多行的架構，就需要用一個陣列包起來。 description描述這個使用者判斷是幹嘛的，可寫可不寫，寫了的話會顯示在顯示在 IntelliSense 上，可以讓其他人更好理解這個使用者片段在幹嘛。 $ =&gt; 預設處理位置這個範例裡面可以發現到 body 之中有著神秘的$符號，它其實就代表著，把這個使用這片段引入之後，預設的輸入位置，假如有多個時候，可以透過 tab 來做切換。 步驟四來看看這個內建的 log 使用者片段的效果。 實際上情境運用我有一個想要用使用者片段的地方，就是我在一個新 vue 檔案時，都要重新寫 123&lt;script setup&gt;&lt;/script&gt;&lt;template&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 所以會希望用使用者片段去節省掉寫這些的時候，直接來做設定！ 直接照著格式謝一組自己需要的片段。 看使用效果：","link":"/2022/11/13/snippets/"},{"title":"搞懂 width &#x2F; max-width &#x2F; min-width 差異","text":"原文連結: https://appcs342.blogspot.com/2022/03/width-max-width-min-width.html移植時的最後更新日期: 2022-03-27T01:59:21.653-07:00 原本自己以為是很簡單的觀念，不過最近被問後發現其實並沒有很了解，像是我沒去思考過假如width跟max-width都設定數值，互相衝突後會發生什麼事情。所以我打算重新研究後，整理筆記出來。width(寬度）用來設定物件的寬網頁頁面一定會用到的屬性max-width(最大寬度值）用來給物件設定最大寬度值適用於尺寸限制時min-width(最小寬度值）用來給物件設定最小寬度值適用於尺寸限制時衝突時的狀況結論：會以更加明確的那個狀況為優先。舉例來說，假如給一個物件10單位的寬度（width)，又指定給這個物件最小寬度為20單位(min-width)，這時候就會產生衝突的狀況。最後的結果會是最小寬度更為優先，所以是20單位。在這狀況下，min-width會覆蓋width的值，我自己是理解成min-width意味著最少就是需要這樣的寬度值，所以假如width設定的寬度值少於min-width就會失去效果。小結寬度通常都會擇一使用，很少會遇到&nbsp;width / max-width / min-width 同時混再一起使用，因為這樣不只可讀性變得怪怪的，邏輯也會不太通。然後還有width因為比較基本，所以通常混用時，常常會被&nbsp;max-width / min-width 覆蓋效果，所以要讓width正常發揮它的作用，最簡單的方式就是只下width就好。參考資料https://ithelp.ithome.com.tw/articles/10252194https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width","link":"/2022/03/27/width%20%20max-width%20%20min-width/"},{"title":"volta 使用筆記","text":"會學習 volta 主要是在進行 node 版本切換的時候，原本會是使用 nvm 的方式，但是聽說現在有一個更好用的工作叫做 volta，所以開始對這個工具進行研究。 首先是 volta 的官網： https://volta.sh/ 進到這個官網以後，就可以看得到如何安裝的方式。 在這裡就打開終端機，然後下這串指令： 1curl https://get.volta.sh | bash 就會自動安裝成功了，在這裡我自己有遇到一些問題，就是安裝明明是成功的，但是當我下volta -v試圖去查詢版本號時，卻得到not found volta的結果，讓我以為沒有成功安裝，但後來發現只是因為使用 vscode 內建的終端機去下載安裝完還需要重載不然不會正確顯示，其實原本還是有安裝，這點要記得注意。 如何使用官網在這裡把 volta 的管理分成 Managing your toolchain Managing your project 在這裡的第一個會使用到的指令是volta install 剛開一個新專案時都是空的，還沒有任何資料，這時候切換 node 版本的方式就只能是用volta install，我的理解是它有點類似於最外層的概念，但單獨講這塊可能會難想像，所以先繼續往下。 假如在這個空的資料夾裡面再創兩個新的 project，像是有一個叫做”0221”的資料夾，裡面創了兩個 vue 的新專案(vue-project , vue-project2) 會發現裡面的 project 打開後，還會有package.json，而最外層沒有，而如何改動這個 vue 的新專案的 node 版本就會需要用到volta pin指令 在這邊實際實作一次： 先檢查外層”0221”的 node 版本狀況 然後進到”vue-project”裡，這邊使用volta pin指令來改變 node 版本 下volta pin node@15，會跳出訊息success: pinned node@15.14.0 (with npm@7.7.6) in package.json代表已經成功轉換了，這時候去看”vue-project”的package.json會發現已經被添加了 volta 相關版本訊息 這時候已經轉換成功了，所以去看 node 版本會發現已經變成 15 而這時候再使用volta install系列就改變不了”vue-project”的 node 版本，因為有package.json會優先看這裡的。 轉換到”vue-project2”的資料夾，會發現版本還是處在外層”0221”的 node 版本狀況，然後再用volta pin指令來改變 node 版本，成功後這三種地方的 node 版本就都會不一樣 重點理解整理一般來說volta install可以理解成是改變預設狀態下的 node 版本，而volta pin則是會把改變的 node 版本給紀錄在package.json，所以會有固定的效果，只要是在那個package.json範圍的都會吃到它當中的 node 版本。 在這邊就會產生一些優先權問題，這些都是正常的： 使用volta pin後，volta install會失效 沒有package.json就沒辦法使用volta pin 目前體感的好處是，假如協作的對象也有使用volta，那可以從他的專案的package.json去看 node 的版本，這點很方便，切換的速度也十分的快速，想切換就切換～！ 最後以上介紹的是普通狀況會常用的兩個指令，另外還有許多的指令這部分可以參考官網： 官網的地方：https://docs.volta.sh/reference/","link":"/2023/02/28/volta/"},{"title":"好想工作室的案主挑戰賽 參加心得","text":"參加這個練功的活動，完全在我的意料之外，因為案主挑戰賽開賽期間我正在參與一個案子，算是接案中，但後來在最後一刻還是參與了進來。 模擬案主所謂的案主會由工作室內資深的前輩進駐者擔任，會由他們之前所做的案子之中，萃取出直接之前專案中遇到的難題來當作挑戰賽主軸，包括題目的設定，驗收的 story，挑戰賽過程中也會不斷地跟參賽者有所互動。 規則大致上是這樣，會分成幾組來比賽，舉辦方會依造參加者目前的程度，來平均分隊，像是這次主要就分成三組，每組三個人，時程就只有一個禮拜，在這一個禮拜中要儘可能的把案主的需求做完，生出一個網站。 一切的起源就在那一個風和日麗的下午，工作室內有要參加這次案主挑戰賽的人全部聚集在了大會議室，人微微多讓我覺得有點緊張，主辦方首先請我們每一個參加的人寫下想跟誰同隊的小紙張，我隨便寫了一個便交了出去，隨後便是一陣主辦方的操作，經過一個我也不太了解的機制後，我的另外兩個隊友就出爐了，所有的分組組合就印在會議室內的大白板上，主辦方開始講一些該注意的事項。 這時我突然凝視著前方的白板，看了看我的隊友，除了我之外沒有人有寫程式的經驗，有一個還連切版都不太會切，我的汗慢慢從我的臉上滑了下來。 開始分配離開大會議室後，挑戰賽就算是正式開始，大家各組都開始討論了起來。 時間只有一個禮拜，理論上要很趕，現在就要馬上狂做，但我覺得越是這種時候，前面就要花越多時間在分配這件事情上面才對，一開始困難後反而後面會簡單，我是這麼想的，保持著慢慢來比較快的心態，我開始分析起來我們這組的未來。 我知道這個挑戰賽不是只是想考驗技術力而已，不然就全部都最厲害的人來做會最快，但這樣就沒有分組的必要，而且未來實際工作上也不可能都是一個人單打獨鬥，是要有團隊的！所以協作力才是這次挑戰賽的關鍵。 我開始去確定每個隊友的能力所在，然後去思考他們能做的工作，我的底線是團隊中大家都有要參與，都有要貢獻，最後先分配一個大方向。 我 =&gt; 專案中的 JS隊友 A =&gt; 專案中的切版隊友 B =&gt; 專案中的套件 我的部分主要是因為其他兩個隊友其實才剛碰前端沒多久，所以程式的部分我就一肩扛下了，至於隊友Ａ的狀況，我覺得他切版其實還 OK，所以專案中的切版就交給了他，最後隊友 B 的部分比較難，因為切版的部分也不 OK，後來想到專案有一些套件的部分，可以直接去網路上找別人做好的來用，最好的情況下只需要改改樣式，於是交付給他，就這樣初步的分配就完成了。 注定遇到的雷接案的分工合作中，有一些事情是躲不掉的，其中有一個就是 git 的版控管理這一塊，而為什麼這個部分很可怕呢？ 那是因為假如一個專案要協作的人越來越多，假如沒有先定好一個統一的規則，大家都照自己的想法去 commit 或是開分支，都任君開發的話，就最終就會變成一場災難，畢竟你的習慣不是我的習慣，大家習慣都不一樣，那要聽誰的。 所以在最初的時候，我們這組有引進 Git Flow 的流程開發，就是讓大家有一套規則可以去遵守，包括 commit 紀錄的格式寫法，以及分支應用情境，每個分支都有它功能意義存在，在合併分支時都需要透過一個非自己的人透過 PR 的方式再次檢查要合併的 code，做一個確認的動作，藉由這些方式，讓 git 版控管理這個注定遇到的雷發生問題的機率小一點。 還有一個是我覺得應該也是一定會碰到的雷，但是被我們巧妙地避免，就是重複及衝突的部分，這塊因為我們的分配分得很開，程式跟切版是完全獨立出來的，所以基本上不會有什麼會重複的問題，假如今天一個頁面是由兩個人負責切版，那就有可能會發生同一個區塊，但是兩個地方的樣式都不一樣的狀況，甚至一些衝突的部分要反覆修改，但我們這組在參加挑戰賽的時候這種情況不多，基本上就是隊友 A 一直瘋狂的切著版，我就寫功能，等他把版面切好後我再去串 API，亦或是我先把 API 串好，他再繼續切這樣，衝突會有但是基本上很少，而我也僅可能完全不去碰切版，就交給隊友Ａ。 挑戰賽期間評估專案需求後，我們最終是決定用 vue 的框架來完成這次挑戰的模擬案，之前有接過 vue 的專案，所以我有一些把握不至於最終會做不出來，把環境建好之後，大家都開始做自己分配好的任務，準備開始一個禮拜的挑戰賽。 過程中跟我想得差不多，一定會有很多我還不知道的地方，要先研究過後才能實作，所以這部分已經有心理預期，但一開始的時候有些過份樂觀，還以為可以一邊進行挑戰賽，一邊弄我原本的專案，事實證明我連把挑戰賽顧好都顯得有些吃力，還在過程中還遇到許多卡住的事情，例如：跳出的錯誤訊息看不懂，找資料半天也沒頭緒，做專案過程中還必須一直撥時間去處理別人的事情，解決別人的問題，對我來說都是很困難的挑戰。 這個挑戰賽總共有兩次的驗收，第一次是在兩天後，第二次是在剛好一個禮拜後，時間很短所以在第一次驗收的時候基本上還沒有完全做完，而且在第一次驗收時，由於我不會拒絕的原因，被擔任模擬業主的前輩們硬生生追加許多功能以及細節，所以兩天後的第一次驗收結束後，我大概就感覺到我後面這幾天不用睡覺了。 越接近尾聲，狀況就有如雨後春筍般不斷有湧出，我猜在這部分也可能是挑戰賽精心策劃的難題，像是驗收前幾天才把後台資料給齊，不停的設變(Design Alteration)，一些的臨時額外需求，這部分我覺得主辦方的模擬案主們扮演的非常的好，把真實可能反覆無常，愛刁難人的角色演繹得栩栩如生，我們組就盡可能的把這個鍋子(需求壓力)給蓋好，不要讓他滿爆出來，心中不停默念著一切都好。 最後驗收的前一天，得知了一些套件的需求可能隊友做不出來，所以可能要我生，再加上還有一些額外新被提出功能我還沒做完，但我想說其他大部分都做完了，所以這部分還好，但意外就是在這種時候會發生，這時的專案還沒成功部署上去，只在本地端測試，但卻在測試時發現手機載入時的速度慢得要命，明顯不正常，真的完蛋的那種，而且還是在前一天才發現，因為電腦上完全看不出來，所以開始瘋狂找原因，從下午找到晚上，從晚上找到回家，完全找不到原因，很奇怪的是就只有 ios 的手機跟平板會卡頓，安卓不會，電腦也都不會，為了解決這個問題，花了我一整天，所以原本要趕出來的功能通通都沒時間做，因為要是這個問題沒解決，等於直接宣判了我們這組的死刑，我平常是搭公車通勤的，那天也是待在末班車的時間不得不回家。 最終驗收就在明天，心生絕望後決定先部署，總不能連個網頁樣子都弄不出來，但部署上去後就突然恢復正常了，有點命運捉弄人的感覺，但好在是解決了，後來的故事就是我在正式驗收之前，把其餘的功能都趕一趕出來，在隔天正常驗收前生出了我自認有八成像的網站等待驗收，雖然過程有些坡折，但最後還是有成功把東西做出來～ 參賽後記完賽後第一個感覺是時間過得真快，一個禮拜的時間刷一下就消失了，過程除了在弄模擬專案外，主辦方也會關心我們每一組的進度以及講解一些重點幫助大家進入狀況，所以也有學到很多在正式接案中跟業主對談的眉眉角角，像是： PM 金三角 如何確認需求，Story 可開工條件 demo 展示給業主看的要點 最小可行性 MVP 完賽後有些人陸陸續續誇獎我讓我覺得自己很棒，所以整體來說我蠻喜歡這次參加的體驗，藉由這次我也更深刻的明白自己確實還有許多不足的地方，不會的東西還有很多，我想這次挑戰賽結束之後，感覺到的不是單純的可以放鬆了，而是要再去開拓自己還不足的學習道路，畢竟有補充了許多方向可以參考，期許不久後在面對壓力時可以更游刃有餘！","link":"/2022/11/28/web%20client%20challenge/"}],"tags":[{"name":"css","slug":"css","link":"/tags/css/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"grid","slug":"grid","link":"/tags/grid/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"sass","slug":"sass","link":"/tags/sass/"}],"categories":[{"name":"舊部落格移植文章","slug":"舊部落格移植文章","link":"/categories/%E8%88%8A%E9%83%A8%E8%90%BD%E6%A0%BC%E7%A7%BB%E6%A4%8D%E6%96%87%E7%AB%A0/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"2022 iThome 鐵人賽","slug":"2022-iThome-鐵人賽","link":"/categories/2022-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"還沒分類的","slug":"還沒分類的","link":"/categories/%E9%82%84%E6%B2%92%E5%88%86%E9%A1%9E%E7%9A%84/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"html","slug":"html","link":"/categories/html/"},{"name":"sass","slug":"sass","link":"/categories/sass/"},{"name":"活動心得","slug":"活動心得","link":"/categories/%E6%B4%BB%E5%8B%95%E5%BF%83%E5%BE%97/"}]}