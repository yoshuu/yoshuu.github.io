<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>初探Git Hooks，優化Git工作流</title>
      <link href="/2023/05/04/git%20hooks/"/>
      <url>/2023/05/04/git%20hooks/</url>
      
        <content type="html"><![CDATA[<p>git是現在主流的版控控制，寫軟體的人基本上都知道，但關於如何優化工作流以及什麼是git hooks知道的人可能就不多，因為這個部分是一種「優化」，使用了會更好，但是不用也沒關係，那我研究後覺得git hooks學會之後好處很多，那下面會儘量用好懂的方式來記錄跟介紹。</p><p>不講腳本寫法，不講複雜應用，只講整體的概念以及簡單的小應用來幫助理解概念。<br>但還是要有對於git的簡單知識，不然可能看不懂這篇。</p><p>這篇文章主要會有以下這三個大重點：</p><ul><li>什麼是git hooks</li><li>為什麼要使用git hooks</li><li>git hook基本的應用有哪些</li></ul><h2 id="什麼是git-hooks"><a href="#什麼是git-hooks" class="headerlink" title="什麼是git hooks"></a>什麼是git hooks</h2><p>用一句話來講解這個概念，就是「每次使用了git的資料庫中發生特別事件時(像生命週期)自動運行的腳本」。</p><p>生命週期就是像人的一生中，有嬰兒、壯年，生、老、病、死，那git的特別事件我覺得也像是生命週期一樣，就是git的一些重要環節上代表各個git的生命週期，這個稍微就會解釋。</p><p>腳本就是一種程式的文件，我會把它想像是可以做某一種事情的程式，像是玩遊戲的時候，假如覺得一直在做一些重複性的事情很煩，那就可以寫一個滑鼠自動一直點的腳本。</p><p>而使用了git的資料庫的話，就是一個乾淨的專案裡面，只要下一個指令<code>git init</code>，那這個專案就會被加入到git的版控中，然後專案目錄下也會多出一個.git的隱藏檔。</p><p>好，然後下一個問題我想就是那該如何去之後這個腳本會怎麼運行？ 我得去哪裡控制它？</p><p>首先，會在它git專屬的隱藏檔裡面，在<code>.git/hooks</code>的位置，可以在裡面去放入腳本來去進行控制的動作，但要注意，一般來說是觀測不到的，因為git的.git隱藏檔是預設看不到，所以要使用git hooks的技術，第一步得先找到git hooks檔案所需要放置的位置。</p><p>以下是打開git隱藏檔，找出git hooks的方式，我是用vscode，所以只講它的情境：</p><p><img src="https://hackmd.io/_uploads/HkRnYDUVn.png"><br>一開始打開vscode，</p><p>&#x3D;&gt; 設定 (右下角齒輪裡面，蠻明顯的，按下去再使用者那邊找)</p><p>&#x3D;&gt; 找Files: Exclude</p><p>&#x3D;&gt; 如上圖，刪除裡面.git選項</p><p>這樣一來，你就會發現隱藏檔露出了它的廬山真面目，但注意的是，因為這種改動從設定(使用者)的話是影響整個專案，而之所以git隱藏檔要隱藏起來，是因為不小心亂改到是很危險的，所以如果用這種方式改的話，那之後所有的專案都可以看到的。</p><p>這邊也提供另外一個技巧，如果你今天只想for自己的這個專案可以看到的git隱藏檔，可以這樣做。</p><p>一樣進到設定，但不是使用者，而是它右邊的工作區，點擊進去工作區之中的<code>settings.json</code>，加上這一段程式碼就ok了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;files.exclude&quot;:&#123;</span><br><span class="line">    &quot;**/.git&quot;: false,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>當成功的把git的隱藏檔顯露出來後，就可以觀測到git hooks的所在。</p><p><img src="https://hackmd.io/_uploads/rkxunw8Nh.png"></p><p>一個名字叫做hooks的資料夾，裡面擺了很多的git生命週期事件的檔案，等等會把這個檔案跟git的真正對應指令做個比較圖，先講這邊要如何去修改跟撰寫。</p><p>其實很簡單，就是把這個檔案的<code>sample</code>給刪除，直接去更改裡面就會生效了，我的理解是<code>sample</code>是要讓它預設為沒作用，那拿掉就變成有作用。</p><p><img src="https://hackmd.io/_uploads/ryn6aDIVn.png"></p><p>另外裡面打開會長這個，除了最上面的<code>#!/bin/sh</code>之外其他都刪除也沒關係，我都會先把預設的都刪掉然後再自己寫新的，還有就是裡面寫的腳本可以用任何的程式語言去寫，像是node.js也是完全沒問題。</p><p>接下來這邊最後就來講裡面的各種檔案對應的git指令吧：<br><img src="https://hackmd.io/_uploads/ryG3AD8N3.png"></p><p>有很多，但我只列舉git的最常用的那幾個，像是耳熟能詳的<code>git add</code>、<code>git commit</code>這種，而我們想要利用git hooks做的事情，其實就是當我們在使用這些git指令的時候，可以在那個時期做事情而已，也就是執行腳本。</p><p>會發現hit hooks裡面的特定檔案事件會把git指令分成執行前以及執行後，初看會覺得似乎沒有必要，但這卻是必須的。</p><p>我來舉例一個情境，假如你使用腳本，是為了在<code>git commit</code>之前去做檢查，要是commit訊息中，沒有某些字，你要用git hooks腳本的方式，阻止coomit訊息的發送，那麼同樣的腳本，執行前跟執行後就分成兩種不同的情境。</p><p><code>git commit</code>執行之前的話，那代表還沒有成功commit，所以腳本檢查完去阻止，是可以成功擋下的，<br>但是在<code>git commit</code>執行之後的話，它git生命週期的點已經是commit結束之後了，就算可以檢查得出錯誤，但也沒辦法阻止發生，這是它一個很大的差別。</p><p>所以說，執行前有它的情境，執行後也有它的用處，這是兩種不同的卻又都有需求，兩個都要有很合理。</p><h2 id="為什麼要使用git-hooks"><a href="#為什麼要使用git-hooks" class="headerlink" title="為什麼要使用git hooks"></a>為什麼要使用git hooks</h2><p>關於這個部分，我有整理出了幾點：</p><ol><li>自動化流程</li><li>強制規範</li><li>安全性</li></ol><p>第一，自動化流程的意思是使用Git hooks可以自動化許多重複性、瑣碎的工作。</p><p>沒有也可以，但你就是要手動一直做很多重複事情，軟體開發時總是會遇到這種事情，像是運行單元測試、檢查代碼風格、自動化部署等等，會發現這些事情可能超級耗時間，而且因為是手動去執行的，所以會發生一些像是忘記執行，或是少執行了一些步驟，然後導致整個在使用版控的流程發生錯誤。</p><p>git hooks只要把這個自動化的流程流程寫成腳本，放進去git的生命週期，像是每次push之後都要做一個自動化部署，直接幫你省一大堆時間，開發效率直線上升。</p><p>接著是強制規範的部分，Git hooks可以強制做一些規範，像是說查程式碼風格、檢查文件格式、防止不必要的合併等等，甚至連git commit訊息都可以去規定它要怎麼寫，用了就回不去了，實在是太方便。</p><p>這樣做可以確保假如有在協作的話，大家全部人的風格都符合同一個標準，有一致性的同時也拉高了可讀性，讓寫code變成更愉快的同時，程式碼也是變的用容易維護以及修改。</p><p>最後是安全性，Git hooks可以幫助保持資料庫的安全性，例如說防止提交敏感資訊、防止執行有害的程式碼等等。</p><p>像是如果有不能被傳上去的禁止字樣，或是可怕的程式碼寫法，直接上傳上去是會造成困擾的，這個部分跟強制規範規範其實有點類似，主要就是在提交程式碼之前，再次做個檢查，看看這些程式中有沒有包含危險不安全的東西存在，有的話就馬上警告，確保整個專案都是安全的狀態。</p><p>總之，做個小結論，使用Git hook可以幫助自動化流程、強制規範和提高安全性，從而提高開發效率、確保品質和減少風險，不用可以，用了會更好，這是我覺得它的優點。</p><h2 id="git-hook基本的應用有哪些"><a href="#git-hook基本的應用有哪些" class="headerlink" title="git hook基本的應用有哪些"></a>git hook基本的應用有哪些</h2><p><img src="https://hackmd.io/_uploads/ry_nrdINh.png"></p><p>這邊最基礎的話，從<code>pre-commit</code>開始寫起git hooks，也就是所謂的<code>git commit</code>執行之前的腳本，跟前面說的一樣，除了最上面那行之外，其他全部刪掉，自己寫。</p><p>我這邊寫的意思是，當coomit的指令下出去，指令之後，執行之前會去跑這個腳本觸發，功能是會呼叫一次我的名字，”hello vic”這樣。</p><p>有用到了兩個我覺得要知道的語法，介紹一下什麼是<code>Echo</code>及<code>exit</code>。</p><p><code>Echo</code>命令用來將後方參數輸出到console，就是把寫的東西印出來。<br><code>exit</code>命令如果是0的話會讓commit繼續，若exit後為非0，例如exit 1則會終止commit。</p><p><img src="https://hackmd.io/_uploads/B14dDuL4n.png"></p><p>然後是稍微讓大家了解概念的應用，也就是執行腳本這件事情，專案當中，可能就已經使用了很多<code>lint</code>系列的套件，這些套件就是專門用來負責處理程式的格式、風格，所以其實可以把它們直接加上git hooks就好了。</p><p>舉例來說，假如專案中有在使用<code>eslint</code>，通常Node.js專案會在package.json的scripts欄位下設定lint腳本，來呼叫lint工具去檢查JavaScript等程式碼的語法。</p><p>那我可以把它搭配做使用，在git hooks當中的pre-commit腳本中去執行npm run lint。</p><p>這樣就會達成效果是commit指令下去之後，會在commit執行之前，幫我得程式碼做一個檢查的動作，這也是我目前比較常用的做法，然後commit的話也有專門的commitlint可以做使用，所以其實不用真的會寫git hooks的腳本也沒關係。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>以上大致就是我在研究git hooks之後，想分享及做的筆記心得，下次可能會想研究git hooks的工具搭配，因為其實要打開隱藏檔這件事情真的是比較麻煩的，而且由於.git隱藏檔不吃版控的關係，我找了一些奇怪的方式才能追蹤到推遠端，覺得應該可以用更好的方式。</p><p>有一個叫做<code>Husky</code>的工具，據說使用它可以讓git hooks這件事情變得更加簡單，下一個研究的目標就會是它，研究完我會再把我的心得研究丟blog。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><h3 id="影片類"><a href="#影片類" class="headerlink" title="影片類"></a>影片類</h3><p><a href="https://www.youtube.com/watch?v=zKR3I9t9KF0&ab_channel=%E7%B0%A1%E7%9D%BF%E5%AD%B8%E5%A0%82">(2) [Git#8] 用pre-commit檢查提交時的分支是否正確 - YouTube</a><br><a href="https://www.youtube.com/watch?v=ZQFvw3Rfhpg&t=251s&ab_channel=PJCHENder">透過工具建立有規範的 git commit message 吧 - YouTube</a></p><h3 id="文章類"><a href="#文章類" class="headerlink" title="文章類"></a>文章類</h3><p><a href="https://git-scm.com/book/zh-tw/v2/Customizing-Git-Git-Hooks">Git - Git 鉤子</a><br><a href="https://matthung0807.blogspot.com/2021/08/what-is-git-hooks.html">菜鳥工程師 肉豬: Git 什麼是Git Hooks？</a><br><a href="https://github.com/aitemr/awesome-git-hooks">aitemr&#x2F;awesome-git-hooks: 😎 A collection of awesome Git Hooks</a><br><a href="https://www.freecodecamp.org/chinese/news/git-hooks-script/">手写 git hooks 脚本（pre-commit、commit-msg）</a><br><a href="https://hackmd.io/@s716134/githook01#fn1">探索藏在Git當中的Git Hook - HackMD</a><br><a href="https://magiclen.org/git-hooks/">如何在執行git commit前自動進行檢查？Git Hooks的基本用法 | MagicLen</a></p>]]></content>
      
      
      <categories>
          
          <category> 軟體與操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端資料本地儲存的方式</title>
      <link href="/2023/04/27/Cookies%20vs.%20Local%20storage%20vs.%20Session%20Storage/"/>
      <url>/2023/04/27/Cookies%20vs.%20Local%20storage%20vs.%20Session%20Storage/</url>
      
        <content type="html"><![CDATA[<p>瀏覽器本身是可以儲存資料的，方法不只一種，目前我知道有以下這些方法：</p><ol><li>Cookies</li><li>localStorage, sessionStorage</li><li>indexedDB</li></ol><p>其中<code>indexedDB</code>沒有去詳細理解內部實作細節，因為使用到的情境似乎很少見，我自己從來沒用到過，可能需要有龐大暫存的需求情境才有機會碰到，這個部分我只紀錄幾篇有關的技術文章：</p><ul><li><a href="https://zh.javascript.info/indexeddb">IndexedDB</a></li><li><a href="https://www.yasssssblog.com/2020/08/19/web-indexeddb/">前端如何緩存大筆資料：IndexedDB 介紹&#x2F;應用 | Yass Tsai</a></li><li><a href="https://lilyliu.coderbridge.io/2021/08/04/indexedDB/">【瀏覽器資料存取】IndexedDB</a></li></ul><h2 id="暫存機制的存在意義"><a href="#暫存機制的存在意義" class="headerlink" title="暫存機制的存在意義"></a>暫存機制的存在意義</h2><p>為什麼不把資料都存在伺服器端就好，資料為什麼得放在瀏覽器本身的儲存區？</p><p>其實是有它的必要性，會有情境是把東西放在瀏覽器中比較好的狀況，而且放在瀏覽器的本地也有許多的好處。</p><p>首先，第一個比較直觀的好處是假如可以直接把資料就存在本地端，那就代表可以減少瀏覽器跟伺服器之間的數據運輸量，這樣可以減少從伺服器載入資源的速度，換句話說，這樣可以提升網站的載入速度，減少網站的等待時間。</p><p>然後存在本地端的話，也可以拿來做記錄用戶的行為，比如說登入了一個網站，要是沒有登出的話，下一次再進到這個頁面中發現還是登入的狀況，這其實也是瀏覽器暫存機制幫的忙，藉由在本地端儲存的資料，可以判斷有沒有登入過，已經登入者是誰，這樣就不會需要每次要登入時，都一定得重新打一次帳號密碼，這部分很好的幫助優化了用戶體驗。</p><p>總得來說，雖然沒有暫存機制，網頁也是可以運作下去，它不算是缺少就弄不出網頁，但是由於使用了它可以提升網站性能，用戶體驗，甚至是開發者的開發效率，所以已經變成了現代網站開發中不可或缺的一部分。</p><h2 id="Cookies-vs-Local-storage-vs-Session-Storage"><a href="#Cookies-vs-Local-storage-vs-Session-Storage" class="headerlink" title="Cookies vs. Local storage vs. Session Storage"></a>Cookies vs. Local storage vs. Session Storage</h2><p>接下來，這是這三種方式來做一個比較，開頭前先說，每一種方式雖然有舊新之分，但卻沒有好壞之別，每種都有自己適合使用的情境，那這邊我有做一個表，先從這個表來看看：</p><p><img src="https://i.imgur.com/1NxTQiB.png"></p><p>這三種方法相同的地方在於說都會存在到同一個正在使用的瀏覽器之中，若是在<code>chrome</code>中使用儲存那資料就會儲存在<code>chrome</code>中，如果在<code>Safari</code>中就會存在於<code>Safari</code>，以此類推，所以是沒辦法做到跨瀏覽器儲存的，可以當作暫存機制是獨立在瀏覽器中的，不會跟其他使用者衝突，或是說可以互相讀取，這點要特別注意。</p><p>那就開始從第一點來看吧！</p><h3 id="儲存大小"><a href="#儲存大小" class="headerlink" title="儲存大小"></a>儲存大小</h3><p>會發現說，<code>cookies</code>特別的小，才 4kb，然後<code>Local storage</code>有 10mb 最多，<code>Session Storage</code>也有 5mb 的儲存大小，這傳遞出了一個訊息，就是假如你想要在本地端暫存很多資料，肯定首選不是<code>cookies</code>，而為什麼<code>cookies</code>會特別的小，也是有它的原因存在的，後續會談到。</p><h3 id="瀏覽器"><a href="#瀏覽器" class="headerlink" title="瀏覽器"></a>瀏覽器</h3><p><code>cookies</code>作為較為舊的瀏覽器儲存方式，它可以支援 HTTP4 的舊瀏覽器，至於<code>Local storage</code>以及<code>Session Storage</code>比較新就只能支援 HTTP5 的瀏覽器，好消息是現在網站應該已經全部都是 HTTP5 了，所以這塊基本上不會有什麼影響。</p><h3 id="到期問題"><a href="#到期問題" class="headerlink" title="到期問題"></a>到期問題</h3><p>資料儲存之後可以儲存多久，這三種方法都不太一樣，<code>Local storage</code>的話就是會永久保存資料，除非主動把它刪除掉，不然它就會永遠存在那邊。</p><p>而<code>Session Storage</code>會看當下的這個頁面，它的到期時間跟頁面息息相關，要是關掉當前頁面，那<code>Session Storage</code>裡面資料就會過期，這是它跟<code>Local storage</code>最主要的差別。</p><p>最後是<code>cookies</code>他很特別，可以手動去設定<code>cookies</code>的確切到期時間，所以可以完全掌握<code>cookies</code>內的資料可以存在多久。</p><h3 id="伺服器儲存端跟儲存位置"><a href="#伺服器儲存端跟儲存位置" class="headerlink" title="伺服器儲存端跟儲存位置"></a>伺服器儲存端跟儲存位置</h3><p>會把這兩個放在一起講，因為我覺得這兩項的性質差不多。</p><p><code>cookies</code>可以儲存的地方不僅局限於瀏覽器，伺服器端也可以做存取，在這三種的方法中只有它可以做的到，我個人覺得這也就是為什麼<code>cookies</code>可以儲存的大小這些少的原因，因為假如它像是<code>Local storage</code>及<code>Session Storage</code>一樣可以存取那麼多東西的話，那在儲存送到伺服器端就會比較困難，然而我們還是會需要存在於本地端，但是也可以送到伺服器端的功能，像是之前講的紀錄用戶狀態，就會使用<code>cookies</code>來儲存用戶的登入狀態。</p><p><code>Local storage</code>及<code>Session Storage</code>的資料只能局限於本地端，只能存在於瀏覽器，各有好壞只是看要使用的情境是什麼，就會選擇使用哪一種的方式。</p><h2 id="使用的語法"><a href="#使用的語法" class="headerlink" title="使用的語法"></a>使用的語法</h2><p>那在<code>javascript</code>要怎麽樣去使用這三個方法，就得先去了解它們各自的語法，在這邊我學習的時候是去參考這三個部分的 MDN，位置分別如下：</p><ul><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Window/localStorage">Window.localStorage - Web APIs | MDN</a></li><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Window/sessionStorage">Window.sessionStorage - Web APIs | MDN</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies">使用 HTTP cookies - HTTP | MDN</a></li></ul><p>在這邊我覺得可以拆成兩個部分來看，一個部分是<code>Local storage</code>及<code>Session Storage</code>，因為它兩個部分幾乎語法一模一樣，另一個是<code>cookies</code>。</p><p>在開始講語法之前，先來介紹一下要怎麼樣在瀏覽器上觀測到本地儲存的位置在哪裡。</p><ol><li>先打開 Chrome 瀏覽器的 DevTools</li><li>打開後最上方去尋找 Application</li><li>進到裡面後，最左邊那一排可以看到 storage 的區域<br><img src="https://i.imgur.com/XdSyxwE.png"></li></ol><p>之後都可以從這邊去看本地端儲存的資料有哪一些。</p><h3 id="儲存資料"><a href="#儲存資料" class="headerlink" title="儲存資料"></a>儲存資料</h3><p><code>Local storage</code>及<code>Session Storage</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// localStorage</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Vic&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sessionStorage</span></span><br><span class="line">sessionStorage.<span class="title function_">setItem</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Vic&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 這兩種儲存的時後都一樣要有一組key/value才能成功儲存。</span></span><br></pre></td></tr></table></figure><p><code>cookies</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;name=Vic&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也是一樣要寫key/value但是要寫在字串裡面。</span></span><br></pre></td></tr></table></figure><h3 id="獲取儲存資料"><a href="#獲取儲存資料" class="headerlink" title="獲取儲存資料"></a>獲取儲存資料</h3><p><code>Local storage</code>及<code>Session Storage</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// localStorage</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// vic</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sessionStorage</span></span><br><span class="line">sessionStorage.<span class="title function_">setItem</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sessionStorage.<span class="title function_">setItem</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// vic</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有set那麼拿的時候就是get，這邊要注意只輸入key就好</span></span><br></pre></td></tr></table></figure><p><code>cookies</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>); <span class="comment">// name=Vic;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 似乎只能直接印出所有，看所有的。</span></span><br></pre></td></tr></table></figure><h3 id="刪除資料"><a href="#刪除資料" class="headerlink" title="刪除資料"></a>刪除資料</h3><p><code>Local storage</code>及<code>Session Storage</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// localStorage</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&quot;name&quot;</span>); <span class="comment">// 刪除單個</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">clear</span>(); <span class="comment">// 刪除所有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sessionStorage</span></span><br><span class="line">sessionStorage.<span class="title function_">removeItem</span>(<span class="string">&quot;name&quot;</span>); <span class="comment">// 刪除單個</span></span><br><span class="line"></span><br><span class="line">sessionStorage.<span class="title function_">clear</span>(); <span class="comment">// 刪除所有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 這個部分蠻直覺的，要記得刪除也是抓key就好，手動刪除的部分</span></span><br></pre></td></tr></table></figure><p><code>cookies</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;name=; expires=Thu, 01 Jan 1900 00:00:00 GMT&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cookie就是很特別的那種，要刪除的話就得再次設置，比如說給它一個過去的到期日期，那現在就一定到期，等於它就被刪除了。</span></span><br></pre></td></tr></table></figure><h2 id="做個總結"><a href="#做個總結" class="headerlink" title="做個總結"></a>做個總結</h2><p>會發現到說這三種方式其實都大同小異，不過其實還是有差別存在的，所以在使用前還是得對它們稍微去做個了解，最主要是除非有需要有特別存取到伺服器上的情境，不然正常狀況下要用到瀏覽器暫存功能會使用<code>Local storage</code>及<code>Session Storage</code>就好，會比<code>cookies</code>容易使用，不然光是語法我覺得<code>cookies</code>確實偏難理解，另外兩種倒是蠻直覺的。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><h3 id="文章類"><a href="#文章類" class="headerlink" title="文章類"></a>文章類</h3><p><a href="https://zh.javascript.info/cookie">Cookie，document.cookie</a><br><a href="https://zh.javascript.info/localstorage">LocalStorage，sessionStorage</a><br><a href="https://5xruby.tw/posts/localstorage">認識瀏覽器的神秘儲存空間 - localStorage | 五倍紅寶石・專業程式教育</a></p><h3 id="影片類"><a href="#影片類" class="headerlink" title="影片類"></a>影片類</h3><p><a href="https://www.youtube.com/watch?v=GihQAC1I39Q">JavaScript Cookies vs Local Storage vs Session Storage - YouTube</a><br><a href="https://www.youtube.com/watch?v=fYTTUBa-lPc">Local Storage Explained In 10 min | Javascript - YouTube</a><br><a href="https://www.youtube.com/watch?v=KfOBmxPILKs&t=430s">認識 JavaScript 的 WebStorage - YouTube</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端相關 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>程式語言的性格解密：靜態 vs. 動態、強 vs. 弱、靜態 vs. 動態作用域</title>
      <link href="/2023/04/20/the%20character%20of%20the%20program/"/>
      <url>/2023/04/20/the%20character%20of%20the%20program/</url>
      
        <content type="html"><![CDATA[<p>這篇主要是紀錄我是怎麼理解這些名詞的。</p><p>因為關於程式語言的部分，我目前只有寫過 JavaScript，所以對於其他程式語言比較沒辦法體悟，這篇會從我使用 JavaScript 的角度來去理解！</p><p>在都還沒研究時，我其實就已經知道 JavaScript 分別是哪幾種，但還不明白差異：</p><p>JavaScript &#x3D;&gt;</p><ol><li>動態語言</li><li>弱型別</li><li>靜態作用域</li></ol><h2 id="動態語言、靜態語言"><a href="#動態語言、靜態語言" class="headerlink" title="動態語言、靜態語言"></a>動態語言、靜態語言</h2><p>用一句話來解釋就是在執行的時候可以改變結構的是動態語言，如果不能的話那就是靜態語言了。</p><p>這塊需要釐清以及容易卡住的地方我覺得是「執行」和「編譯」的名詞。</p><p>假如今天是在 vscode 寫 code，使用的程式語言是動態語言，像是 JavaScript，執行的話我會理解成，我印出了一個值，比如說 console.log(x)，那要看到這個 x 是多少的話，就得對它做「執行」的動作，我才能知道我到底印出了多少，不管是在瀏覽器上，還是在 node.js 上，而我在寫 console.log(x)的時候，就是同時在做「編譯」這件事情，我在 vscode 寫程式碼的過程就是編譯時的過程。</p><p>理解了這塊之後，再來回頭看動態語言跟靜態語言的差異。</p><p>執行的時候可以改變結構，也就是代表在編譯時都不會去管，用類別檢查來做個舉例：</p><p>寫 JavaScript 時，其實執行時才會進行類別檢查，編譯時怎麼寫都不會管。</p><p><img src="https://i.imgur.com/EjbBCMT.png"></p><p>x 值的類別是什麼呢？</p><p>在第一個賦值於 5 的時候，印出來的值會是 number 的型別，如果後來再去賦予一段字串，那它印出來的型別就會變成是 string。</p><p>也就是說，假如要印出一個變數，得在執行的時候才會決定，編譯時什麼都不知道，這就是<code>動態語言的奇妙之處</code>，所以在寫 JavaScript 的時候，可以隨心所欲的去改變自己的變數，因為動態語言的特性下其實可以看成變數是任何的類型，不會產生編譯錯誤，在 vscode 執行程式前，不會發生報錯的狀況。</p><p>而靜態語言在這塊就會嚴謹很多，一樣用型別的檢查這件事情來做舉例。</p><p>靜態的特性就是會在編譯時進行對變數或是函式進行類別的檢查，必須要在執行前，就知道每一個變數是什麼類別了，而不是在執行的時候才知道，所以使用前就得要先宣告，要是像上面一樣，在執行前沒有給變數一個明確是什麼型別的話，就會在編譯時報錯。</p><p>聽起來很麻煩，但這樣其實是好處多多的，因為我在寫 JavaScript 時，動態的特性讓我想寫什麼都不會編譯時出錯，但也因為如此，很多的錯誤都是要等到執行後才會發現，有時候在想如果今天 JavaScript 是一個靜態語言，那其實很多常見的錯誤就可以提前發現，所以這點上有好有壞，靜態特性可以提升可靠性，而動態特性可以獲得靈活性跟高彈性。</p><p>回到最開頭講的話，執行的時候可以改變結構的是動態語言，如果不能的話那就是靜態語言，其實也就是檢查的嚴格程度，動態的話，就是動來動去，結構定下來是在執行的時候，也就代表執行前都沒還確定下來，靜態則是不可以亂改變的人，所以執行前也就是編譯時，就會先做檢查，檢查不過就先送你報錯，看似殘忍的提早送你報錯，也比你真正在執行後報錯好，這是我想靜態語言這樣設定的心態吧。</p><h2 id="強型別、弱型別"><a href="#強型別、弱型別" class="headerlink" title="強型別、弱型別"></a>強型別、弱型別</h2><p>顧名思義這個跟「型別」有很大的關係，用一句話來形容的話，就是程式語言容忍隱性型別轉換的程度。</p><p>理解的話要先從什麼是隱性以及顯性開始說起。</p><p>隱性就是看出不來，顯性就是非常明顯的，轉型別的說的話，一個就是你偷偷的從數字變成了字串，怎麼轉換不是寫程式的人決定的，是程式本身自己覺得，自己變換過去，但顯性的話就不會發生這種事情，發生了什麼變化一定是寫程式的人自己做得決定，要從數字變成字串就得自己去轉換。</p><p>可以想像成隱性的話會有一個小幫手，為了幫助你，在他覺得應該要轉換的時候，助你一臂之力，幫你做事情，而顯性的話就沒有小幫手，都得靠自己。</p><p>而強型別來看的話，就是不允許隱性的行為，沒有小幫手，也就是得在編譯得時候就強制要求變數跟型別類型要匹配，你得一切都自己決定好，要是決定的不夠清楚的地方，就直接送你編譯報錯，而弱型別就有點像是上面提到的動態語言一樣很寬鬆，就像是有個小幫手會默默幫你，當你遇到沒有很清楚什麼型別是什麼型別的時候，小幫手會幫你自動轉換，都幫你做好決定了，編譯時這塊的匹配機制就相對十分寬鬆。</p><p>另外這塊我還有用一個整理雜物的例子來理解：</p><p><img src="https://i.imgur.com/IeB8tsF.jpg"></p><p>用兩種的箱子來分類雜物，一種是裡面已經分類好的箱子，箱子不能亂放，假如是分類為「衣服」的箱子，那裡面只能放衣服而已，分類為「書籍」的箱子裡面只能放書而已，被分類的明明白白，而另一種是通用的箱子，這箱子彈性很大的，想放衣服也可以，想放書本也可以，當它放入的衣服的時候，就變成放衣服的箱子，但也可以把衣服拿出來，放入書本，那它這時候就變成了放書的箱子。</p><p>而這種裡面已經分類好的箱子呢其實就很像是前面所提到的強型別，當我看到這種箱子的時候，我就知道裡面只有這個類型的物品，這樣代表我得花比較多的時間跟精力去確保每一個雜物都放在適當得箱子中。</p><p>弱型別就像是通用的箱子，它可以把任何雜物放入通用的箱子中，而不用去進行分類，這種方式在整理雜物的時候容易很多，但是若我需要使用特定的某個雜務時，就必須非常輕楚它們被放在哪個箱子中，不然很容易就會找不到它們。</p><p><img src="https://i.imgur.com/D30Le5Z.jpg"></p><p>JavaScript 就是弱型別語言的一個代表，也是我現在主要在寫的，上圖 JavaScript 的部分可以看到說，今天 x 是字串，而 y 是數字，那麼把兩個相加會怎麼樣呢？ 最後結果是字串還是數字呢？</p><p><img src="https://i.imgur.com/dXgZzDd.png"></p><p>答案是 string，弱型別的話，在這種狀況下會有小幫手來幫你偷偷轉，不會編譯報錯，會自動變成 string 或是 number 的其中一個，會自動幫忙合理化，所以說其實弱型別的語言我覺得學起來的門檻會比較低，而且寫起來會比較輕鬆，但同時也比較難去建立一個良好的程式概念，這個部分有好有壞，對我來說 JavaScript 弱型別的特性幫我簡化了很多事情，但我得去知道它幫我偷偷簡單化了什麼步驟，而不是都讓它幫我去做不去理解，相互比較之下我相信也可以擁有好的程式觀念。</p><h2 id="靜態作用域、動態作用域"><a href="#靜態作用域、動態作用域" class="headerlink" title="靜態作用域、動態作用域"></a>靜態作用域、動態作用域</h2><p>這邊用兩句話來解釋：</p><p>靜態作用域指的是變數跟函式在宣告的時候就已經確定下來自己的作用域，<br>而動態作用域的作用域會隨著程式碼的呼叫而變化。</p><p>首先，維基百科上告訴我大多數現在程式設計語言都是採用靜態作用域規則，連結：<br><a href="https://zh.wikipedia.org/zh-tw/%E4%BD%9C%E7%94%A8%E5%9F%9F">https://zh.wikipedia.org/zh-tw/%E4%BD%9C%E7%94%A8%E5%9F%9F</a></p><p>那麼看起來靜態作用域肯定有它的好處存在，不過其實我還沒有參透什麼情境下要使用動態作用域什麼時候要使用靜態作用域，目前已經變成靜態作用域腦了。</p><p>話題拉回來，很多人覺得很難理解，我個人覺得其實還蠻好懂的，靜態作用域所謂在宣告的時候就已經確定自己的作用域這件事情，其實也可以濃縮成兩句話，就是我自己在學 JavaScript 的 scope 時理解的兩句話：</p><p>JavaScript 的作用域跟你如何呼叫完全無關，<br>只跟「程式碼的位置在哪裡這件事情」有關。</p><p>用程式碼來舉個例子：</p><p><img src="https://i.imgur.com/ORzRD6d.png"></p><p>最外面宣告一個 x 的變數叫做外面的變數，然後宣告兩個函式 foo 跟 foo2，裡面分別一個把 x 印出來，一個再宣告一個 x 叫做裡面的變數，順便再呼叫 foo，然後最下面去呼叫 foo2。</p><p>那首先要是還不確定是什麼作用域的話，x 的答案有可能是外面的變數也有可能是裡面的變數，這點要先知道，但是在這邊來說的話，答案會是外面的變數。</p><p>因為靜態作用域的定義就是在宣告時就已經確定下來自己的作用域了，所以在這個例子來看的時候，宣告 foo 時，就已經存在 foo 裡面 x 的作用域的，所以會變成是會先去找 foo 裡面有沒有 x，沒有的話就會往外面找，這邊應該 foo 裡面本身沒有 x，所以是會找到外層的外面的變數，所以說不管是怎麼呼叫的，都會依造這樣的機制來看，不會變來變去，應該說不會動來動去。</p><p>而動態作用域就不ㄧ樣了，先說我沒有寫過動態作用域的程式語言，我對它的認識是看許多文章跟影片來理解的。</p><p>如果是動態作用域的話，在上面那個例子可能最後的答案就變成印出裡面的變數了，這是為什麼呢？</p><p>因為動態作用域有兩個大特點:</p><ul><li>函式被呼叫得時候才會去定義作用域的變數值</li><li>變數值每一次在呼叫的時候都會重新定義</li></ul><p>我覺得最大的差別是動態作用域在找它的作用域時，不是依靠位置去尋找，而是依照呼叫他的地方來決定，所以不同的呼叫，可能最後找到作用域就會不一樣，變化多端，我個人覺得這樣會讓我很難理解我現在變數到底是什麼，變來變去的。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>不同的程式語言擁有不同的個性特點，而這些特點也會影響到寫程式的思維方式或是編寫的風格。所以了結這些特點是很重要的，我也因此花了不少時間在研究這些的差異。</p><p>總之，我研究完的心得就是，每個哪一個是特別好或是特別壞的，一切都看使用需求跟情境，不用去區分優劣，但是要去了解自己使用語言的特性跟優劣處，知己知彼才會寫 code 事半功倍。</p><h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><h3 id="文章類"><a href="#文章類" class="headerlink" title="文章類"></a>文章類</h3><p><a href="https://jenifers001d.github.io/2019/11/22/JavaScript/programming-language-type/">靜態語言 &#x2F; 動態語言、強型別 &#x2F; 弱型別、静態作用域 &#x2F; 動態作用域 | Jenifer.Code.World</a><br><a href="https://openhome.cc/Gossip/Programmer/DynamicStaticLanguage.html">程式語言的特性本質（一）靜態語言與動態語言的信任抉擇</a><br><a href="https://growingdna.com/language-type-compiler/">編譯 vs. 直譯&#x2F; 靜態 vs. 動態&#x2F; 強型別 vs. 弱型別 | GrowingDNA 成長基因</a></p><h3 id="影片類"><a href="#影片類" class="headerlink" title="影片類"></a>影片類</h3><p><a href="https://www.youtube.com/watch?v=tHGb41YO2bg">十分钟理解动态编程语言、静态编程语言、编译型编程语言、解释型编程语言、强类型编程语言及弱类型编程语言 - YouTube</a><br><a href="https://www.youtube.com/watch?v=ZjwnnlQaJ3I">13-1 什麼是變數領域 Scope ? 靜態 vs 動態作用域 全域區域變數 JavaScript 網頁程式設計入門教學課程 | #安迪 TV | Andy PRO TV - YouTube</a><br><a href="https://www.youtube.com/watch?v=ymjbQN1ZM0M">JS 靜態作用域和動態作用域 - YouTube</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何開啟mac截圖後的右下浮動畫面</title>
      <link href="/2023/04/14/a/"/>
      <url>/2023/04/14/a/</url>
      
        <content type="html"><![CDATA[<p>mac 的內建截圖方式是按 shift+command+3 或是+4。</p><p>而在截圖的時候正常來說在右下都會有一個截完圖後的浮動視窗，可以在這個視窗再去做操作跟編輯，不喜歡可以直接刪掉。</p><p>而有一天截圖的時候就突然直接截完直接儲存在桌面，對我來說很不方便，我通常是截完圖後直接複製貼到 hackmd，如果沒有右下浮動視窗的功能，我就還得回到桌面去找哪一張截圖，實在是麻煩。</p><p>最後是研究要怎麼改變回來，雖然自己找花了一些時間，但其實蠻簡單的，在這邊紀錄一下：</p><ol><li>按下 shift+command+5</li></ol><p>看到這個框框就代表沒錯</p><p><img src="https://i.imgur.com/cP32ze3.png"></p><ol start="2"><li>點擊這個框框裡面「選項」</li></ol><p>選擇裡面的“顯示浮動縮覽圖”</p><p><img src="https://i.imgur.com/Lg01jE0.png"></p><ol start="3"><li>你會發現你截完圖後的浮動視窗回來了</li></ol>]]></content>
      
      
      <categories>
          
          <category> 軟體與操作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>簡單理解TCP/IP</title>
      <link href="/2023/04/13/tcpip/"/>
      <url>/2023/04/13/tcpip/</url>
      
        <content type="html"><![CDATA[<p>這個部分算是網路的基礎，關於網路之間是如何傳遞資料的，背後的邏輯，我覺得很重要所以花了一些時間去研究，主要在這邊整理我理解的結果。</p><p>研究網頁前端的過程中，讓我發現一些盲點的事情，像是當我們輸入網址的時候按下了 enter 後，究竟是發生了什麼事情？</p><p>當時我的腦袋覺得，只是我在客戶端發送了一個請求，然後在伺服器端接收了這個請求後，發送了回應回來，渲染出一個新的話，所以我這邊可以看到一個全新的畫面。</p><p>但是傳輸的過程沒有這麼簡單。</p><h2 id="網路的層級-OSI"><a href="#網路的層級-OSI" class="headerlink" title="網路的層級 - OSI"></a>網路的層級 - OSI</h2><p>過去有一群人有發現說網路在傳送的過程中實在是做了太多的事情了，沒有整理起來的話其實大家都不太好懂，雜亂不堪是很難持續進步的，所以他們就一起把這些東西，也就是網路的部分做了標準化。</p><p>這些人把網路標準化後的部分，分成了七個層級，每一層都是負責不同的事情，包括了硬體和軟體在內的七個標準。</p><p>也就是所謂的 OSI，它是一個模型。<br>全名是 System Interconnection Model。</p><p>有哪七個呢？ 如下圖</p><p><img src="https://i.imgur.com/4uEa8rj.png"></p><p>最上面是軟體，最下面是硬體的部分，而詳細這七層每一層在做什麼事情，我個人沒有去背，我覺得只要知道說最詳細嚴謹的層數有七層，然後它叫做 OSI 就好。</p><p>然後有了這七層之後，剛剛說到我送出了一個網址的這個網路傳送行為就會像這樣：</p><p><img src="https://i.imgur.com/DMXf6Dq.png"></p><p>我覺得這個部分也只是有大概的概念就好了，為什麼會這麼說呢，因為七層可能太多了，所以後來會推出一個簡化版本的，也就是今天的主題，TCP&#x2F;IP 四層模型。</p><h2 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h2><p>首先，它是經過 OSI 簡化過後的，也是現在比較主流會討論的，所以我比較偏好去理解這個。</p><p>簡化版的 TCP&#x2F;IP 會比原本 OSI 的七層少了一些，只剩四層。</p><p><img src="https://i.imgur.com/tANAYWZ.png"></p><p>其實也就是把七層的一些部分給合在了一起，像是說應用、表達、會談簡化成了應用一層。</p><p><img src="https://i.imgur.com/eGN28aj.png"></p><p>剩下的這四層都是我覺得相較重要的，這邊來一個個做介紹。</p><h3 id="應用層-Application"><a href="#應用層-Application" class="headerlink" title="應用層 Application"></a>應用層 Application</h3><p>這層的東西就是一般常聽到的像是 HTTP、RTSP、FTP。</p><p>應用層這邊的東西，我會想像成是一種協議，協議意思是要用什麼樣的方式來達成共識。</p><p>有點像是如果法國人不懂中文，我也不同法文，那假如我跟法國人買東西時，要怎麼樣有辦法達成共識，其實還是有辦法的，因為雖然我們語言不通，但只要我們彼此都有學過數字，都懂的阿拉伯數字，那還是有辦法可以達成共識，那這時候阿拉伯數字就可以變成是我跟法國人的一種協議。</p><p>而這塊我會理解成不同的功能應用，就會需要用到不同的協議，因為就網路來說，所需要的功能也是很多種。</p><p>像是一般網頁上的需求，可以就會選擇 HTTP。<br>要傳送資料的話會選擇 FTP。<br>需要做一些串流服務像是開直播的話會選擇 RTSP。</p><p>依照所需要的情境而使用不同的協議及應用。</p><p>這塊是平常很容易專注到的，像是現在的網頁網址你點開裡面，裡面沒出意外的話應該就是’https’<br>開頭的吧。</p><h3 id="傳輸層-Transport"><a href="#傳輸層-Transport" class="headerlink" title="傳輸層 Transport"></a>傳輸層 Transport</h3><p>顧名思義，傳輸。</p><p>就是決定著用什麼樣的方式，來進行傳輸這件事情，把資料送到定位。</p><p>現在主流的方式有兩種。</p><ul><li>TCP</li><li>UDP</li></ul><p>網路上主要會走的傳輸方式是 TCP，因為比較安全可靠。</p><p>這是由於 TCP 的這種方式，會在確定傳輸前，進行一個名字叫做三次握手的方式。</p><p>我對這個方式其實沒有很明白它的底層是怎麼實作的。</p><p>網路上很多文章用兩個人聊天來當作例子，雖然不準確但是好懂。</p><p>大概是兩個人，一個叫做小白，一個叫做小紅。</p><p>兩個互相傳訊息，小白說你好嗎，小紅說我很好你呢，小白說也不錯。</p><p>傳三次之後就代表兩個人的收跟發功能就正常了。</p><p>我對三次握手的理解是這樣。</p><p>我覺得這塊理解這樣就足夠了，TCP 由於有進行一個三次握手的動作，所以可以確保資料不會在傳送的過程中有遺漏，所以很可靠。</p><p>相對來說，UDP 就沒有三次握手，但也是因為沒有三次握手，所以它的傳輸速度會比 TCP 快很多，有好有壞的概念。</p><p>由於這個特點，所以 UDP 這種傳輸的方式常常會被拿來運用在沒有那麼需要可靠及穩定的情況下，這種情況通常也比較需要傳遞速度快一些，舉例來說串流服務，不論是視訊通話或是直播。</p><p>會沒有需要那麼可靠以及穩定主要是因為這種的服務其實每秒都在傳送，要是傳送的過程中丟失一咪咪的東西，其實對使用者的影響不會太大，體感來說就只是看影片時突然失真，卡頓了一下下，其實影響也是不會太大的，這時候的需求反而是因為要很及時，所以傳輸速度要很快，所以 UDP 的傳輸方式是首選。</p><p>而像是一般在傳送電子郵件，如果使用 UDP 的方式那就可能很慘，因為如果丟掉了資料在傳送的過程中，就算只是一點點，那也會造成很大的影響，說不定那是很重要的資料，對我來說兩個都有它使用的情境。</p><p>結合上面應用層所講的不同的應用會對應到不同的傳輸方式，像是說 http 會走 TCP 的方式，RTSP 會走 UDP 的方式。</p><h3 id="網路層-Internet"><a href="#網路層-Internet" class="headerlink" title="網路層 Internet"></a>網路層 Internet</h3><p>這個在網路傳送資料的分層中，是代表地址的一塊。</p><p>我要把資料送到哪裡去？ 這就是網路層的概念。</p><p>平常很常聽到的 IP 其實就是了，大家會講 IP 其實已經是簡化過的用語，其實是 IP 位址，這也是我們在網路上的地址。</p><p>我的想像是每一台電腦都有一個 IP 位址，都可以從這 IP 位置去找到電腦的所在地。</p><p>這個部分還可以細分成：</p><ul><li>固定 IP</li><li>浮動 IP</li><li>虛擬 IP</li></ul><p>簡單解釋一下，這三種的差別。</p><p>固定 IP 就是固定不會變的地址，通常都是公司企業會使用的，這樣才能保證使用者可以連上伺服器，不會突然找不到。</p><p>浮動 IP 就是代表說，每次連上網路的時候，IP 位址都會不一樣，別人還是可以連到這個 IP，但是呢這個 IP 位址會隨著下一次的連線而做變化，為什麼要這樣設計呢？</p><p>我覺得原因是今天如果被有心人士給盯上，或是被洩露了 IP 位置，也不會被輕易的攻擊，如果是用浮動 IP 的話，像我自己電腦就是浮動 IP，一般來說，普通的使用者跟家用電腦也大部分是浮動 IP。</p><p>最後一個是虛擬 IP，我其實比較不太懂這個，它是在內網底下才可以互相連結的，沒辦法使用外網連上，<br>這也代表說內網的 IP 位址可以重複，不過這個對於外網而已一定會有一組 IP 地址對外，可能是浮動也可能是固定。</p><h3 id="網路訪問層-Network-Access"><a href="#網路訪問層-Network-Access" class="headerlink" title="網路訪問層 Network Access"></a>網路訪問層 Network Access</h3><p>這就是 TCP&#x2F;IP 這四層模組最下面那一層，代表的是實體的連結方式。</p><p>就是網路需要一個實際真正的實體來做傳輸，最早的時候可能是透過海底電纜的方式，現在的話可能是使用光纖網路，連結的方法有很多種。</p><p>我會想像成是我家裡電腦的網路線，要拉一段距離，然後是實體的。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>我做了一張圖：</p><p><img src="https://i.imgur.com/aR70lSR.png"></p><p>其實我研究的時候有發生其他更深入的部分，但我只選擇看過但是沒吸收進入大腦，當然也是因為太複雜了如果要完全弄需要花費很多的時間成本，但最主要是我覺得只要現在了解大概，之後真的有需要用到的時候再去研究也不遲。</p><p>那麼這篇文章就告一段落，加油加油！</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><h3 id="影片類"><a href="#影片類" class="headerlink" title="影片類"></a>影片類</h3><p><a href="https://www.youtube.com/watch?v=2UWiTaIxukY">05 成為看起來很強的後端：網路是如何運作的－TCP&#x2F;IP 四層模型 - YouTube</a><br><a href="https://www.youtube.com/watch?v=gxoIrBFfpDU">網路基礎 2- 網路七層與 TCP&#x2F;IP - YouTube</a><br><a href="https://www.youtube.com/watch?v=HEEnLZV2wGI">The OSI Model Demystified - YouTube</a></p><h3 id="文章類"><a href="#文章類" class="headerlink" title="文章類"></a>文章類</h3><p><a href="https://miahsuwork.medium.com/%E7%AC%AC%E5%85%AD%E9%80%B1-%E7%B6%B2%E8%B7%AF%E5%9F%BA%E7%A4%8E-tcp-ip-f89cc09f1f36">[第六週] 網路基礎 — TCP&#x2F; IP. 學習目標：粗淺了解 TCP&#x2F; IP | by MiaHsu | Medium</a><br><a href="https://zh.wikipedia.org/zh-tw/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F">網際網路協議套組 - 維基百科，自由的百科全書</a><br><a href="https://ithelp.ithome.com.tw/articles/10246327">[知識篇] 網際網路協議 - TCP&#x2F;IP - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端相關 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Volta 使用筆記</title>
      <link href="/2023/02/28/volta/"/>
      <url>/2023/02/28/volta/</url>
      
        <content type="html"><![CDATA[<p>會學習 volta 主要是在進行 node 版本切換的時候，原本會是使用 nvm 的方式，但是聽說現在有一個更好用的工作叫做 volta，所以開始對這個工具進行研究。</p><p>首先是 volta 的官網： <a href="https://volta.sh/">https://volta.sh/</a></p><p>進到這個官網以後，就可以看得到如何安裝的方式。</p><p><img src="https://i.imgur.com/zfHPEgR.png"></p><p>在這裡就打開終端機，然後下這串指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://get.volta.sh | bash</span><br></pre></td></tr></table></figure><p>就會自動安裝成功了，在這裡我自己有遇到一些問題，就是安裝明明是成功的，但是當我下<code>volta -v</code>試圖去查詢版本號時，卻得到<code>not found volta</code>的結果，讓我以為沒有成功安裝，但後來發現只是因為使用 vscode 內建的終端機去下載安裝完還需要重載不然不會正確顯示，其實原本還是有安裝，這點要記得注意。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>官網在這裡把 volta 的管理分成</p><ol><li>Managing your toolchain</li><li>Managing your project</li></ol><p>在這裡的第一個會使用到的指令是<code>volta install</code></p><p>剛開一個新專案時都是空的，還沒有任何資料，這時候切換 node 版本的方式就只能是用<code>volta install</code>，我的理解是它有點類似於最外層的概念，但單獨講這塊可能會難想像，所以先繼續往下。</p><p>假如在這個空的資料夾裡面再創兩個新的 project，<br>像是有一個叫做”0221”的資料夾，裡面創了兩個 vue 的新專案(vue-project , vue-project2)</p><p><img src="https://i.imgur.com/QR4pSXl.png"></p><p>會發現裡面的 project 打開後，還會有<code>package.json</code>，而最外層沒有，而如何改動這個 vue 的新專案的 node 版本就會需要用到<code>volta pin</code>指令</p><p>在這邊實際實作一次：</p><p>先檢查外層”0221”的 node 版本狀況<br><img src="https://i.imgur.com/T2nboCv.png"></p><p>然後進到”vue-project”裡，<br>這邊使用<code>volta pin</code>指令來改變 node 版本</p><p>下<code>volta pin node@15</code>，<br>會跳出訊息<br><code>success: pinned node@15.14.0 (with npm@7.7.6) in package.json</code><br>代表已經成功轉換了，這時候去看”vue-project”的<code>package.json</code>會發現已經被添加了 volta 相關版本訊息</p><p><img src="https://i.imgur.com/v31NaO7.png"></p><p>這時候已經轉換成功了，所以去看 node 版本會發現已經變成 15<br><img src="https://i.imgur.com/B9XHVDY.png"></p><p>而這時候再使用<code>volta install</code>系列就改變不了”vue-project”的 node 版本，因為有<code>package.json</code>會優先看這裡的。</p><p>轉換到”vue-project2”的資料夾，會發現版本還是處在外層”0221”的 node 版本狀況，然後再用<code>volta pin</code>指令來改變 node 版本，成功後這三種地方的 node 版本就都會不一樣</p><p><img src="https://i.imgur.com/uPptGaP.png"></p><h2 id="重點理解整理"><a href="#重點理解整理" class="headerlink" title="重點理解整理"></a>重點理解整理</h2><p>一般來說<code>volta install</code>可以理解成是改變預設狀態下的 node 版本，而<code>volta pin</code>則是會把改變的 node 版本給紀錄在<code>package.json</code>，所以會有固定的效果，只要是在那個<code>package.json</code>範圍的都會吃到它當中的 node 版本。</p><p>在這邊就會產生一些優先權問題，這些都是正常的：</p><ol><li>使用<code>volta pin</code>後，<code>volta install</code>會失效</li><li>沒有<code>package.json</code>就沒辦法使用<code>volta pin</code></li></ol><p>目前體感的好處是，假如協作的對象也有使用<code>volta</code>，那可以從他的專案的<code>package.json</code>去看 node 的版本，這點很方便，切換的速度也十分的快速，想切換就切換～！</p><p>最後以上介紹的是普通狀況會常用的兩個指令，另外還有許多的指令這部分可以參考官網：<br><img src="https://i.imgur.com/oc2BSKw.png"></p><p>官網的地方：<a href="https://docs.volta.sh/reference/">https://docs.volta.sh/reference/</a></p>]]></content>
      
      
      <categories>
          
          <category> 軟體與操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volta </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的「回傳」與「印出」</title>
      <link href="/2023/01/02/JS%20retrun%20and%20log/"/>
      <url>/2023/01/02/JS%20retrun%20and%20log/</url>
      
        <content type="html"><![CDATA[<p>剛開始學習時常常搞混的地方，關於什麼時候屬於「回傳」什麼時候得「印出」常常傻傻搞不清楚，在這裡做個筆記紀錄一下，我自己研究完後的理解。</p><p>這部分要先知道所謂的「回傳」在 JavaScript 使用的語法是<code>return</code>，<br>而「印出」則是<code>console.log</code>。</p><h2 id="回傳：return"><a href="#回傳：return" class="headerlink" title="回傳：return"></a>回傳：return</h2><p>通常是使用在函式裡面，代表說回傳一個值的概念，這邊要注意，只是代表說會回傳一個值但是不會印出來，所以說假如去互叫一個只有<code>retrun</code>卻沒有<code>console.log</code>的函式，那會發現什麼也不會發生。</p><p>假如是想要在呼叫函式的時候，也可以印出值的話，就得在函式中去<code>retrun</code>出值，然後在外面的部分去進行<code>console.log</code>的東西才有辦法做得到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">call</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">call</span>(<span class="string">&quot;vic&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="印出：console-log"><a href="#印出：console-log" class="headerlink" title="印出：console.log"></a>印出：console.log</h2><p>單純把被<code>console.log</code>裡面的值給印出來，跟回傳不一樣的地方是，假如今天函式內直接做<code>console.log</code>，那在外面呼叫時就會直接印出東西來。</p><p>印出東西的情境我覺得最多是用在找 bug 的時候，非常的方便建議多多利用，因為編譯的時候其實都不太會被錯，所以很多的錯誤都是要等程式執行之後才跑出來，這時候就可以用<code>console.log</code>慢慢尋找錯誤的地方。</p><h2 id="瀏覽器上特殊的行為"><a href="#瀏覽器上特殊的行為" class="headerlink" title="瀏覽器上特殊的行為"></a>瀏覽器上特殊的行為</h2><p>在瀏覽器上假如使用 dev tool 去寫 JavaScript，會發現瀏覽器多幫忙做了一些事情，所以建議如果要做測試時或是想試寫一個函式是要印出值的，在 node.js 的環境下比較保險。</p><p>我發現瀏覽器多做的一些事情比如說像是寫一個函式裡面只有使用回傳<code>retrun</code>，但是如果只要呼叫這個函式，也是會直接把值給印出來，我大膽假設瀏覽器每次都會多幫忙在外面多幫忙做一次<code>console.log</code>，所以才會造成這種現象。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>新手卡關就是會卡在這裡了，但還是得花一些時間把這塊釐清清楚，兩個都很常用到，也很容易做出互相搭配，這邊最後提醒一下，<code>retrun</code>除了回傳值之外，它同時也代表著就到此結束，所以後面的程式碼就不會繼續進行下去了，這點要注意。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://lidemy.com/courses/387030/lectures/9677847">「回傳」與「印出」的差異 | Lidemy 鋰學院</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>node.js 取得使用者輸入</title>
      <link href="/2022/11/29/nodeJS%20readline/"/>
      <url>/2022/11/29/nodeJS%20readline/</url>
      
        <content type="html"><![CDATA[<ul><li>自己研究時的參考資源：</li></ul><p>-<a href="https://www.delftstack.com/zh-tw/howto/javascript/get-user-input-in-javascript/">在 JavaScript 中獲取使用者輸入| D 棧</a></p><p>-<a href="https://github.com/Hans-Tsai/Node.js-Learn">Hans-Tsai&#x2F;Node.js-Learn</a></p><p>-<a href="https://nodejs.org/en/">Node.js 官網</a><br>node.js 要取得使用者輸入會需要方法，我目前在使用的方式是用 readline 的方式，可以藉由它直接去做到使用者輸入</p><h2 id="主要的幾種方式"><a href="#主要的幾種方式" class="headerlink" title="主要的幾種方式"></a>主要的幾種方式</h2><ul><li>readline &#x3D;&gt; node.js 提供，可直接引用來幫助取得輸出輸入</li><li>prompt-sync &#x3D;&gt;</li></ul><table><thead><tr><th></th><th>readline</th><th>prompt-sync</th></tr></thead><tbody><tr><td>Text</td><td>非同步</td><td>同步</td></tr><tr><td>Text</td><td>不需要安裝</td><td>需要安裝</td></tr></tbody></table><h2 id="readline"><a href="#readline" class="headerlink" title="readline"></a>readline</h2><p>引用基於 callback and sync 的 API</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const readline = require(&#x27;node:readline&#x27;);</span><br></pre></td></tr></table></figure><p>引用基於 promise 的 API</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import * as readline from &#x27;node:readline/promises&#x27;;</span><br></pre></td></tr></table></figure><p>CJS 範例版本 &#x3D;&gt; commonJs</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;node:readline&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">stdin</span>: input, <span class="attr">stdout</span>: output &#125; = <span class="built_in">require</span>(<span class="string">&#x27;node:process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123; input, output &#125;);</span><br><span class="line"></span><br><span class="line">rl.<span class="title function_">question</span>(<span class="string">&#x27;What do you think of Node.js? &#x27;</span>, <span class="function">(<span class="params">answer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Log the answer in a database</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Thank you for your valuable feedback: <span class="subst">$&#123;answer&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  rl.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>ESM 範例版本 &#x3D;&gt; ES module</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> readline <span class="keyword">from</span> <span class="string">&#x27;node:readline/promises&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; stdin <span class="keyword">as</span> input, stdout <span class="keyword">as</span> output &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123; input, output &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> answer = <span class="keyword">await</span> rl.<span class="title function_">question</span>(<span class="string">&#x27;What do you think of Node.js? &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Thank you for your valuable feedback: <span class="subst">$&#123;answer&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">rl.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure><h2 id="prompt-sync"><a href="#prompt-sync" class="headerlink" title="prompt-sync"></a>prompt-sync</h2><p>首先，你需要使用 NPM 或 Yarn 安裝 prompt-sync</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install prompt-sync</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add prompt-sync</span><br></pre></td></tr></table></figure><p>CJS 範例版本 &#x3D;&gt; commonJs</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> prompt = <span class="built_in">require</span>(<span class="string">&quot;prompt-sync&quot;</span>)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="title function_">prompt</span>(<span class="string">&quot;你叫做什麼名字?&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`您好 <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好想工作室的案主挑戰賽 參加心得</title>
      <link href="/2022/11/28/web%20client%20challenge/"/>
      <url>/2022/11/28/web%20client%20challenge/</url>
      
        <content type="html"><![CDATA[<p>在好想工作室中參與其他案子累積經驗時，過程中剛好碰到這個案主挑戰賽的活動，主要是給一些在好想工作室一些還在學習的學員讓他們有接案的經驗，可以參考這一篇：<br><a href="https://ithelp.ithome.com.tw/articles/10252793">練功活動: 模擬案主!! - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天</a></p><p>本來沒有要參加，但在最後一刻還是加入了進去。</p><h2 id="模擬案主"><a href="#模擬案主" class="headerlink" title="模擬案主"></a>模擬案主</h2><p>所謂的案主會由工作室內資深的前輩進駐者擔任，會由他們之前所做的案子之中，萃取出直接之前專案中遇到的難題來當作挑戰賽主軸，包括題目的設定，驗收的 story，挑戰賽過程中也會不斷地跟參賽者有所互動。</p><p>規則大致上是這樣，會分成幾組來比賽，舉辦方會依造參加者目前的程度，來平均分隊，像是這次主要就分成三組，每組三個人，時程就只有一個禮拜，在這一個禮拜中要儘可能的把案主的需求做完，生出一個網站。</p><p>一切的起源就在那一個風和日麗的下午，工作室內有要參加這次案主挑戰賽的人全部聚集在了大會議室，人微微多讓我覺得有點緊張，主辦方首先請我們每一個參加的人寫下想跟誰同隊的小紙張，我隨便寫了一個便交了出去，隨後便是一陣主辦方的操作，經過一個我也不太了解的機制後，我的另外兩個隊友就出爐了，所有的分組組合就印在會議室內的大白板上，主辦方開始講一些該注意的事項。</p><p>這時我突然凝視著前方的白板，看了看我的隊友，除了我之外沒有人有寫程式的經驗，有一個還連切版都不太會切，我的汗慢慢從我的臉上滑了下來。</p><h2 id="開始分配"><a href="#開始分配" class="headerlink" title="開始分配"></a>開始分配</h2><p>離開大會議室後，挑戰賽就算是正式開始，大家各組都開始討論了起來。</p><p>時間只有一個禮拜，理論上要很趕，現在就要馬上狂做，但我覺得越是這種時候，前面就要花越多時間在分配這件事情上面才對，一開始困難後反而後面會簡單，我是這麼想的，保持著慢慢來比較快的心態，我開始分析起來我們這組的未來。</p><p>我知道這個挑戰賽不是只是想考驗技術力而已，不然就全部都最厲害的人來做會最快，但這樣就沒有分組的必要，而且未來實際工作上也不可能都是一個人單打獨鬥，是要有團隊的！所以協作力才是這次挑戰賽的關鍵。</p><p>我開始去確定每個隊友的能力所在，然後去思考他們能做的工作，我的底線是團隊中大家都有要參與，都有要貢獻，最後先分配一個大方向。</p><p>我 &#x3D;&gt; 專案中的 JS<br>隊友 A &#x3D;&gt; 專案中的切版<br>隊友 B &#x3D;&gt; 專案中的套件</p><p>我的部分主要是因為其他兩個隊友其實才剛碰前端沒多久，所以程式的部分我就一肩扛下了，至於隊友Ａ的狀況，我覺得他切版其實還 OK，所以專案中的切版就交給了他，最後隊友 B 的部分比較難，因為切版的部分也不 OK，後來想到專案有一些套件的部分，可以直接去網路上找別人做好的來用，最好的情況下只需要改改樣式，於是交付給他，就這樣初步的分配就完成了。</p><h2 id="注定遇到的雷"><a href="#注定遇到的雷" class="headerlink" title="注定遇到的雷"></a>注定遇到的雷</h2><p>接案的分工合作中，有一些事情是躲不掉的，其中有一個就是 git 的版控管理這一塊，而為什麼這個部分很可怕呢？</p><p>那是因為假如一個專案要協作的人越來越多，假如沒有先定好一個統一的規則，大家都照自己的想法去 commit 或是開分支，都任君開發的話，就最終就會變成一場災難，畢竟你的習慣不是我的習慣，大家習慣都不一樣，那要聽誰的。</p><p>所以在最初的時候，我們這組有引進 Git Flow 的流程開發，就是讓大家有一套規則可以去遵守，包括 commit 紀錄的格式寫法，以及分支應用情境，每個分支都有它功能意義存在，在合併分支時都需要透過一個非自己的人透過 PR 的方式再次檢查要合併的 code，做一個確認的動作，藉由這些方式，讓 git 版控管理這個注定遇到的雷發生問題的機率小一點。</p><p>還有一個是我覺得應該也是一定會碰到的雷，但是被我們巧妙地避免，就是重複及衝突的部分，這塊因為我們的分配分得很開，程式跟切版是完全獨立出來的，所以基本上不會有什麼會重複的問題，假如今天一個頁面是由兩個人負責切版，那就有可能會發生同一個區塊，但是兩個地方的樣式都不一樣的狀況，甚至一些衝突的部分要反覆修改，但我們這組在參加挑戰賽的時候這種情況不多，基本上就是隊友 A 一直瘋狂的切著版，我就寫功能，等他把版面切好後我再去串 API，亦或是我先把 API 串好，他再繼續切這樣，衝突會有但是基本上很少，而我也僅可能完全不去碰切版，就交給隊友Ａ。</p><h2 id="挑戰賽期間"><a href="#挑戰賽期間" class="headerlink" title="挑戰賽期間"></a>挑戰賽期間</h2><p>評估專案需求後，我們最終是決定用 vue 的框架來完成這次挑戰的模擬案，之前有接過 vue 的專案，所以我有一些把握不至於最終會做不出來，把環境建好之後，大家都開始做自己分配好的任務，準備開始一個禮拜的挑戰賽。</p><p>過程中跟我想得差不多，一定會有很多我還不知道的地方，要先研究過後才能實作，所以這部分已經有心理預期，但一開始的時候有些過份樂觀，還以為可以一邊進行挑戰賽，一邊弄我原本的專案，事實證明我連把挑戰賽顧好都顯得有些吃力，還在過程中還遇到許多卡住的事情，例如：跳出的錯誤訊息看不懂，找資料半天也沒頭緒，做專案過程中還必須一直撥時間去處理別人的事情，解決別人的問題，對我來說都是很困難的挑戰。</p><p>這個挑戰賽總共有兩次的驗收，第一次是在兩天後，第二次是在剛好一個禮拜後，時間很短所以在第一次驗收的時候基本上還沒有完全做完，而且在第一次驗收時，由於我不會拒絕的原因，被擔任模擬業主的前輩們硬生生追加許多功能以及細節，所以兩天後的第一次驗收結束後，我大概就感覺到我後面這幾天不用睡覺了。</p><p>越接近尾聲，狀況就有如雨後春筍般不斷有湧出，我猜在這部分也可能是挑戰賽精心策劃的難題，像是驗收前幾天才把後台資料給齊，不停的設變(Design Alteration)，一些的臨時額外需求，這部分我覺得主辦方的模擬案主們扮演的非常的好，把真實可能反覆無常，愛刁難人的角色演繹得栩栩如生，我們組就盡可能的把這個鍋子(需求壓力)給蓋好，不要讓他滿爆出來，心中不停默念著一切都好。</p><p>最後驗收的前一天，得知了一些套件的需求可能隊友做不出來，所以可能要我生，再加上還有一些額外新被提出功能我還沒做完，但我想說其他大部分都做完了，所以這部分還好，但意外就是在這種時候會發生，這時的專案還沒成功部署上去，只在本地端測試，但卻在測試時發現手機載入時的速度慢得要命，明顯不正常，真的完蛋的那種，而且還是在前一天才發現，因為電腦上完全看不出來，所以開始瘋狂找原因，從下午找到晚上，從晚上找到回家，完全找不到原因，很奇怪的是就只有 ios 的手機跟平板會卡頓，安卓不會，電腦也都不會，為了解決這個問題，花了我一整天，所以原本要趕出來的功能通通都沒時間做，因為要是這個問題沒解決，等於直接宣判了我們這組的死刑，我平常是搭公車通勤的，那天也是待在末班車的時間不得不回家。</p><p>最終驗收就在明天，心生絕望後決定先部署，總不能連個網頁樣子都弄不出來，但部署上去後就突然恢復正常了，有點命運捉弄人的感覺，但好在是解決了，後來的故事就是我在正式驗收之前，把其餘的功能都趕一趕出來，在隔天正常驗收前生出了我自認有八成像的網站等待驗收，雖然過程有些坡折，但最後還是有成功把東西做出來～</p><h2 id="參賽後記"><a href="#參賽後記" class="headerlink" title="參賽後記"></a>參賽後記</h2><p>完賽後第一個感覺是時間過得真快，一個禮拜的時間刷一下就消失了，過程除了在弄模擬專案外，主辦方也會關心我們每一組的進度以及講解一些重點幫助大家進入狀況，所以也有學到很多在正式接案中跟業主對談的眉眉角角，像是：</p><ul><li>PM 金三角</li><li>如何確認需求，Story</li><li>可開工條件</li><li>demo 展示給業主看的要點</li><li>最小可行性 MVP</li></ul><p>整體來說我蠻喜歡這次參加的體驗，藉由這次我也更深刻的明白自己確實還有許多不足的地方，不會的東西還有很多，我想這次挑戰賽結束之後，感覺到的不是單純的可以放鬆了，而是要再去開拓自己還不足的學習道路，畢竟有補充了許多方向可以參考，期許不久後在面對壓力時可以更游刃有餘！</p>]]></content>
      
      
      <categories>
          
          <category> 活動心得 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>建立sass環境(2022)</title>
      <link href="/2022/11/27/sass%20build%20environment/"/>
      <url>/2022/11/27/sass%20build%20environment/</url>
      
        <content type="html"><![CDATA[<p>此篇文章建立已經有 npm 的情況下。</p><p>如果是像我還有需要 node.js 的人，只要去安裝了 node.js，也會同時安裝 npm，至於如何安裝 node.js 可以去它的官網看&#x3D;&gt;<a href="https://nodejs.org/en/">https://nodejs.org/en/</a> 。</p><span id="more"></span><p>回到這次主題。</p><h2 id="環境分成兩種"><a href="#環境分成兩種" class="headerlink" title="環境分成兩種"></a>環境分成兩種</h2><ul><li>全域的方式</li><li>本地端的方式</li></ul><p>全域的方式代表只要裝了一次，整台電腦都會有 sass，而本地端則是範圍只限於一個專案之中，個人偏好使用本地端的方式，儘管可能每次都要裝一次，但會比較清楚使用了什麼。</p><h2 id="全域安裝-sass-環境"><a href="#全域安裝-sass-環境" class="headerlink" title="全域安裝 sass 環境"></a>全域安裝 sass 環境</h2><p>第一步打開終端機。</p><p>第二步直接打指令。</p><p>安裝的指令： <code>npm install -g sass</code><br>解除安裝的指令： <code>npm uninstall -g sass</code></p><p>在這過程中可能會直接錯誤，畫面上會給出報醋，這是十分正常的，爬文後發現有一些權限問題，這時候只要最前面加上<code>sudo</code>，以及之後打上密碼就 ok 了。</p><p>例如：<br>安裝的指令 &#x3D;&gt; <code>sudo npm install -g sass</code><br>解除安裝的指令 &#x3D;&gt; <code>sudo npm uninstall -g sass</code></p><p>而要怎麼檢查安裝有沒有成功，或是有沒有成功卸載，可以透過查詢 sass 的版本來檢查，一樣在終端機的地方打上這段指令:<code>sass --version</code>。</p><p>要是你跟我一樣沒有在全域安裝的話就會出現這一段：<br><img src="https://i.imgur.com/SK51ICe.png"></p><h2 id="本地端安裝-sass-環境-自動編譯版"><a href="#本地端安裝-sass-環境-自動編譯版" class="headerlink" title="本地端安裝 sass 環境(自動編譯版)"></a>本地端安裝 sass 環境(自動編譯版)</h2><p>在創立一個專案後，進入到裡面開始以下步驟。</p><ol><li><p>先 <code> npm init -y</code><br>他跟 npm init 幾乎一樣，只是它會幫你把預設選項全部跳過，產生一個空白的 package.json (懶人專用)<br><img src="https://i.imgur.com/vbB13xu.png"></p></li><li><p>使用 <code>nam install sass</code><br><img src="https://i.imgur.com/Q5RzsZl.png"></p></li><li><p>加上 <code> &quot;sass&quot;: &quot;sass --watch scss/style.scss:style/style.css&quot;</code><br><img src="https://i.imgur.com/0rN0iKz.jpg"></p></li><li><p>把 scss 的資料夾給創出來</p></li><li><p>成功編譯！<br>之後之要寫<code>npm run sass</code>就可以一直幫忙自動編譯。<br><img src="https://i.imgur.com/jeOJPkI.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在VSCode設定自己想要的使用者片段</title>
      <link href="/2022/11/13/snippets/"/>
      <url>/2022/11/13/snippets/</url>
      
        <content type="html"><![CDATA[<p>前端工程師在使用 vscode 這個編譯器進行切板剛開始時，通常開完一個叫做 index.html 的檔案後，就會開始在最初的頁面裡下一個驚嘆號。</p><p><img src="https://i.imgur.com/ZJa60Fz.png"></p><p>這是預設的，所以完全不用做任何的設定，而當把這個驚嘆號給按下去之後，就會出現一套模板，包含了 html、head、body，這個模板節省了最初的撰寫時間，相信很多人沒有這個驚探號生成的模板可能剛開頭就不知道如何下手了。</p><p>而這個其實也能夠自己手動去做設定的，它是 vscode 其中的一個好用功能，叫做 User Snippets，也稱之為使用者自訂程式碼片段。</p><p>接下來就會教如何從零設定自己想要的使用者片段。</p><h2 id="步驟一"><a href="#步驟一" class="headerlink" title="步驟一"></a>步驟一</h2><p>首先 vscode 頁面從最上面那一排找到一個叫做喜好設定的選項當中，會看到裡面有一個叫做&#x3D;&#x3D;使用者程式碼片段&#x3D;&#x3D;的區塊，點下去。</p><p><img src="https://i.imgur.com/J3TWiMT.png"></p><h2 id="步驟二"><a href="#步驟二" class="headerlink" title="步驟二"></a>步驟二</h2><p>會出現一個視窗的選項在中央供選擇，這此請按新增&#x3D;&#x3D;全域程式碼片段檔案&#x3D;&#x3D;。</p><p>這個選項的意思是此檔案設定的使用者片段會讓你的所有檔案都可以使用，所以假如只由讓特定檔案使用而已的話，就不適合全域的方式，可以選擇只 for 一個專案去新增。</p><p><img src="https://i.imgur.com/v9UGMHO.png"></p><p>然後會跳出需要為這個程式碼片段取名字，假如不知道要取什麼的話可以跟我一樣先叫做 demo，當做測試的意思。</p><p><img src="https://i.imgur.com/hq6JEo9.png"></p><h2 id="步驟三"><a href="#步驟三" class="headerlink" title="步驟三"></a>步驟三</h2><p>會進入到一個檔案當中，這個檔案就是用來設定你全域使用者片段的地方，裡面一開始就有一段註解的 code，這段 code 其實就是在說明要如何使用使用者片段，還附了一段簡單的範例。</p><p><img src="https://i.imgur.com/LDkevhG.jpg"></p><p>在這邊先反註解它的範例 code，來做測試，把綠色字 Example:下面的都反註解。<br>(mac 系列的使用者使用者反註解的方式就是 <code>command + ?</code>)</p><p><img src="https://i.imgur.com/Q0CHIjM.jpg"></p><p>這邊解釋一下它範例裡面語法的個別意思。</p><h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><p>指這個使用者片段可以使用的程式語言範圍，像是裡面 javascript 跟 typescript 就表示說，只有寫在兩種程式語言的檔案時才會生效，假如說在 html 的檔案中就不會生效。</p><h3 id="prefix"><a href="#prefix" class="headerlink" title="prefix"></a>prefix</h3><p>填寫時的關鍵字，就像是最前面說的那個驚嘆號，打出關鍵字就能成功引入自己設定的使用者片段。</p><p>單個關鍵字用字串直接寫就好，但如果需要多個關鍵字就需要用陣列包起來。</p><h3 id="body"><a href="#body" class="headerlink" title="body"></a>body</h3><p>使用者片段的內容本體，填寫在裡面的內容就會直接被當成使用者片段來輸出。</p><p>另外裡面假如只有單行的話，就可以包字串就好，但如果是多行的架構，就需要用一個陣列包起來。</p><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>描述這個使用者判斷是幹嘛的，可寫可不寫，寫了的話會顯示在顯示在 IntelliSense 上，可以讓其他人更好理解這個使用者片段在幹嘛。</p><h3 id="x3D-gt-預設處理位置"><a href="#x3D-gt-預設處理位置" class="headerlink" title="$ &#x3D;&gt; 預設處理位置"></a>$ &#x3D;&gt; 預設處理位置</h3><p>這個範例裡面可以發現到 body 之中有著神秘的$符號，它其實就代表著，把這個使用這片段引入之後，預設的輸入位置，假如有多個時候，可以透過 tab 來做切換。</p><h2 id="步驟四"><a href="#步驟四" class="headerlink" title="步驟四"></a>步驟四</h2><p>來看看這個內建的 log 使用者片段的效果。<br><img src="https://i.imgur.com/fmqVSi0.gif"></p><h2 id="實際上情境運用"><a href="#實際上情境運用" class="headerlink" title="實際上情境運用"></a>實際上情境運用</h2><p>我有一個想要用使用者片段的地方，就是我在一個新 vue 檔案時，都要重新寫</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>所以會希望用使用者片段去節省掉寫這些的時候，直接來做設定！</p><p>直接照著格式謝一組自己需要的片段。<br><img src="https://i.imgur.com/iUr5JwP.png"></p><p>看使用效果：</p><p><img src="https://i.imgur.com/DpNKcYe.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 軟體與操作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的「引數」、「參數」、「變數」</title>
      <link href="/2022/10/30/JS%20three%20numbers/"/>
      <url>/2022/10/30/JS%20three%20numbers/</url>
      
        <content type="html"><![CDATA[<p>這三個常常會搞混，用一個簡單的範例超快速搞懂這三個概念！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>這時候 add 這個函式裡面的 a 跟 b 就是<code>參數</code>。<br>而下方呼叫函式裡面的 1 跟 2 就是<code>引數</code>。</p><p>那現在如何把變數的概念也加進去 &#x3D;&gt;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, c);</span><br></pre></td></tr></table></figure><p>剛剛的那個例子中就會多了一個叫做 c 的變數，這個 c 的變數就會在呼叫 add 這個函式的時候把變數帶入這個引數，這個時候變數就成為了引數，然後這個引數會在帶回這個參數，最後把結果給算出來。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML 內建範本的三個meta</title>
      <link href="/2022/10/24/html%20three%20meta%20tag/"/>
      <url>/2022/10/24/html%20three%20meta%20tag/</url>
      
        <content type="html"><![CDATA[<p>創建完.html 的檔案後，在開始把版面切出來之前，通常會使用!的方式把內建的範本給建立出來，使用內建範本會把一些基本的東西都先呈現出來，像是 html、head、body 的 tag。</p><span id="more"></span><p><img src="https://i.imgur.com/Nm0Ll9g.png"></p><p>雖然十分的理所當然，但也因為方便所以有時會忽略掉那些內建的東西是什麼，在內建範本之中，我覺得最容易被忽略掉，跟最容易經過時間遺忘的是其中的三個 meta tag，所以在此做個筆記讓之後遺忘可以複習。</p><p><img src="https://i.imgur.com/Zu9pEFi.png"></p><br><h2 id="lt-meta-charset-quot-UTF-8-quot-gt"><a href="#lt-meta-charset-quot-UTF-8-quot-gt" class="headerlink" title="&lt;meta charset=&quot;UTF-8&quot;&gt;"></a><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code></h2><p>這一段是跟編碼有所關聯，可以用來指定說這個網頁內容需要用什麼編碼。</p><p>一般來說會使用”UTF-8”來做編碼，HTML5 的規範也推薦所有開發人員都使用 UTF-8 字符集，因為它幾乎涵蓋了世界上所有的字符跟符號。</p><p>詳細可以參考這一篇文章，我覺得還不錯：<br><a href="https://progressbar.tw/posts/200">[HTML][新手] 04. 中文編碼表示 meta charset</a></p><br><h2 id="lt-meta-http-equiv-quot-X-UA-Compatible-quot-content-quot-IE-edge-quot-gt"><a href="#lt-meta-http-equiv-quot-X-UA-Compatible-quot-content-quot-IE-edge-quot-gt" class="headerlink" title="&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;"></a><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code></h2><p>這一段主要是用到控制 IE 相容模式，可以用此來設定 IE 的版本。</p><p>讓在 IE 瀏覽器的時候，也能正常地觀看網頁，但現在因為 IE 已漸漸沒落，所以感覺這段的作用慢慢減少中，之後可能就會完全停用。</p><p>關於這塊的文章：<br><a href="https://hackercat.org/web-notes/ie-x-ua-compatible">IE 相容模式設定 X-UA-Compatible</a><br><a href="https://www.cnblogs.com/youpeng/p/10991144.html"><meta http-equiv="X-UA-Compatible" content="IE=edge">詳解</a></p><br><h2 id="lt-meta-name-quot-viewport-quot-content-quot-width-device-width-initial-scale-1-0-quot-gt"><a href="#lt-meta-name-quot-viewport-quot-content-quot-width-device-width-initial-scale-1-0-quot-gt" class="headerlink" title="&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;"></a><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code></h2><p>這段的作用是 rwd 響應式的設定，會需要 meta 裡面的 viewport 來指定瀏覽器怎麼渲染和縮放網頁畫面的的大小。</p><p>比較詳細的語法介紹：<br><a href="https://www.fooish.com/html/meta-viewport.html">html viewport meta 淺見及說明</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端相關 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day30 - 結束與開始的序言</title>
      <link href="/2022/10/15/JS30/"/>
      <url>/2022/10/15/JS30/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Vic，目前已經寫到鐵人賽的最後一天，過程中受到很多好人的幫助指點，讓我獲得了不放棄的勇氣，今年的鐵人賽無論結果如何，我覺得至少我自己已經做到了堅持，而這不是單單靠我一個人就辦得到，是遇到了一堆好人後最終產生的結果，所以在開頭想感謝所有幫助過我的人事物。</p><p>感謝好想工作室的這個環境，感謝給我建議跟指點的每個朋友，也感謝團體賽中每個夥伴的互相包容，因為雖然當了團長，但我其實連自己都顧不太來，所以很多時候沒時間去關心其他人的進度，能夠順利平安結束真的是太好了。</p><p>這次的鐵人賽文章會同步發佈於:</p><p><a href="https://yoshuu.github.io/">我的部落格</a></p><p>接著就進入最後一次的序言時間。</p><h2 id="預想與實際"><a href="#預想與實際" class="headerlink" title="預想與實際"></a>預想與實際</h2><p>我是一個不囤稿派的。</p><p>我的想法是鐵人的精神就是要藉由每天迫使自己的產出，排除萬難來達成挑戰，藉此來磨練自身意志力，培養出持之以恆的習慣，若是通通都先寫好了，不過就只是一個無情的發文機器人，每天時間到就發，發完就去做其他事情，磨練在哪裡，鐵人精神又在哪裡，所以我都沒有準備文章。</p><p>只有一個念頭是，我應該從困難的開始寫，我有注意到之前鐵人賽其他參加者的狀況，很多半途而廢的人，蠻多有一個共同點，都是從簡單的開始寫，寫到後面開始越寫越難，最終很多人就選擇了放棄。</p><p>我就想說，假如我先把系列最難的部分給寫完了，那後面不就是越來越輕鬆？<br>一種倒吃甘蔗的概念，於是我興奮的想著，那我一開始就要直接先來寫我覺得 JS 中最難理解的<code> Prototype</code>、<code>class</code>，還有<code>this</code> 跟<code>Promise</code>，那時就這樣描繪著開賽後的美好藍圖，一邊等待著鐵人賽的開賽。</p><p>就如同第一天文章寫的，我的預想如下：<br><img src="https://i.imgur.com/6A4thlg.png"></p><p>有著這些想法的我，在開始沒多久，就被現實的鐵拳打得眼冒金星。</p><p>計畫總是趕不上變化，鐵人賽開始前一天被交付了一個專案，那是個我不能放棄的機會，意味著大半時間要花在那上面，還有兩個正在持續進行的讀書會，那時每週一、三、五都要花兩小時參與讀書會，鐵人賽時間還有幾場需要導讀，真是壓力山大，本來還想在鐵人賽過程中再撥一些時間來完成我的 JS30 練習跟 todolist 練習，不過從我的第二天的鐵人賽文章寫到半夜都發不出來後，我就抹滅掉了這些想法。</p><p>後來剛開始的幾天，我發現我完全低估了每天發文的壓力，沒有整天的時間可以寫文章，跟害怕寫不出來的話會害得所有團賽的夥伴都一起失去團賽資格，恐懼與壓力交織堆疊，前面二十天大概是最痛苦的時候，中間還病倒休息半天差點文章完蛋，那陣子很懷念床，因為沒機會躺都在桌上睡覺，但那時每個禮拜會去全家買好好吃的買一送一霜淇淋，所以某種程度來說有取得一種平衡。</p><p>進入狀況後，會藉由捨棄掉一些不重要的東西，以及請別人幫忙當團長的小幫手，幫我注意其他人狀況，替我省下了不少時間，也發現到人的時間就像是牙膏一樣，想擠的時候還是多少能擠出來，不要小看人的潛力，寫這篇文章時，案子差不多進入結案階段，最困難的階段已經撐過去，真是開心。</p><p>雖然預想跟實際的狀況不太一樣，但整體上還是蠻順利的，如果問我說下次參加鐵人賽還會不會不囤稿，我的選擇會還是一樣，因為我是不囤搞派。</p><h2 id="結束與開始"><a href="#結束與開始" class="headerlink" title="結束與開始"></a>結束與開始</h2><p>就如標題所講的，這是一段結束與開始的序言，鐵人賽結束的同時，一些事情也隨之跟著開始，在下個階段開始之前，</p><p>我想去躺在我的床上睡個沒有壓力的好覺，然後去剪頭髮跟刮鬍子，整理這段時間所學習到的心得記錄下來，然後把自己的作息給調整回來。</p><p>而主題介紹的那個問句，<br><strong>鐵人賽完賽後就真的能往前邁進嗎？</strong></p><p>對現在已經快做完這一場挑戰的我來說，答案是肯定的，向前邁進的意思不意味著已經寫得很完美，我不覺得我這次系列的文章寫的有多好，但不是只有成功了才是有進步的。</p><p>我接受了挑戰，在我能力所及的範圍內，努力做到了最好，那麼不管結果如何，我覺得自己就已經往前邁進了，我沒辦法說自己已經比誰誰誰厲害，但我可以說下次寫的文章，一定會比之前寫的還要好。</p><p>這次的結束不是結束，而是下一個階段的開始，期許自己能變得更卓越，變成像是別人幫助我那樣，我也可以幫助其他人。</p><p>那就準備新的開始吧，三十天的 JS 之路，落幕<img src="/images/emoticon/emoticon29.gif" alt="/images/emoticon/emoticon29.gif"></p><h2 id="友情推薦"><a href="#友情推薦" class="headerlink" title="友情推薦"></a>友情推薦</h2><p>最後我想分享一些邦友的系列文來結束我今年的鐵人賽，推薦大家可以去看～<br>每篇都是用心撰寫的好文。</p><blockquote><ul><li><p>幫助 vue 新手認識 vue3 及避開各種的坑 &#x3D;&gt; <a href="https://ithelp.ithome.com.tw/users/20152606/ironman/5782">真的好想離開 Vue 3 新手村 feat. CompositionAPI</a></p></li><li><p>搭配 ECMAScript 讓你從另外一個角度看 Array method! &#x3D;&gt; <a href="https://ithelp.ithome.com.tw/users/20152459/ironman/5744">咩色用得好，歸剛沒煩惱 - 從 ECMAScript 偷窺 JavaScript Array method </a></p></li><li><p>手把手帶你練習 PixiJS 語法 &#x3D;&gt; <a href="https://ithelp.ithome.com.tw/users/20152526/ironman/5741">PixiJS 青銅玩家</a></p></li><li><p>利用學習的撞牆經驗讓你了解前端技術 &#x3D;&gt; <a href="https://ithelp.ithome.com.tw/users/20152424/ironman/5659">前端蛇行撞牆記</a></p></li><li><p>從零重新帶你認識 JS 一遍 &#x3D;&gt; <a href="https://ithelp.ithome.com.tw/users/20145552/ironman/5213">[學習筆記] 邊學邊寫 JavaScript 30 天</a></p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day29 - Destructuring assignment(解構賦值)</title>
      <link href="/2022/10/14/JS29/"/>
      <url>/2022/10/14/JS29/</url>
      
        <content type="html"><![CDATA[<p>解構賦值是 es6 之後出來的一個新語法，我的理解它是一種語法糖，語法糖意思也就是說它可以用更簡單的方式達到相同的效果。</p><p>至於它究竟解構了什麼？<br>其實就是陣列或是物件裡面的值，原本我們假如要取出陣列跟物件裡面的值，可能會這樣來寫：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 陣列的情況</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> goodNum = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我想要取出裡面的數字，各個分別取出來</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = goodNum[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> two = goodNum[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> three = goodNum[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> four = goodNum[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(one, two, three, four); <span class="comment">// 10 20 30 40</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 物件的情況</span></span><br><span class="line"><span class="keyword">const</span> goodFruit = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;西瓜&quot;</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&quot;green&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我希望把個別key內中的value給取出來</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = goodFruit.<span class="property">name</span>;</span><br><span class="line"><span class="keyword">const</span> color = goodFruit.<span class="property">color</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, color); <span class="comment">// 西瓜 green</span></span><br></pre></td></tr></table></figure><p>但如果使用解構賦值的話，取用的方式就會變得稍微有些不同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 陣列使用了解構取值的情況</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> goodNum = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我想用a,b,c,d 這四個變數去取到這些從陣列之中解構出來的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [one, two, three, four] = goodNum;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(one, two, three, four); <span class="comment">// 10 20 30 40</span></span><br></pre></td></tr></table></figure><p>原本取出值之前，還需要宣告變數的部分取消了，直接可以把陣列裡面的值給解構出來變成一個獨立的變數。</p><p>左邊陣列裡面變數會把右邊陣列裡面的值給裝起來。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 物件使用了解構賦值的情況</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> goodFruit = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;西瓜&quot;</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&quot;green&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; name, color &#125; = goodFruit;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, color); <span class="comment">// 西瓜 green</span></span><br></pre></td></tr></table></figure><p>物件的解構方式會有一些不一樣的地方，就是因為有 key 及 value 的關係，所以為了確定可以成功獲取物件裡面的 key 的 value，所以一定要是跟它一模一樣的 key 才能取到，跟陣列相比會有這種限制，如果用自創的變數來試圖取，沒辦法只依靠位置獲得。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> goodFruit = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;西瓜&quot;</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&quot;green&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; aaa, bbb &#125; = goodFruit;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aaa); <span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bbb); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>會發現抓不到東西，沒有相對應的 value 值，所以會出現 undefined。</p><p>這邊會發現陣列跟物件在解構上的順序會有所差別，陣列的話會去依照它的索引值去抓取，而物件的話會依照物件的屬性名稱也就是 key 值來抓取，這是這兩者之間的差別。</p><p>上方講的一些基礎的方法，再來會介紹一些陣列跟物件一些特別的用法。</p><h2 id="Array-Destructuring"><a href="#Array-Destructuring" class="headerlink" title="Array Destructuring"></a>Array Destructuring</h2><p>因為陣列會照著索引值來去一個個抓值，所以當其中有想要跳過的部分時，會沒辦法直接跳過，所以可以利用空格的技巧，跳過那個索引值不需要的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//陣列的忽略某些值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, , b] = <span class="title function_">f</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/VIPLgOg.png"></p><p>解構賦值也可以拿來做陣列的變數交換。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//陣列的變數交換</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">[arr[<span class="number">2</span>], arr[<span class="number">1</span>]] = [arr[<span class="number">1</span>], arr[<span class="number">2</span>]];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/t6KC1nF.png"></p><p>陣列遇到字串時如果解構會自動變成字元的樣子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遇到字串會解構成字元</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;床前明月光&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = str;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/a952CKd.png"></p><h2 id="Object-Destructuring"><a href="#Object-Destructuring" class="headerlink" title="Object Destructuring"></a>Object Destructuring</h2><p>剛剛有提到說，因爲物件的解構是看 key 的值，所以如果直接在外部去定義子己想要設定的變數名，會找不到，但還是有需要自己定義變數名稱的場景，這時候可以利用在取變數時，在那邊 key 值旁邊增加一個<code>：</code>寫變數名稱的方式，來達到說改變變數名稱的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新賦予變數名稱</span></span><br><span class="line"><span class="keyword">let</span> value = &#123;</span><br><span class="line">  aaa : <span class="number">111</span>,</span><br><span class="line">  bbb : <span class="number">222</span>,</span><br><span class="line">  ccc : <span class="number">333</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">aaa</span>: apple &#125; =value</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Pq9e07M.png"></p><p>另外如果是物件需要預設值的狀況，直接在變數那邊使用等於就好，這點陣列也是相同的。</p><p>陣列預設值：<br><img src="https://i.imgur.com/3EMhoNv.png"></p><p>物件預設值：<br><img src="https://i.imgur.com/VuU8GVt.png"></p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><ul><li>解構賦值能夠減少很多重複性的事情，也能提高代碼整體的可讀性</li><li>陣列跟物件的解構賦值取值順序不同，陣列是看索引值，物件則是屬性名稱</li><li>除了順序之外陣列跟物件所用的括號也不一樣，一個是中括號，一個是大括號</li></ul><p>大家也多多使用解構賦值的方式來取值吧！明天將會進入這次鐵人賽的最終章。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">MDN - Destructuring assignment</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day28 - Currying (柯里化)</title>
      <link href="/2022/10/13/JS28/"/>
      <url>/2022/10/13/JS28/</url>
      
        <content type="html"><![CDATA[<p>柯里化是一個函數的運用技術，不只是<code>JavaScript</code>裡面，它可以運用在很多的地方，簡單來說就是幫忙做了轉換。</p><p>原本的函式可能是長這樣的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fnc</span>(A, B, C);</span><br></pre></td></tr></table></figure><p>柯里化後會變成這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fnc</span>(A)(B)(C);</span><br></pre></td></tr></table></figure><p>這兩種方式最後出來的結果都是會一樣的，而怎麼實現的等等就會提到，<br>今天會從幾個角度介紹這個主題 &#x3D;&gt;</p><ul><li>介紹與原理</li><li>目的與好處</li></ul><h2 id="介紹與原理"><a href="#介紹與原理" class="headerlink" title="介紹與原理"></a>介紹與原理</h2><p>柯里化主要的用途是用來簡化呼叫函式的過程，像是說把呼叫 f(a,b)變成呼叫 f(a)以及 f(b)，<br>就可以達成說，把一個很多參數的函式，切分成很多只有一個參數的函式。</p><p>舉例來說：<br>這是一個簡單的相加，它是一個有很多參數的函式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">plus</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">plus</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">//印出6</span></span><br></pre></td></tr></table></figure><p>使用柯里化的方式改寫，讓它變成很多只有一個參數的函式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">plus</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">c</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性的呼叫多個</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">plus</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">//印出6</span></span><br></pre></td></tr></table></figure><p>使用柯里化的方式後，可以一次性的呼叫多個，也可以讓最後只呼叫一個參數</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">plus</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">c</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> plusThree = <span class="title function_">plus</span>(<span class="number">1</span>)(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最後呼叫裡面只放一個參數</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">plusThree</span>(<span class="number">3</span>)); <span class="comment">//印出6</span></span><br></pre></td></tr></table></figure><p>其實最主要的概念就是這樣而已，這邊要記得兩件事情</p><ul><li>柯里化不會去呼叫函式，只會對函式進行轉換</li><li>柯里化一次只會接受一個參數</li></ul><p>而柯里化其實是藉由把函式當作參數，帶到另一個參數之中，讓傳遞到的最後一個函式回傳之前所有的結果。</p><h2 id="目的與好處"><a href="#目的與好處" class="headerlink" title="目的與好處"></a>目的與好處</h2><p>可以用來拆分程式碼，把比較重要的部分給保留，固定住一部分，只要改另外一部分就好，不用每次都全部寫出來。</p><p>比如說如果兩個數字需要相乘：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次都需要填入兩個參數，但如果今天假如第一個數字是固定時，使用柯里化的方式就能夠，只填入一個參數達到相同的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">multiply</span> = (<span class="params">num</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * x;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multiplyByTwo = <span class="title function_">multiply</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiplyByTwo</span>(<span class="number">1</span>)); <span class="comment">//10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiplyByTwo</span>(<span class="number">2</span>)); <span class="comment">//20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiplyByTwo</span>(<span class="number">3</span>)); <span class="comment">//30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiplyByTwo</span>(<span class="number">4</span>)); <span class="comment">//40</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiplyByTwo</span>(<span class="number">5</span>)); <span class="comment">//50</span></span><br></pre></td></tr></table></figure><p>不僅是減少重複的寫入，提高複用性，整體看起來的可讀性也會跟著上升。</p><p>同時也代表著不用在想著要傳入多少參數，一次就只要專心地傳遞一個，出現錯誤時可以更好的找出問題所在，那麼今天就介紹到這邊，明天見～</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://en.wikipedia.org/wiki/Currying">Currying - Wikipedia</a><br>[2] <a href="https://ithelp.ithome.com.tw/articles/10236374">Currying</a><br>[3] <a href="https://www.cythilya.tw/2017/02/27/currying-in-javascript/">Currying in JavaScript（柯里化）</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day27- JSON Methods(JSON 方法)</title>
      <link href="/2022/10/12/JS27/"/>
      <url>/2022/10/12/JS27/</url>
      
        <content type="html"><![CDATA[<p>今天要來介紹<code>JSON</code>的兩個靜態方法：</p><ul><li>JSON.parse()</li><li>JSON.stringify()</li></ul><p>會從什麼是<code>JSON</code>開始介紹起，直接開始吧。</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p><code>JSON</code>的全名是<code>JavaScript Object Notation</code>，它是一種輕量型的數據交換格式，就是可以用來儲存跟方便傳遞的一種格式，跟物件的樣子很像，但其實不太一樣，會有著<code>JSON</code>的出現，主要還是單純物件的話，還不夠簡單跟容易閱讀。</p><p>跟使用物件的格式有一些差別。</p><p>第一<code>JSON</code>它只能用雙引號，不能用單引號，不論是<code>key</code>還是<code>value</code>，物件沒有這種限制，可以用單引號，甚至<code>key</code>不要加引號也沒有關係。</p><p>第二<code>JSON</code> 支持 <code>object</code>、<code>array</code>、<code>string</code>、<code>number</code>、<code>boolean</code> 和 <code>null</code>，基本上除了<code>undefined</code>之外其他全包了。</p><p>不過雖然支持，但是大部分的<code>JavaScript</code>都不是<code>JSON</code>，主要原因還是上面第一點，不論是<code>key</code>還是<code>value</code>都需要雙引號。</p><p>簡單說，<code>JSON</code> 是用來表示在<code>JavaScript</code>物件的一種格式，比單純的物件格式更好閱讀，有更高的相容性。</p><p><code>JSON</code>的範例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;fruit&quot;:[</span><br><span class="line">  &#123;&quot;fruitName&quot;:&quot;apple&quot;, &quot;customer&quot;:&quot;Rex&quot;&#125;,</span><br><span class="line">  &#123;&quot;fruitName&quot;:&quot;banana&quot;, &quot;customer&quot;:&quot;Vic&quot;&#125;,</span><br><span class="line">  &#123;&quot;fruitName&quot;:&quot;orange&quot;, &quot;customer&quot;:&quot;Dan&quot;&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h2><p>當想把<code>JSON</code>轉換成物件的時候，可以使用的一個方法。</p><p>可以用型別的方式去想像，從<code>string</code>轉換成<code>object</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> one = <span class="string">&quot;[1,1,1,1,1,1]&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> one); <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line">one = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(one);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> one); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h2><p>當想把物件轉換成<code>JSON</code>的時候，可以使用的一個方法。</p><p>型別來說的話，是從<code>object</code>轉換成<code>string</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruit = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;apple&quot;</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">  <span class="attr">delicious</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">customer</span>: [<span class="string">&quot;vic&quot;</span>, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;while&quot;</span>],</span><br><span class="line">  <span class="attr">price</span>: <span class="string">&quot;1000&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> fruit); <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line">fruit = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(fruit);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> fruit); <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p>但是有一些特別的地方。<br>不是總是能轉換成<code>string</code>，只能確定<code>object</code>會轉換成<code>string</code>，其他假如像是數字或是布林，那經過<code>JSON.stringify()</code>也不會發生改變。</p><p>用 10 來轉換的話，數字還是數字，不會變成”10”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="number">10</span>)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>字串的話轉換還是字串，只是單引號會變成雙引號。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="string">&quot;apple&quot;</span>)); <span class="comment">// &quot;apple&quot;</span></span><br></pre></td></tr></table></figure><p>陣列轉換出來還是陣列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])); <span class="comment">// [1,1,1]</span></span><br></pre></td></tr></table></figure><p>布林值轉換出來還是布林值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="literal">false</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>但以上這些去觀察它們的型別會發現通通都還是<code>string</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="number">10</span>)); <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="string">&quot;apple&quot;</span>)); <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])); <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="literal">false</span>)); <span class="comment">// string</span></span><br></pre></td></tr></table></figure><h2 id="JSON-parse-JSON-stringify"><a href="#JSON-parse-JSON-stringify" class="headerlink" title="JSON.parse() + JSON.stringify()"></a>JSON.parse() + JSON.stringify()</h2><p>可以把一個物件，把它轉換成<code>JSON</code>，再轉換回來。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> programmer = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;vic&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> programmer2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(programer));</span><br></pre></td></tr></table></figure><p>這舉動看似毫無意義，但其實非常有用。</p><p>利用這個方式，可以達到物件的深拷貝。</p><p>拷貝的意思是複製一個東西出去，拷貝出來的那個東西，不會影響到原來的東西。</p><p>正常來說物件因為是傳址的緣故，所以如果只是單純的 A &#x3D; B 這種賦值，是沒辦法達到拷貝的效果，這樣改 B 就會改到 A。</p><p>物件想要獲得拷貝的效果，有幾種方式可以達成。</p><p>一種是使用<code> Object.assign</code>的方式，<br>也可以使用 <code>spread operator</code>的方式去進行物件的拷貝。</p><p>但這種方式其實也只能保持，物件的複製一層的效果，要是再更改到裡面的層，會發現說還是會有改 B 就改到 A 的現象，所以會把這兩種方式稱之為淺拷貝，有拷貝的效果，但是只有表層有。</p><p>而<code>JSON.parse() + JSON.stringify()</code>卻是深拷貝，用了這個方式，就可以達成說物件複製後完全不會改變到原來的物件，這也是我唯一知道的深拷貝方式。</p><h2 id="最後"><a href="#最後" class="headerlink" title="最後"></a>最後</h2><p>前面有提到說，今天介紹的這兩個方法都是屬於靜態方法，那會有動態方法嗎？</p><p>其實在<code>JSON</code>之中，就只有動態方法的存在，不只是方法，<code>JSON</code>的所有屬性跟方法都是靜態的。</p><p>關於要如何區分，可以這樣理解，動態方法是需要要先創建實例才能使用，而靜態方式就直接使用就可以，像是<code>Math</code>，我們可以直接從<code>JavaScript</code>去做取用，不用再<code>new</code>出一個實例。</p><p>而動態方式就像是<code>date</code>還需要先<code>new Date</code>之後，才能去使用它底下的方法。</p><p>在<code>JSON</code>中的所有方法通通都是靜態的，代表說都可以直接取用，同時也沒有辦法。</p><p>因為<code>JSON</code>不是一個構造函式，所以也沒辦法使用<code>new</code>，那麼今天對<code>JSON Methods</code>介紹就到這邊，明天見～</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON">MDN - JSON</a><br>[2] <a href="https://www.w3schools.com/js/js_json.asp">W3C - JavaScript JSON</a><br>[3] <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/JSON">MDN - Working with JSON</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day26 - Strict Mode(嚴格模式)</title>
      <link href="/2022/10/11/JS26/"/>
      <url>/2022/10/11/JS26/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>JavaScript</code>的嚴格模式，如其名會讓程式碼的檢視變的嚴格，嚴格意味著不讓你錯，寫起來會更加安全嚴謹。</p><p>今天會照以下幾個角度來講解：</p><ul><li>嚴格模式由來</li><li>使用方式</li><li>禁止事項</li><li>使用情境</li></ul><h2 id="嚴格模式由來"><a href="#嚴格模式由來" class="headerlink" title="嚴格模式由來"></a>嚴格模式由來</h2><p><code>JavaScript</code>寫法規則相對來說不嚴謹，像是弱型別的轉換特性，就算沒有寫清楚，<code>JavaScript</code>也會自動幫忙補完，不會報錯，好處是很容易上手，不會被一大堆語法的限制給綁手綁腳，不過同時壞處也是十分明顯的，有時候寫錯也不會報錯，那麼將會很難避免一堆潛在錯誤，在寫的時候也完全發現不了。</p><p>為了應付這種狀況，<code>JavaScript</code>在 2009 年 ECMAScript5 有新推出了這個叫做<code>Strict Mode</code>的語法，創造出一個模式，是很嚴格嚴謹的，提供一個給開發者改善上述提到不嚴謹導致出錯的問題，讓開發者可以自由選擇。</p><p>舉例來說，在嚴格模式下，沒有辦法使用一個沒有宣告的變數。</p><p>沒有嚴格模式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apple = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(apple); <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>使用了嚴格模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line">apple = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(apple); <span class="comment">//ReferenceError</span></span><br></pre></td></tr></table></figure><p>接下來介紹在<code>JavaScript</code>要如何使用。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>要讓程式知道是嚴格模式的話，首先要加上這段指令：<br><code>&quot;use strict&quot;;</code></p><p>假如說是放在程式碼的最前面，會使整個<code>JavaScript</code>的檔案都變成了嚴格模式。</p><p>而也可以只放在函式裡面，那麼就只有函式會生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="comment">// apple = 10;</span></span><br><span class="line">  <span class="comment">// console.log(apple);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A();</span></span><br><span class="line">apple = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(apple);</span><br></pre></td></tr></table></figure><p>函式外面的範圍就不會被嚴格模式給影響到，所以可以理解成嚴格模式有分成兩種的作用域。</p><p>一種是<code>Global Scope</code>，在程式的開頭宣告，那麼它將會有全局的範圍都會變成是嚴格模式。</p><p>另一種是<code>Function Scope</code>。</p><p>在函式的開頭宣告，那它只會存在於函式的{}裡面是嚴格模式。</p><p>另外假如不是在開頭宣告，那在宣告了<code>&quot;use strict&quot;;</code>之上的所有程式碼，都不會被嚴格模式影響到。</p><p>所以假如要使用嚴格模式的話，很重要的一點是確保<code>&quot;use strict&quot;;</code>出現在最頂部，不論是<code>Global Scope</code>或是<code>Function Scope</code>。</p><p>還有一個使用上要注意的小地方是，當使用<code>&quot;use strict&quot;;</code>之後，就沒辦法取消，沒有指令可以再返回沒有<code>&quot;use strict&quot;;</code>的狀態，所以假如用了嚴格模式後，不想要使用了，就只能在當初寫的<code>&quot;use strict&quot;;</code>給刪除或是註解掉。</p><h2 id="禁止事項"><a href="#禁止事項" class="headerlink" title="禁止事項"></a>禁止事項</h2><p>除了上面有提到過的沒宣告的變數沒辦法使用之外，如果變成了嚴格模式將會有這些限制：</p><ul><li>不能使用 delete 刪除變數或是函式</li></ul><p>刪變數 &#x3D;&gt;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> apple = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">delete</span> apple; <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><p>刪函式 &#x3D;&gt;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">apple</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> apple; <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><ul><li>不能重複參數名稱</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">apple</span>(<span class="params">A, A</span>) &#123;&#125; <span class="comment">//SyntaxError</span></span><br></pre></td></tr></table></figure><ul><li>不能使用八進制數字</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> apple = <span class="number">010</span>; <span class="comment">//SyntaxError</span></span><br></pre></td></tr></table></figure><ul><li>不能使用<code>eval</code>跟<code>arguments</code>當變數名稱</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">const eval = 10; // SyntaxError</span><br><span class="line">const arguments = 10; // SyntaxError</span><br></pre></td></tr></table></figure><ul><li>不能使用<code>with</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">with</span> (<span class="title class_">Math</span>) &#123;</span><br><span class="line">  x = <span class="title function_">cos</span>(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><ul><li><p>以下的關鍵字為了將來版本的保留，所以在嚴格模式下也通通不能拿來當變數名稱：<br>implements、interface、let、package、private、protected、public、static、yield</p></li><li><p>嚴格模式時，this 的預設狀態都會指向<code>undefined</code></p></li></ul><table><thead><tr><th></th><th>瀏覽器環境</th><th>node.js 環境</th></tr></thead><tbody><tr><td>嚴格模式</td><td>undefined</td><td>undefined</td></tr><tr><td>非嚴格模式</td><td>window</td><td>global</td></tr></tbody></table><h2 id="使用情境"><a href="#使用情境" class="headerlink" title="使用情境"></a>使用情境</h2><p>什麼時候會用到，該不該去使用嚴格模式，我的看法是要是一個專案或者是程式碼已經很龐大了，也許可以先從<code>Function Scope</code>的方式去使用嚴格模式，因為假如在一個專案中直接改成嚴格模式的話，可能會直接無法運作且一時之前有點難改完。</p><p>而在寫程式的一開始就直接使用嚴格模式就不會有這個問題，而且也會幫助養成好習慣，寫出來的程式碼也會好維護，而有些新的結構其實就內建了嚴格模式，像是之前有講到過的<code>class</code>，以及<code>module</code>，使用它們的時候沒有設定嚴格模式也會有嚴格模式的效果。</p><p>關於嚴格模式的介紹就到這邊，各位明天見。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">MDN - Strict Mode</a><br>[2] <a href="https://www.w3schools.com/js/js_strict.asp">W3C - JavaScript Use Strict</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day25 - Arrow Function (箭頭函式)</title>
      <link href="/2022/10/10/JS25/"/>
      <url>/2022/10/10/JS25/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天要來介紹什麼是<code>Arrow Function</code>，這個是一個看起來非常簡單的語法，因為<code>=&gt;</code>就像是箭頭一樣所以叫做<code>Arrow Function</code>，它可以直接把函式的建立變成簡化版，看起來像是這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">arrow</span> = (<span class="params">a, b</span>) =&gt; a + b;</span><br></pre></td></tr></table></figure><p>會叫做<code>Arrow Function</code>也是因為<code>=&gt;</code>就像是一個箭頭的關係，雖然看起來很簡單，但其實我自己在寫時常常忘記怎麼寫,利用這次寫文章的機會來複習一下。</p><h2 id="過去與現在"><a href="#過去與現在" class="headerlink" title="過去與現在"></a>過去與現在</h2><p><code>Arrow Function</code>是 es6 之後才出來的新語法，意味著在此之前都是只能用以下這些方式。</p><p>一般做法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">past</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;過去做法&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">past</span>()); <span class="comment">// 過去做法</span></span><br></pre></td></tr></table></figure><p>匿名做法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> past = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;過去做法&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">past</span>()); <span class="comment">// 過去做法</span></span><br></pre></td></tr></table></figure><p>es6 之前只能用上面那兩種方式，之後多了一種箭頭函式可用。</p><p>而箭頭函式有點像是匿名的進階版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">now</span> = (<span class="params"></span>) =&gt; <span class="string">&quot;箭頭函式做法&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">now</span>()); <span class="comment">// 箭頭函式做法</span></span><br></pre></td></tr></table></figure><p>省略了很多東西變成了匿名更短的版本，最主要的變化以上面那個例子來看：</p><ol><li>省略了<code>function</code></li><li>省略了大括號 <code>&#123;&#125;</code></li><li>省略了寫<code>return</code></li></ol><p>但其實不是每一次都可以省略那麼多，還是需要看狀況，以下就介紹箭頭函式的語法以及使用情境。</p><h2 id="寫法注意事項"><a href="#寫法注意事項" class="headerlink" title="寫法注意事項"></a>寫法注意事項</h2><p>關於省略<code>function</code>的部分，只要用了<code>=&gt;</code>，那就代表說<code>function</code>不用寫，目前還沒遇到非寫不可的狀況，假如直接多寫的話還會報錯。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> A = <span class="keyword">function</span>(<span class="params"></span>) =&gt; <span class="string">&quot;A&quot;</span>; <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><p>而<code>&#123;&#125;</code>則是需要跟<code>return</code>綁在一起來做說明。</p><p>可以理解成，有<code>return</code>就一定要用<code>&#123;&#125;</code>，不能直接使用<code>return</code>，而單獨使用<code>&#123;&#125;</code>時，箭頭函式也不會自動幫忙<code>return</code>，這點要注意。</p><p>可以省略的情境是如果函數只有一個語句，而且只回傳一個值的時候，<code>&#123;&#125;</code>跟<code>return</code>就可以同時被省略，比如說像是這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">A</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">A</span>()); <span class="comment">// A</span></span><br></pre></td></tr></table></figure><p>可以變成這樣:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">A</span> = (<span class="params"></span>) =&gt; <span class="string">&quot;A&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">A</span>()); <span class="comment">// A</span></span><br></pre></td></tr></table></figure><p>省略時，不就代表沒有作用，會變成箭頭函式自動幫忙做，所以其實還是會有<code>&#123;&#125;</code>跟<code>return</code>的效果。</p><p>而帶參數的那個小括號其實也是可以被省略的。</p><p>省略的情境是只有一個參數時：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">A</span> = (<span class="params">a</span>) =&gt; a + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">A</span>(<span class="number">5</span>)); <span class="comment">// A</span></span><br></pre></td></tr></table></figure><p>只有一個參數的箭頭函式實際上就可以把那個小括號直接省略掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">A</span> = (<span class="params">a</span>) =&gt; a + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">A</span>(<span class="number">5</span>)); <span class="comment">// A</span></span><br></pre></td></tr></table></figure><p>但不是所有情況都可以省略小括號，當不只有一個參數，或是根本沒有參數的時候，小括號就沒有辦法去省略。</p><h2 id="用法限制"><a href="#用法限制" class="headerlink" title="用法限制"></a>用法限制</h2><p>箭頭函式雖然很方便，但還是有許多情境只能依靠傳統函式才能做到。</p><p>像是說在箭頭函式是沒有自己的<code>this</code>跟<code>arguments</code>跟<code>super</code>，因為沒有自己的<code>this</code>代表說需要去找它時，只能夠從外部去獲取。</p><p>而沒有自己的<code>this</code>也表示說，箭頭函式不能當作構造函式來用，也沒辦法使用<code>new</code>來調用它們，同時也不適用 <code>call</code>跟<code>apply</code>跟<code>bind</code>的方法。</p><p>所以還是可以用<code>this</code>，只是跟傳統函式不一樣，不是由呼叫的方式來綁定，所以<code>this</code>的方法沒辦法使用。</p><p>最後箭頭函式也無法作用於生成器函式使用(generator function)，不能使用<code>yield</code>這個關鍵字。</p><p>可以發現說箭頭函式雖然遠比傳統函式來得方便許多，但同樣限制也很多，不能在所有的情況下使用，所以假如有箭頭函式很方便，那就全部都用箭頭函式這種想法的話，是行不通的。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>透過箭頭函式的各種省略，可以使用更短的語法寫出一樣的效果，不只會讓整體的程式碼看起來很精簡，可讀性也會跟著增加，是我覺得好處多於壞處的一個語法，只是要注意有些情境沒辦法使用，總之建議適量的在程式碼中使用，讓程式碼便得簡潔乾淨吧！</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">MDN - Arrow function expressions</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day24 - nullish coalescing operator (空值合併運算子)</title>
      <link href="/2022/10/09/JS24/"/>
      <url>/2022/10/09/JS24/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前講的是常用的邏輯運算子，而有一個比較特別的，寫法是兩個問號。<br>之前看不太懂，趁著今天研究出來順便寫自己的理解，接下來就直接開始。</p><h2 id=""><a href="#" class="headerlink" title="??"></a><code>??</code></h2><p>根據 MDN 的解釋，當左邊的值是<code>null</code>或是<code>undefined</code>時，會回傳右邊的值，假如不是<code>null</code>或是<code>undefined</code>就會回傳左邊的值。</p><p>還記得前天講的<code>||</code>嗎？</p><p><code>||</code>是碰到第一個真值就回傳。</p><p>而當一個值，如果它不是<code>null</code>也不是<code>undefined</code>，那它就會是<code>defined</code>，意思是一個已經定義的值。</p><p>所以<code>||</code>跟<code>??</code>來做比較的話：</p><ul><li><code>??</code>會回傳第一個已經定義的值</li><li><code>||</code>會回傳第一個遇到的真值(true)</li></ul><p>來試試看 &#x3D;&gt;</p><p>左邊是<code>null</code>時，會回傳右邊的值，左邊不是<code>null</code>或是<code>undefined</code>，就會直接回傳左邊的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> ?? <span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">50</span> ?? <span class="literal">null</span>); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure><p>MDN 只有說左右兩側，測試看看假如兩組值以上的狀況。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> ?? <span class="literal">null</span> ?? <span class="number">100</span> ?? <span class="number">50</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">50</span> ?? <span class="literal">null</span> ?? <span class="literal">null</span> ?? <span class="number">100</span>); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure><p>也是一樣效果，會回傳第一個已經定義的值，讓我想到一個問題，如果全部都沒有定義的值呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> ?? <span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span> ?? <span class="literal">null</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>結果來看會回傳最後一個沒定義的值。</p><p>還有就是 MDN 裡面有提到說，不能跟<code>||</code>及<code>&amp;&amp;</code>共用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> ?? <span class="string">&quot;1&quot;</span> || <span class="literal">null</span>); <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> ?? <span class="string">&quot;2&quot;</span> &amp;&amp; <span class="literal">null</span>); <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><p>把目前的資訊整理一下。</p><p><code>??</code>主要用來邏輯判斷定義的值及未定義的值。</p><p>要是遇到第一個已經定義的值就直接回傳，否則就一直向右尋找，要是都沒有的話，就回傳最後一個未定義的值，然後不能跟其他邏輯運算子共用。</p><h2 id="使用情境"><a href="#使用情境" class="headerlink" title="使用情境"></a>使用情境</h2><p>可以用在需要提供默認值的場合。</p><p>比如說，如果<code>fruit</code>的值不是不是<code>null</code>也不是<code>undefined</code>，就會顯示<code>fruit</code>的值，不然就顯示字串<code>水果</code>。</p><p>在這裡字串<code>水果</code>就是<code>fruit</code>的默認值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruit = <span class="string">&quot;蘋果&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruit ?? <span class="string">&quot;水果&quot;</span>); <span class="comment">// 蘋果</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruit = <span class="literal">undefined</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruit ?? <span class="string">&quot;水果&quot;</span>); <span class="comment">// 水果</span></span><br></pre></td></tr></table></figure><p>假如今天有一家水果店，開放標一顆蘋果，就可以利用<code>??</code>來判斷是誰搶到了，不買的人就用<code>null</code>表示，會按照順序問下去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> first = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> second = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> third = <span class="string">&quot;Angela&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first ?? second ?? third ?? <span class="string">&quot;流標&quot;</span>); <span class="comment">// Angela</span></span><br></pre></td></tr></table></figure><p>有人可能會問說，那幹嘛不用<code>||</code>就好？</p><p>依據碰到第一個真值就回傳的特性，在上面的例子使用<code>||</code>結果也會完全一模一樣。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> first = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> second = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> third = <span class="string">&quot;Angela&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first || second || third || <span class="string">&quot;流標&quot;</span>); <span class="comment">// Angela</span></span><br></pre></td></tr></table></figure><p>這邊要先從發展的角度來說。</p><h2 id="過去的-，現在的"><a href="#過去的-，現在的" class="headerlink" title="過去的||，現在的??"></a>過去的<code>||</code>，現在的<code>??</code></h2><p><code>??</code>是很後期大約在<code>ES11</code>才出現的新語法，代表著是先有<code>||</code>，才有<code>??</code>的誕生。</p><p>而會有這種狀況的產生，我的理解是因為有些<code>||</code>沒辦法顧及的狀況，所以才需要有一個跟<code>||</code>很像但又不完全一樣的語法。</p><p>而這個答案其實前面就有暗示了。</p><p><code>||</code>會回傳<code>真值</code>，而<code>??</code>會回傳<code>已定義的值</code>。</p><p>這邊代表一件事情，那就是<code>||</code>只能判斷真值跟假值，也就是說，全部的假值都不會被回傳。</p><p>不論是<code>0</code>,<code>“”</code>,<code>NaN</code>,<code>null</code>,<code>undefined</code>，全部都不會被回傳。<br><code>||</code>沒有辦法區分它們。</p><p>這樣會造成很多麻煩的點在於，假如我今天想要的值就是<code>0</code>，那麼使用<code>||</code>將會沒辦法達到我想要預期的結果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scope = <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(scope || <span class="string">&quot;默認值&quot;</span>); <span class="comment">// 默認值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(scope ?? <span class="string">&quot;默認值&quot;</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>我的變數值想設定成<code>0</code>，但是會發現說使用<code>||</code>會沒有辦法顯示出來，會直接跳到默認值，因為對於<code>||</code>來說，<code>0</code>是假值，不會回傳。</p><p>但如果使用<code>??</code>就不會發生這種問題，它會先判斷是不是有定義的值，如果不是非定義的值(<code>null</code>,<code>undefined</code>)，那就會是有效值，就不會被替換成默認值了。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator">MDN - Nullish coalescing operator (??)</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day23 - Logical operators (邏輯運算子) AND、NOT篇</title>
      <link href="/2022/10/08/JS23/"/>
      <url>/2022/10/08/JS23/</url>
      
        <content type="html"><![CDATA[<p>今天來講昨天沒講完的兩個<code>Logical operators</code>。</p><ol><li>Logical AND (&amp;&amp;)</li><li>Logical NOT (!)</li></ol><h2 id="Logical-AND-amp-amp"><a href="#Logical-AND-amp-amp" class="headerlink" title="Logical AND (&amp;&amp;)"></a>Logical AND (&amp;&amp;)</h2><p>會用<code>&amp;&amp;</code>來判斷<code>&amp;&amp;</code>兩邊的值，最基本的判斷是兩邊只有<code>true</code>跟<code>false</code>值的話，全部為<code>true</code>才會是<code>true</code>，只要有一個<code>false</code>就會直接回傳成<code>false</code>。</p><p>舉例來說，假如小白他想要合法的騎車，他就必須滿足以下條件:</p><ol><li>滿 18 歲</li><li>獲得機車駕照</li><li>有一台車</li><li>有安全帽</li></ol><p>其中，假如有一項沒有達成也就是<code>false</code>，那麼最後的結果也會是回傳<code>false</code>，沒有辦法騎車。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目前狀況 = 已滿<span class="number">18</span>歲 &amp;&amp; 已有駕照 &amp;&amp; 已有車 &amp;&amp; 沒有安全帽;</span><br><span class="line"></span><br><span class="line">可以騎車嗎? =&gt; 不行</span><br></pre></td></tr></table></figure><p>同等於</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> condition = <span class="literal">true</span> &amp;&amp; <span class="literal">true</span> &amp;&amp; <span class="literal">true</span> &amp;&amp; <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(condition); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>而跟<code>||</code>一樣，有著操作的值不是一個「boolean」值，也會被轉換成一個「boolean」型態的特性。</p><h2 id="尋找第一個假值，找到就馬上回傳"><a href="#尋找第一個假值，找到就馬上回傳" class="headerlink" title="尋找第一個假值，找到就馬上回傳"></a>尋找第一個假值，找到就馬上回傳</h2><p><code>&amp;&amp;</code>在全部只有<code>true</code>跟<code>false</code>只有回傳這兩者其中之一很單純，但要是每一種的值都不一樣時，那回傳是哪一個呢?</p><p>答案是按照順序從左到右，遇到第一個<code>false</code>的值，就直接回傳，要是到了最右邊都沒有<code>false</code>的值，就會回傳最後一個的<code>true</code>。</p><p>來證明這件事情。</p><p>已知<code>1,2,3,4,5</code>都是<code>true</code>，<br>而 <code>0,null,undefined,&#39;&#39;</code>會是<code>false</code>。</p><p><strong>回傳第一個<code>false</code></strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> &amp;&amp; <span class="number">1</span> &amp;&amp; <span class="number">2</span> &amp;&amp; <span class="number">3</span> &amp;&amp; <span class="literal">null</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>第一個遇到的<code>0</code>就是<code>false</code>所以就會直接回傳，就算最後一個是<code>null</code>也不會碰到，從左到右的規則下，遇到<code>0</code>之後就停止比較了。</p><p>可以把<code>0</code>拿掉看看。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> &amp;&amp; <span class="number">2</span> &amp;&amp; <span class="number">3</span> &amp;&amp; <span class="literal">null</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>把<code>0</code>拿到之後，<code>null</code>就會變成最後一個<code>false</code>，所以會被回傳。</p><p><strong>回傳最後一個的<code>true</code></strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> &amp;&amp; <span class="number">2</span> &amp;&amp; <span class="number">3</span> &amp;&amp; <span class="number">4</span> &amp;&amp; <span class="number">5</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>從左到右都碰不到<code>false</code>直到最後一個的<code>5</code>，那麼就會把最後一個的<code>5</code>這個<code>true</code>的結果給回傳。</p><p>再試一組看看。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span> &amp;&amp; <span class="number">4</span> &amp;&amp; <span class="number">3</span> &amp;&amp; <span class="number">2</span> &amp;&amp; <span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>最後一個的<code>true</code>變成了<code>1</code>，且完全沒有<code>false</code>的值，所以會回傳<code>1</code>。</p><h2 id="Logical-NOT"><a href="#Logical-NOT" class="headerlink" title="Logical NOT (!)"></a>Logical NOT (!)</h2><p>我個人認為最好懂的<code>Logical operators</code>。</p><p>原理就是加上了一個<code>!</code>，<code>true</code>會變成<code>false</code>，<code>false</code>會變成<code>true</code>，一個反向的概念。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="literal">false</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>而對於不是「boolean」值的其他值，會變成反向的轉換成「boolean」型態。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="string">&quot;小白&quot;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="literal">null</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所以有一種用法，就是我想要把一個值，變成「boolean」值的時候，可以使用兩個<code>!</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="string">&quot;小白&quot;</span>); <span class="comment">// ture</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="literal">null</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>想要的話，也可以用很多很多個<code>!</code>，不過通常只會用到兩個，之後的效果也都一樣。</p><p>3 個<code>!</code> 同等於 1 個<code>!</code> 。</p><h2 id="優先級"><a href="#優先級" class="headerlink" title="優先級"></a>優先級</h2><p>首先，要是<code>||</code>跟<code>&amp;&amp;</code>跟<code>!</code>比較起優先順序，那麼<code>!</code>是最大的。</p><p>無論何時，<code>!</code>都會在<code>||</code>跟<code>&amp;&amp;</code>之前被執行。</p><p>就像是先乘除，後加減。<br>在邏輯運算子裡面是先 NOT，後其他操作。</p><p>其實還蠻合理的，沒有先用<code>!</code>轉完的話，根本沒辦法比較。</p><p>接下來是<code>||</code>跟<code>&amp;&amp;</code>。</p><p><code>&amp;&amp;</code>會比<code>||</code>更優先執行，在執行<code>||</code>會先把<code>&amp;&amp;</code>都解決。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">false</span> &amp;&amp; <span class="literal">true</span>) || (<span class="literal">false</span> &amp;&amp; <span class="literal">true</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>也可以看成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">false</span> &amp;&amp; <span class="literal">true</span>) || (<span class="literal">false</span> &amp;&amp; <span class="literal">true</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators">MDN - Expressions and operators</a><br>[2] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND">MDN - Logical AND (&amp;&amp;)</a><br>[3] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_NOT">MDN - Logical NOT (!)</a><br>[4] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN - Operator precedence</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day22 - Logical operators (邏輯運算子) OR篇</title>
      <link href="/2022/10/07/JS22/"/>
      <url>/2022/10/07/JS22/</url>
      
        <content type="html"><![CDATA[<p>今天要來介紹的是<code>Logical operators</code>，最主要有這三種常常使用 &#x3D;&gt;</p><ul><li><code>||</code> &#x3D;&gt; OR 運算子</li><li><code>&amp;&amp;</code> &#x3D;&gt; AND 運算子</li><li><code>!</code> &#x3D;&gt; NOT 運算子</li></ul><p>學習在這邊的時候可能會有疑問，運算子(operators)是什麼?</p><p>拿去 google 會發現它似乎會常常被跟運算式(Expressions)一起談論。</p><h2 id="Expressions-and-operators"><a href="#Expressions-and-operators" class="headerlink" title="Expressions and operators"></a>Expressions and operators</h2><p>可以用一個簡單的 1+1 來了解這個概念。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> X = <span class="number">1</span> + <span class="number">1</span>; <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p><code>1+1</code>會等於<code>2</code>應該沒問題，而這個<code>X = 1+1</code>其實就是<code>Expressions</code>，這個<code>Expressions</code>會產生一個<code>2</code>的值，那麼<code>operators</code>在哪裡？</p><p>在這個<code>X = 1+1</code>的<code>Expressions</code>裡面，<code>=</code>是一個<code>operators</code>，<code>+</code>也是一個<code>operators</code>，實際上，<code>Expressions</code>就是透過<code>operators</code>來進行運算的，透過<code>operators</code>的運算獲得最後的「值」。</p><p>是的，加、減、乘、除都是<code>operators</code>，除了計算之外，<code>operators</code>也可以用來賦予值，像是上面提到的<code>=</code>，它把<code>1+1</code>得出<code>2</code>的這個值賦予到這個 x 的變數之中，其他也有許許多多的不同的類型<code>operators</code>，像是我們今天的主題<code>Logical Operators</code>。</p><p>想要更了解的話可以去看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators">MDN Expressions and operators</a>。</p><p>接下來進入<code>Logical operators</code>個別介紹，會儘量用白話的方式來講述。</p><h2 id="介紹"><a href="#介紹" class="headerlink" title="||介紹"></a><code>||</code>介紹</h2><p><code>||</code>可以念做 OR 運算子，如它其名，這是一個用來判斷 OR 邏輯的<code>operators</code>，但什麼是 OR 邏輯判斷？</p><p>來看一個小故事。</p><h3 id="肚子痛的故事"><a href="#肚子痛的故事" class="headerlink" title="肚子痛的故事"></a>肚子痛的故事</h3><p>有一天小白穿得很帥的在路上走來走去，突然肚子一陣劇痛，小白心想這事情不太妙，這種感覺是沒辦法撐到回家的，好在他所在的位置附近剛好有兩個有廁所的建築物，一個是右側方過去有公園，另一個則是左邊過去有一間麥當勞。</p><p>時間已經等不了他了！ 小白要馬上做出選擇，最後他選擇的是……</p><h4 id="A-世界線-x3D-gt"><a href="#A-世界線-x3D-gt" class="headerlink" title="A 世界線 &#x3D;&gt;"></a>A 世界線 &#x3D;&gt;</h4><p>小白選擇了去公園，他步履蹣跚的向著公園廁所走去，路上小心翼翼的躲避著那些橫衝直撞的小孩，跟一群追著飛盤的狗，千辛萬苦來到廁所，裡面有三間，此時小白已經到了極限，他一間間的敲，第一間有人，第二間有人，第三間也有人，小白頓時留下兩行清淚，他失敗了。</p><h4 id="B-世界線-x3D-gt"><a href="#B-世界線-x3D-gt" class="headerlink" title="B 世界線 &#x3D;&gt;"></a>B 世界線 &#x3D;&gt;</h4><p>小白選擇了去麥當勞，趕到之後裡面一瞧，發現竟只有兩間廁所，小白吞了吞口水，拿起他那雙顫抖的手「叩叩叩」第一間廁所門，發現沒有反應後試探性地打開那廁所門，小白笑了，他知道他不用再去看下一間。</p><h3 id="只要是遇到了true就馬上回傳true"><a href="#只要是遇到了true就馬上回傳true" class="headerlink" title="只要是遇到了true就馬上回傳true"></a>只要是遇到了<code>true</code>就馬上回傳<code>true</code></h3><p>剛剛的故事裡，小白在 A 世界線裡選擇到了公園的廁所以及 B 世界線到麥當勞的廁所，我們可以使用 OR 運算子的方式來表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">公園廁所 = 廁所<span class="number">1</span> || 廁所<span class="number">2</span> || 廁所<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">麥當勞廁所 = 廁所<span class="number">1</span> || 廁所<span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>廁所沒人的話，小白可以順利解決肚子痛的問題，我們稱為<code>ture</code>。</li><li>廁所有人的話，小白會很悲慘，我們稱為<code>false</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">公園廁所 = <span class="literal">false</span> || <span class="literal">false</span> || <span class="literal">false</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">麥當勞廁所 = <span class="literal">true</span> || 廁所<span class="number">2</span>; <span class="comment">// ture</span></span><br></pre></td></tr></table></figure><p>公園的廁所每間都有人，全部<code>false</code>，所以最後結果也是<code>false</code>。</p><p>麥當勞的廁所小白只去看了第一間，發現裡面沒有人<code>ture</code>，就直接進去沒有再去看第二間了，最後結果是<code>ture</code>。</p><p>上面這些其實就是 OR 邏輯判斷，當全部失敗的時候就全部失敗，但只要有其中一個成功，那麼就直接成功，不用看其他的。</p><p>列舉一些實際上範例的組合會更了解一些：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> || <span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">false</span> || <span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> || <span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">false</span> || <span class="literal">false</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>可以發現到說，除了全部都是<code>false</code>之外的，其他通通都是<code>true</code>，這基本上就是 OR 運算子的概念。</p><p>但我們實際上不會只用<code>true</code>跟<code>false</code>這種方式來做判斷，我們可以用其他各種類型的值，它們會自動轉換成<code>true</code>跟<code>false</code>的型態，比如說：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">10</span> || age &gt; <span class="number">65</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;你可以買優惠票&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>age &lt; 10</code>及<code>age &gt; 65</code>都會被轉換，有成立就會<code>true</code>沒成立則是<code>false</code>，數字方面也一樣，像是說:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">1</span> || <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;有true&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>數字<code>1</code>會被當作<code>true</code>，數字<code>0</code>會被當作<code>false</code>，會發現到說要是今天操作的值不是一個「boolean」值，也會被轉換成一個「boolean」的型態。</p><p>以上是基本的 OR 運算子會做到的事情。</p><p>了解這塊之後，接下來再來探討在<code>javascript</code>中，一些比較特別的特性。</p><h2 id="尋找第一個真值，找不到就回傳最後一個"><a href="#尋找第一個真值，找不到就回傳最後一個" class="headerlink" title="尋找第一個真值，找不到就回傳最後一個"></a>尋找第一個真值，找不到就回傳最後一個</h2><p>回到上面小白在 A 世界線悲慘的遭遇。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">公園廁所 = 廁所<span class="number">1</span> || 廁所<span class="number">2</span> || 廁所<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">公園廁所 = <span class="literal">false</span> || <span class="literal">false</span> || <span class="literal">false</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>三個廁所都沒有人，所以都是<code>false</code>，會回傳<code>false</code>，但是前面有提到說，除了「boolean」值之外，其實結果可以是任意類型，代表著回傳的東西不一定只能是<code>false</code>。</p><p>在查閱了 MDN 關於<code>Boolean</code>的章節跟一些相關文章後，發現可以被當作<code>false</code>的初始值如下：</p><ul><li>0</li><li>null</li><li>undefined</li><li>‘’</li><li>false(本身)</li><li>(空值沒東西)</li></ul><p>假如用這些值塞滿三個原本<code>false</code>的地方，最後肯定是會回傳<code>false</code>，但三個<code>false</code>值假如不一樣，那麼 OR 運算子會怎麼運作呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三個不同值 = <span class="literal">null</span> || <span class="string">&quot;&quot;</span> || <span class="number">0</span>; <span class="comment">// 三個都是false的值</span></span><br></pre></td></tr></table></figure><p>如果最後傳回來的值，是需要轉換之後才會變成「boolean」值的，那回傳的值會是直接最後一個初始的值。</p><p>從上面來說，就是<code>||</code>先從最左邊開始找，第一個看到<code>null</code>不是<code>true</code>所以繼續往下找，下一個是<code>&#39;&#39;</code>也不是<code>true</code>，所以繼續找，下一個<code>0</code>也不是<code>true</code>，但已經是最後一個了，所以<code>||</code>就會想說好吧，那就回傳<code>0</code>。</p><p>於是，假如今天順序是<code>null || &#39;&#39; || 0</code>就會回傳<code>0</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> || <span class="string">&quot;&quot;</span> || <span class="number">0</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>假如順序是<code>0 || &#39;&#39; || null</code>就會回傳<code>null</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> || <span class="string">&quot;&quot;</span> || <span class="literal">null</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>遇到是<code>true</code>的值，就會馬上回傳，否則回傳最後的<code>false</code>值。</p><p>最後再來利用剛剛的所學，改寫一次小白的例子。</p><p>使用三個變數代表三間廁所，空字串代表<code>false</code>，字串裡面有寫東西代表<code>true</code>，用<code>||</code>的方式來選擇是<code>true</code>的那一樣，並且顯示出來，代表廁所裡面有人。</p><p>利用這種技巧就可以來獲取一群變數排列中，裡面的第一個真值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstBathroom = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> secondBathroom = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> thirdBathroom = <span class="string">&quot;裡面有人&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstBathroom || secondBathroom || thirdBathroom || <span class="string">&quot;沒人可以進去&quot;</span>); <span class="comment">// 裡面有人</span></span><br></pre></td></tr></table></figure><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>今天的介紹就到這邊，明天會繼續把<code>&amp;&amp;</code>跟<code>!</code>講完的<img src="/images/emoticon/emoticon13.gif" alt="/images/emoticon/emoticon13.gif"></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators">MDN - Expressions and operators</a><br>[2] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean">MDN - Boolean</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day21 - recursion(遞迴)</title>
      <link href="/2022/10/06/JS21/"/>
      <url>/2022/10/06/JS21/</url>
      
        <content type="html"><![CDATA[<p>今天假如要寫一個求 1 + 2 + … + n 的總和，一般人可能很直覺的就想到說，要用<code>迴圈</code>的方式把所有值都加在一起。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    result += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">5</span>)); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>但除了<code>迴圈</code>之外，還有另外一種名為<code>遞迴</code>的技巧也能達成相同的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="title function_">add</span>(n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">5</span>)); <span class="comment">//15</span></span><br></pre></td></tr></table></figure><p>我們先來看一下<code>遞迴(recursion)</code>在<code>mdn</code>上面的定義：</p><blockquote><p>The act of a function calling itself, recursion is used to solve problems that contain smaller sub-problems. A recursive function can receive two inputs: a base case (ends recursion) or a recursive case (resumes recursion).</p></blockquote><p>簡單來說，就是一種自己呼叫自己的意思，利用自己呼叫自己來解決問題，通常需要被<code>遞迴</code>的問題是一個可以被分成很多小問題的大問題。</p><p>函數在運行時，有時會呼叫很多其他的函數來達到目的，在一些特殊的情況下，甚至會呼叫自己，而這種函數運行時會呼叫自己的技巧，就是<code>遞迴</code>。</p><p>而通常可以使用<code>迴圈</code>解決的問題，也可以用<code>遞迴</code>來做解決，原本只會使用<code>迴圈</code>的我，想不通幹嘛要用<code>遞迴</code>，後來想想其實多了一種新的解決問題的方式是一件好事，而且其實<code>遞迴</code>的程式碼通常比<code>迴圈</code>少，</p><p>會想要特別寫<code>遞迴</code>是因為一開始看不太懂，但突然看著看著就有了一些概念覺得蠻特別的，所以就來試著講解做個紀錄。</p><h2 id="一個基本的遞迴會需要有："><a href="#一個基本的遞迴會需要有：" class="headerlink" title="一個基本的遞迴會需要有："></a>一個基本的遞迴會需要有：</h2><ol><li>終止條件</li><li>遞迴條件</li></ol><p>第一個是因為假如沒有終止條件，那函式不斷的呼叫自己，最後就會變得沒完沒了，程式將無窮無盡不會結束。</p><p>而遞迴條件就是呼叫自已的條件，沒有終止條件就會無限循環然後當掉，但是沒有遞迴條件就沒辦法呼叫自己，程式就不知道怎麼呼叫。</p><p>舉個例子:<br>小白跟他朋友講一個故事，故事裡面是一個人跟他朋友講一個故事，而這個故事裡面是一個人跟他朋友講故事……</p><p>而在程式中，<code>遞迴</code>有一個經典的例子。</p><h2 id="費氏數列"><a href="#費氏數列" class="headerlink" title="費氏數列"></a>費氏數列</h2><p><img src="https://i.imgur.com/ypKel4Q.png"><br>以費波那契數為邊的正方形拼成的近似的黃金矩形。<br>圖片來源：<a href="https://zh.m.wikipedia.org/zh-tw/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0">https://zh.m.wikipedia.org/zh-tw/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0</a></p><p>在數學上，費波那契數是以遞迴的方法來定義：</p><ul><li>f0&#x3D;0 (1)</li><li>f1&#x3D;1 (2)</li><li>Fn &#x3D; Fn-1+Fn-2 (3)</li></ul><p>其中(1)跟(2)就是上述提到的終止條件，而(3)是<code>遞迴</code>的定義。</p><p>簡單來說，費式數列是從零開始，之後的數字都是由前面的數字兩者相加而成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、 1、 2、 3、 5、 8、 13、 21、 34、 55、 89、 144、 233、 377、 610</span><br></pre></td></tr></table></figure><p>寫法會像這樣:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fibonacci</span>(n - <span class="number">1</span>) + <span class="title function_">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>可能實際在寫程式時不會使用到<code>遞迴</code>，因為其實沒有非<code>遞迴</code>就不能解決的問題，它比較像是解決問題的另一種思路而已，所以多了解是沒有壞處的。</p><p>我個人認為<code>遞迴</code>有兩個優點，第一個是使用後的程式碼會看起來很少，程式碼看起來簡潔舒服，第二個是感覺比較專業，因為大部分人都用<code>迴圈</code>，用<code>遞迴</code>直接變得與眾不同了起來，大家也可以在寫程式中嘗試看看<code>遞迴</code>這個技巧。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Glossary/Recursion">mdn - 遞迴</a><br>[2] <a href="https://chupai.github.io/posts/2008/alg_recursion/">JavaScript 學演算法（二十二）- 遞迴 Recursion</a><br>[3] <a href="https://medium.com/tomsnote/javascript%E7%9A%84%E9%81%9E%E8%BF%B4-recursive-f8ce5d084533">Javascript 的遞迴(Recursive)</a><br>[4] <a href="https://iter01.com/9337.html">JavaScript 演算法之遞迴</a><br>[5] <a href="https://zh.m.wikipedia.org/zh-tw/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0">維基百科-費波那契數</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day20 - What is this?</title>
      <link href="/2022/10/05/JS20/"/>
      <url>/2022/10/05/JS20/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天要來講的主題是<code>this</code>，在<code>JavaScript</code>中的<code>this</code>可以在呼叫函式時，透過不同方式決定它要指向哪一個物件，而關於什麼時候會指向什麼地方，這就是<code>this</code>的困難之處。</p><h2 id="理解this來由"><a href="#理解this來由" class="headerlink" title="理解this來由"></a>理解<code>this</code>來由</h2><p>一開始自己的猜測理解是，有些很冗長的名字，假如有一個代名詞，去代替它會很好很多。</p><p>比如說，我要描述在一家便利商店打工的小白擁有的東西：</p><p>在便利商店打工的小白擁有著一台機車，在便利商店打工的小白還有隨身攜帶一個水壺，而且在便利商店打工的小白手中現在還拿著一個過期的超商飯糰。</p><p>假如把「便利商店打工的小白」用「他」來替換掉的話：</p><p>在便利商店打工的小白擁有著一台機車，「他」還有隨身攜帶一個水壺，而且「他」手中現在還拿著一個過期的超商飯糰。</p><p>程式碼寫起來概念會像這樣：</p><p>這邊變數名稱就不要太長單純是<code>white</code>就好，<br>但可以想像成叫做<code>SuperWhiteWorkingInAConvenienceStore</code>比較符合概念。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> white = &#123;</span><br><span class="line">  <span class="attr">transportation</span>: <span class="string">&quot;motorcycle&quot;</span>,</span><br><span class="line">  <span class="attr">thing</span>: <span class="string">&quot;kettle&quot;</span>,</span><br><span class="line">  <span class="attr">describe</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">      <span class="string">&quot;小白擁有一台&quot;</span> + white.<span class="property">transportation</span> + <span class="string">&quot;,小白還隨身攜帶&quot;</span> + white.<span class="property">thing</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">white.<span class="title function_">describe</span>(); <span class="comment">// 小白擁有一台motorcycle,小白還隨身攜帶kettle</span></span><br></pre></td></tr></table></figure><p>程式加上了<code>this</code>的概念會變成這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> white = &#123;</span><br><span class="line">  <span class="attr">transportation</span>: <span class="string">&quot;motorcycle&quot;</span>,</span><br><span class="line">  <span class="attr">thing</span>: <span class="string">&quot;kettle&quot;</span>,</span><br><span class="line">  <span class="attr">describe</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">      <span class="string">&quot;小白擁有一台&quot;</span> + <span class="variable language_">this</span>.<span class="property">transportation</span> + <span class="string">&quot;,小白還隨身攜帶&quot;</span> + <span class="variable language_">this</span>.<span class="property">thing</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">white.<span class="title function_">describe</span>(); <span class="comment">//小白擁有一台motorcycle,小白還隨身攜帶kettle</span></span><br></pre></td></tr></table></figure><p>這兩種結果都是一樣的，<code>this</code>會去指向這個物件的變數名稱，不管呼叫的東西有很長，最終都只需要四個字母的<code>this</code>就能取代掉，這是我一開始所對<code>this</code><br>的理解。</p><p>用「這個」來當代名詞，利用「這個」來呼叫所指的對象。</p><p>然後去看看比較正確的定義是什麼，這裡推薦去看：</p><ul><li>ECMAScript 標準規範</li><li>MDN - this 官方文件</li></ul><h3 id="先來看看-ECMAScript-標準規範-對-this-的定義："><a href="#先來看看-ECMAScript-標準規範-對-this-的定義：" class="headerlink" title="先來看看 ECMAScript 標準規範 對 this 的定義："></a>先來看看 ECMAScript 標準規範 對 this 的定義：</h3><blockquote><p>「The this keyword evaluates to the value of the ThisBinding of the current execution context.」</p></blockquote><p>翻中文：</p><blockquote><p>「this 這個關鍵字代表的值為目前執行環境的 ThisBinding。」</p></blockquote><p>好，我當初也看不太懂什麼是<code>ThisBinding</code>。</p><h3 id="ThisBinding-是什麼"><a href="#ThisBinding-是什麼" class="headerlink" title="ThisBinding 是什麼"></a>ThisBinding 是什麼</h3><p>有去研究了一下 有看到一篇文章有講述，整理一些重點。<br>文章是這篇：<a href="https://www.gushiciku.cn/pl/gQUF/zh-tw">帶你徹底搞懂執行上下文</a></p><p>在<code>es5 Execution Context</code>的時候 生命週期包括三個階段。</p><p>建立階段 → 執行階段 → 回收階段</p><p>而在建立階段會去做三件事情：</p><ol><li>確定 this 的值，也被稱為 This Binding</li><li>LexicalEnvironment（詞法環境） 元件被建立</li><li>VariableEnvironment（變數環境） 元件被建立</li></ol><p>code 大致長這樣&#x3D;&gt;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ExecutionContext</span> = &#123;</span><br><span class="line">  <span class="title class_">ThisBinding</span> = <span class="language-xml"><span class="tag">&lt;<span class="name">this</span> <span class="attr">value</span>&gt;</span>,     // 確定this</span></span><br><span class="line"><span class="language-xml">  LexicalEnvironment = &#123; ... &#125;,   // 詞法環境</span></span><br><span class="line"><span class="language-xml">  VariableEnvironment = &#123; ... &#125;,  // 變數環境</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><p>所以說 <code>ThisBinding</code> 是和<code>Execution Context</code>綁定的，也就是說每個執行環境都有一個 <code>this</code>，與 <code>es3</code> 的<code>this</code> 並沒有什麼區別，<code>this</code> 的值是在執行的時候才能確認，定義的時候不能確認。</p><p>可以理解成，一個新的函式執行環境被建立時，<code>JavaScript</code>就會自動幫建立一個新的<code>this</code>，所以這邊解開了一個盲點，不是呼叫了一個東西才創造<code>this</code>，而是函式只要創建，就會創造執行環境，而執行環境的建立階段就會去做<code>This Binding</code>的這個動作，確認有<code>this</code>的值。</p><h3 id="然後來看看-MDN-對-this-的定義："><a href="#然後來看看-MDN-對-this-的定義：" class="headerlink" title="然後來看看 MDN 對 this 的定義："></a>然後來看看 MDN 對 this 的定義：</h3><blockquote><p>「In most cases, the value of this is determined by how a function is called.」</p></blockquote><p>翻中文：</p><blockquote><p>「在大多數的情況下，this 會因為 function 被呼叫的方式而有所不同。」</p></blockquote><p>意思是<code>this</code>所指向的值，不是在被定義的當下決定的，是在被呼叫的時候決定的，這個部分會跟<code>Scope Chain</code>完全反過來，而今天主要談論是<code>this</code>，關於<code>Scope Chain</code>的部分，以後會專門做一期文章為大家講解。</p><p>所以在這裡<code>MDN</code>告訴了我們一件事情，隨著執行的方式不同，<code>this</code>所指向的值也都會不同，而注意到了一個細節，這邊是講說<code>In most cases</code>，在大多數的情況下，所以不是所有情況，這種狀況我理解是無意義的情況。</p><h3 id="this-無意義的情況"><a href="#this-無意義的情況" class="headerlink" title="this 無意義的情況"></a>this 無意義的情況</h3><p>無意義的情況是指物件之外的<code>this</code>就沒有意義去討論，沒有意義的意思是，在這種狀況<code>this</code>是什麼都沒關係，不重要。</p><p>比如說要去探討一個<code>function</code>裡面的<code>this</code>是會指向哪裡。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//window</span></span><br></pre></td></tr></table></figure><p>會發現說在瀏覽器環境下會指向<code>Window</code>的物件。<br>也不是指向<code>func</code>這個<code>function</code>，就像是我在介紹一個人，他很帥，什麼人？ 世界上的某一個人，感覺沒有什麼意義。</p><p>這個指向的<code>Window</code>物件也只是因為沒意義的狀況下給的預設值，通常會分成幾種狀況，我做了一個表格。</p><p><code>預設狀態下的this值</code>：</p><table><thead><tr><th></th><th>瀏覽器環境</th><th>node.js 環境</th></tr></thead><tbody><tr><td>嚴格模式</td><td>undefined</td><td>undefined</td></tr><tr><td>非嚴格模式</td><td>window</td><td>global</td></tr></tbody></table><p>整理一下，<code>MDN</code>講的<code>In most cases</code>是指在物件導向內，<code>this</code>所指的東西就是物件裡面的<code>instance</code>，而只要脫離了物件導向，就不用去管<code>this</code>的值是什麼，因為沒有意義。</p><p>而<code>this</code>到底是如何覺得要怎麼指向哪裡，<code>MDN</code>是說因為被呼叫的方式，<br>在這邊當作<code>this</code>有綁定指向的四個招式來解釋：</p><ul><li>Default Binding (預設綁定)</li><li>Implicit Binding (隱含綁定)</li><li>Explicit Binding (顯示綁定)</li><li>new Binding (new 綁定)</li></ul><p>然後第一種的預設綁定已經講完了，就是在沒意義的狀況下，<code>this</code>會有預設的值。</p><p>接下來講其他三種。</p><h2 id="隱含式綁定-Implicit-Binding"><a href="#隱含式綁定-Implicit-Binding" class="headerlink" title="隱含式綁定 (Implicit Binding)"></a>隱含式綁定 (Implicit Binding)</h2><p>關鍵字：透過 <code>.</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vic = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;vic&quot;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">vic.<span class="title function_">getName</span>(); <span class="comment">// vic</span></span><br></pre></td></tr></table></figure><p>隱含就是沒有明確說出<code>this</code>正式綁定的對象是什麼，用一個<code>.</code>可以取出物件屬性的特性，同時也告知<code>this</code>是可以指向哪裡。</p><p>最前面介紹小白擁有東西的程式就是利用<code>Implicit Binding</code>來綁定<code>this</code>。</p><h2 id="顯式綁定-Explicit-Binding"><a href="#顯式綁定-Explicit-Binding" class="headerlink" title="顯式綁定 (Explicit Binding)"></a>顯式綁定 (Explicit Binding)</h2><p>關鍵字： 透過<code>call</code> <code>apply</code> <code>bind</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello.<span class="title function_">call</span>(<span class="string">&quot;call&quot;</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// call 1 2</span></span><br><span class="line">hello.<span class="title function_">apply</span>(<span class="string">&quot;apply&quot;</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// apply 1 2</span></span><br></pre></td></tr></table></figure><p>你第一個參數傳什麼，裡面<code>this</code>的值就會是什麼。儘管原本已經有 <code>this</code>，也依然會被這種方法給覆蓋掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Mainmain</span> = main.<span class="title function_">bind</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="title class_">Mainmain</span>(); <span class="comment">// main</span></span><br></pre></td></tr></table></figure><p>bind 會回傳一個新的 function，這邊把 main 這個 function 用 test 來綁定。</p><h2 id="「new」關鍵字綁定"><a href="#「new」關鍵字綁定" class="headerlink" title="「new」關鍵字綁定"></a>「new」關鍵字綁定</h2><p>關鍵字： 透過<code>new</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Vic</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> main = <span class="keyword">new</span> <span class="title class_">Vic</span>(<span class="string">&quot;vic&quot;</span>);</span><br><span class="line">main.<span class="title function_">getName</span>(); <span class="comment">// vic</span></span><br></pre></td></tr></table></figure><p>當用 new 來建立一個先的物件，這個新的物件會被設為 this 綁定的目標。</p><h2 id="最後做一個小小的綁定整理"><a href="#最後做一個小小的綁定整理" class="headerlink" title="最後做一個小小的綁定整理"></a>最後做一個小小的綁定整理</h2><table><thead><tr><th></th><th>vic 定義</th><th>補充</th></tr></thead><tbody><tr><td>預設綁定</td><td>this 指向外面沒東西</td><td>function 被呼叫的當下如果沒有值,this 會自動指向全域</td></tr><tr><td>隱式綁定</td><td>透過 . 隱含指出</td><td>使用 . 可以取用到物件底下的屬性</td></tr><tr><td>顯式綁定</td><td>call(), apply(), bind()</td><td>直接強制給的，很明確</td></tr><tr><td>關鍵字綁定</td><td>this 指定新 new 出的物件</td><td>透過 new 來創造物件比較不常見</td></tr></tbody></table><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this">MDN - this</a><br>[2] <a href="https://blog.techbridge.cc/2019/02/23/javascript-this/">淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂</a><br>[3] <a href="https://medium.com/%E7%8B%97%E5%A5%B4%E5%B7%A5%E7%A8%8B%E5%B8%AB/whats-this-%E6%B7%BA%E8%AB%87javascript%E4%B8%AD%E4%BB%A4%E4%BA%BA%E5%9B%B0%E6%93%BE%E7%9A%84this-abefb1d76a23">What’s THIS | 淺談 Javascript 中令人困擾的 this</a><br>[4] <a href="https://kuro.tw/posts/2017/10/12/What-is-THIS-in-JavaScript-%E4%B8%8A/">What’s THIS in JavaScript ? [上]</a><br>[5] <a href="https://github.com/mqyqingfeng/Blog/issues/7">JavaScript 深入之从 ECMAScript 规范解读 this</a><br>[6] <a href="https://ithelp.ithome.com.tw/articles/10223674">JS 原力覺醒 Day17 - this 的四種繫結</a><br>[7] <a href="https://www.gushiciku.cn/pl/gQUF/zh-tw">帶你徹底搞懂執行上下文</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day19 - What is symbol?</title>
      <link href="/2022/10/04/JS19/"/>
      <url>/2022/10/04/JS19/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ES6 才加入的<code>primitive type</code>，我個人覺得是<code>primitive type</code>當中最難理解的。</p><p><code>object</code>的<code>key</code>在 ES6 之前都只能是字串，就算寫成數字也會被轉成字串，所以之前我會說，<code>object</code>的<code>key</code>只能是字串，但這個說法被<code>symbol</code>打破了，它也可以拿來當作<code>object</code>的<code>key</code>，而它為什麼可以，以及<code>symbol</code>是處理什麼領域的問題，讓我們看下去吧。</p><h2 id="特性：獨一無二"><a href="#特性：獨一無二" class="headerlink" title="特性：獨一無二"></a>特性：獨一無二</h2><p><code>symbol</code>可以直接跟獨一無二的值劃上等號，只會有一個保證是唯一的，這其實就是可以拿來當作<code>object</code>的<code>key</code>的原因，不會重複很適合拿來幫物件取名。</p><p>這樣記：只要透過<code>symbol</code>建立的值，都會獲得<code>特性：獨一無二</code>。</p><h2 id="建立：symbol"><a href="#建立：symbol" class="headerlink" title="建立：symbol"></a>建立：symbol</h2><p>建立<code>symbol</code>的方式很簡單，只要使用<code>Symbol()</code>即可，不需要用<code>new</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 語法</span></span><br><span class="line"><span class="keyword">const</span> fruit = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> symbol); <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure><p>可以給<code>Symbol</code>裡面加名字，在<code>Symbol()</code>的<code>()</code>裡面，可以當作它是這個變數<code>fruit</code>的描述，而它的類別是<code>Symbol</code>。</p><p>由於<code>特性：獨一無二</code>，所以當名字都是取一樣的，實際上值也是不同的，名字僅供參考，像是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruit = <span class="title class_">Symbol</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fruit2 = <span class="title class_">Symbol</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruit == fruit2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="招式：Symbol-for-、Symbol-keyFor"><a href="#招式：Symbol-for-、Symbol-keyFor" class="headerlink" title="招式：Symbol.for()、Symbol.keyFor()"></a>招式：Symbol.for()、Symbol.keyFor()</h2><p>所有的<code>Symbol</code>都是不同的，就算名字都取的一樣，但有時候還是會想要說相同名字的<code>Symbol</code>能夠擁有相同的實體，為了做到這件事情，需要一個名為<code>global Symbol registry</code>的概念。</p><p>想像有一個神秘的空間(註冊表)，創建了<code>Symbol</code>會註冊在裡面，想去看的時後可以隨時訪問，但不是想看就看的，需要名為招式<code>Symbol.for()</code>才辦到的。</p><p>要在註冊表裡讀取<code>symbol</code>，需要使用<code>Symbol.for()</code>。</p><p><code>Symbol.for()</code>相當於創立<code>Symbol</code>，只是這個創立<code>Symbol</code>是把它放到註冊表當中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruit = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fruit2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruit == fruit2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>比較一下</strong>：<br><code>Symbol()</code> &#x3D;&gt; 每個創立都不相同(就算同名字)，全域無法找到。<br><code>Symbol.for()</code> &#x3D;&gt; 創立時會放到註冊表，同名字就當作相同創建，在全域可以被<code>Symbol.keyFor()</code>找到。</p><p>而我要怎麼去拿到已經放到在註冊表裡面的<code>symbol</code>？<br>就會需要另一個招式&#x3D;&gt; <code>Symbol.keyFor()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruit = <span class="title class_">Symbol</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fruit2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(fruit)); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(fruit2)); <span class="comment">// apple</span></span><br></pre></td></tr></table></figure><p>一樣直接創立的話，就不存在於<code>global Symbol registry</code>，自然<code>Symbol.keyFor()</code>就無法找到。</p><p>這兩個招式其實就是<code>symbol</code>的<code>Static methods</code>(靜態方法)。</p><h2 id="排擠：symbol"><a href="#排擠：symbol" class="headerlink" title="排擠：symbol"></a>排擠：symbol</h2><p>可能是<code>symbol</code>太有個性了(獨一無二），在某些場合，會發生<code>symbol</code>被無視的狀況，比如說<code>for..in</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruit = <span class="title class_">Symbol</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;vic&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">  [fruit]: <span class="string">&quot;this is a apple&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> user) <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// name, age 沒有 fruit</span></span><br></pre></td></tr></table></figure><p>不過還是能找到它裡面的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user[fruit]); <span class="comment">// this is a apple</span></span><br></pre></td></tr></table></figure><p>跟<code>for..in</code>同個系列的<code>for..of</code>也會被略過。</p><p>另外一個會排擠<code>symbol</code>是<code>Object.keys</code>:</p><p>遇到就直接無視。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruit = <span class="title class_">Symbol</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  [fruit]: <span class="string">&quot;this is a apple&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure><p><code>symbol</code>在<code>for..in</code>、<code>for..of</code>、<code>Object.keys</code>都會被跳過。</p><p>可以反過來利用這個特性，當你想要隱藏某一些物件的屬性時，用<code>symbol</code>當<code>object</code>的<code>key</code>就對了，它在上面那些狀況都不會與其他属性一起被處理。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">MDN - Symbol</a><br>[2] <a href="https://pjchender.dev/javascript/js-symbols/">JS Symbols 的使用</a><br>[3] <a href="https://es6.ruanyifeng.com/#docs/symbol">ECMAScript 6 入門</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day18- What is Biglnt?</title>
      <link href="/2022/10/03/JS18/"/>
      <url>/2022/10/03/JS18/</url>
      
        <content type="html"><![CDATA[<blockquote><p>其實我不知道<code>Biglnt</code>的中文可以叫什麼比較好，直接翻成「大整數」似乎不太精確。</p></blockquote><p>今天會從以下這些角度來介紹：</p><ol><li><code>Biglnt</code>為何而來</li><li>定義及如何使用</li><li>可能會踩的雷區</li></ol><h2 id="數字類型-x3D-gt-Biglnt跟Number"><a href="#數字類型-x3D-gt-Biglnt跟Number" class="headerlink" title="數字類型 &#x3D;&gt; Biglnt跟Number"></a>數字類型 &#x3D;&gt; <code>Biglnt</code>跟<code>Number</code></h2><p>在<code>JavaScript</code>中，<code>Biglnt</code>也是其中的一種<code>primitive</code>，也就是基本型別。</p><p>複習一些有哪些基本型別，基本上可以由字串、數字、布林值含括：</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Null</li><li>Undefined</li><li>Symbol</li></ul><p>除了這些，其實還有一種基本型別叫做<code>Biglnt</code>，也是用來處裡數字的部分，就跟<code>Number</code>一樣的領域。</p><p>主要是因為光是<code>Number</code>處理數字會有一些無法顧及到的部分，所以才有了需要<code>Biglnt</code>的誕生。</p><p>舉例來說，只要數字太大，<code>Number</code>就沒辦法顯示精準，而這個範圍大致是<code>2**53-1</code>，從<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER">Number.MAX_SAFE_INTEGER</a>裡面描述的最大安全整數範圍來判斷，也就是說超過了這個數字，<code>Number</code>就沒辦法維持準確性。</p><p>不精確的意思是代表說明明兩個不一樣，但判斷不出來，舉一個例子是在<code>JavaScript</code>當中的<code>2 ** 53 + 1</code> 跟<code>2 ** 53 </code>會一樣，非常奇怪。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="number">2</span> ** <span class="number">53</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> B = <span class="number">2</span> ** <span class="number">53</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(A, B);</span><br><span class="line"><span class="comment">// 9007199254740992 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(A === B);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>為了要解決這個問題，<code>JavaScript</code>才會需要可以支持任意長度整數都保持精確度的<code>Biglnt</code>。</p><h2 id="創建-Biglnt-方式"><a href="#創建-Biglnt-方式" class="headerlink" title="創建 Biglnt 方式"></a>創建 Biglnt 方式</h2><p>把數字變成<code>Biglnt</code>的狀態很簡單，有兩種做法：</p><ol><li>在數字後面直接加上 n</li><li>使用 <code>BigInt()</code></li></ol><p>就是字面上的意思，加上一個 n 跟把數字給()起來。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> number = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">const</span> bigInt1 = <span class="number">123n</span>;</span><br><span class="line"><span class="keyword">const</span> bigInt2 = <span class="title class_">BigInt</span>(<span class="number">123</span>); <span class="comment">//跟bigInt1一模一樣</span></span><br></pre></td></tr></table></figure><p>跟<code>Number</code>一樣可以使用各種的運算子，可以把<code>Biglnt</code>當作一個後綴加上了<code>n</code>的<code>Number</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1n</span> + <span class="number">1n</span>); <span class="comment">// 2n</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2n</span> * <span class="number">2n</span>); <span class="comment">// 4n</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10n</span> / <span class="number">2n</span>); <span class="comment">// 5n</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">50n</span> % <span class="number">10n</span>); <span class="comment">// 0n</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10n</span> &gt; <span class="number">5n</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">20n</span> &gt; <span class="number">30n</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>跟<code>Number</code>有一個不一樣的地方，一般來說當只寫出值，像是<code>10</code>，那它可能是<code>String</code>也可能是<code>Number</code>，而這時候可以使用在這個值前面加上一個<code>+</code>的方式，讓這個值確認變為是<code>Number</code>型別。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> +<span class="number">10</span>); <span class="comment">//number</span></span><br></pre></td></tr></table></figure><p>但在<code>Biglnt</code>不支援這種方式，可能是為了避免搞混，如果在<code>Biglnt</code>就會直接報錯給你看。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="number">10n</span>); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>**什麼時候使用<code>Biglnt</code>**？</p><p>值超過了最大安全數字的時候，就是值大於<code>2^53</code>再使用<code>Biglnt</code>，正常狀態下好好的可以繼續用<code>Number</code>沒問題。</p><h2 id="Biglnt-踩雷區域"><a href="#Biglnt-踩雷區域" class="headerlink" title="Biglnt 踩雷區域"></a>Biglnt 踩雷區域</h2><p>以下問題都知道的話就可以直接跳過囉。</p><ul><li><code>BigInt</code>可以跟其他常規數字混合使用嗎？</li><li><code>BigInt</code>跟<code>Number</code>一直切換是好是壞？</li></ul><p>直接講結論，沒辦法混合使用，<code>BigInt</code>跟<code>Number</code>加再一起送你報錯。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + <span class="number">1</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1n</span> + <span class="number">1n</span>); <span class="comment">// 2n</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1n</span> + <span class="number">1</span>); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>如果有需要兩者的狀況，應該是要想法把轉換他們，有兩種情況：</p><ol><li>將<code>number</code>轉換成<code>bigint</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10n</span> + <span class="title class_">BigInt</span>(<span class="number">10</span>)); <span class="comment">// 20n</span></span><br></pre></td></tr></table></figure><ol start="2"><li>將<code>bigint</code>轉換成<code>number</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="number">10n</span>) + <span class="number">10</span>); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>而<code>BigInt</code>跟<code>Number</code>一直切換好嗎？<br>MDN 文件裡面說這樣不好，不建議在<code>BigInt</code>值和<code>Number</code>值之間進行強制轉換。</p><p>因為<code>Number</code>值和<code>BigInt</code>值之間的強制轉換會導致精度損失。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p><code>Biglnt</code>是一個新的數字基本型別,用來處理一些<code>Number</code>沒有辦法處理的數字，像是<code>Number</code>能夠表示的安全整數範圍之外的，就只能夠靠<code>Biglnt</code>來精準顯示。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt">MDN - BigInt</a><br>[2] <a href="https://ithelp.ithome.com.tw/articles/10250362">JavaScript 之旅 (22)：BigInt</a><br>[3] <a href="https://www.w3schools.com/js/js_2020.asp">w3schools - ECMAScript 2020</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day17 - async/await(Promise語法糖)</title>
      <link href="/2022/10/02/JS17/"/>
      <url>/2022/10/02/JS17/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>async/await</code>的方式提供了<code>promise</code>一種新的寫法，至於有沒有更方便及更高的可讀性，我覺得使用了<code>async/await</code>是更容易進行編寫的，至少可以不用一直<code>.then</code>下去，使用了<code>async/await</code>之後，就跟<code>.then</code>說再見。</p><p>今天會介紹的順序：</p><ol><li>這兩個好用的關鍵字分別代表的意思。</li><li>async&#x2F;await 所達成的「同步」效果。</li><li>錯誤處理的應對措施。</li></ol><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>這是一個加在<code>function</code>前面的關鍵字，沒有加就是普通的<code>function</code>，加了之後就會變成<code>async function</code>就會代表著現在這個<code>function</code>是一個非同步的<code>function</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通的function</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span> + num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async function</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span> + num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而會說加上<code>async</code>後<code>function</code>會變成非同步的原因主要是因為<code>async</code>會讓<code>function</code>在回傳的時候會返回一個<code>promise</code>，所以因為是<code>promise</code>，所以也可以使用<code>.then</code>來取出結果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span> + num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">10</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>所以跟這樣也是會相同的，不加上<code>async</code>的<code>function</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">10</span> + num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">10</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">//20</span></span><br></pre></td></tr></table></figure><p>加了<code>async</code>的<code>async function</code>除了可以讓整體變成非同步的<code>function</code>之外，還可以使用一種名為<code>await</code>的招式。</p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>這些從它的單字意思其實就能略知一二，<code>await</code>是等待，在這裡當關鍵字的就是就是讓這個<code>async function</code>進行等待。</p><p>這邊很重要的一點就是，一定要是<code>async function</code>，沒有的話就沒辦法使用，可是說是有<code>async</code>才有<code>await</code>(但沒有<code>await</code>也可以用<code>async</code>)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> promise;</span><br><span class="line">&#125; <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><p>沒有<code>async</code>的狀態下直接使用<code>await</code>就會報錯給你看。</p><p>等待主要是讓<code>Promise</code>的運行先暫停一下，直到接受了回傳值才會繼續運行，而<code>await</code>這種藉由等待，暫停了非同步的執行的方式，是讓使用了<code>async/await</code>的<code>function</code>看起來很像同步的關鍵。</p><p>明明是非同步，為什麼會看起來很像同步呢？ 看過來。</p><h2 id="async-await的「同步」"><a href="#async-await的「同步」" class="headerlink" title="async/await的「同步」"></a><code>async/await</code>的「同步」</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;五秒到了&quot;</span>), <span class="number">5000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sec</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;在 await 之前&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> promise;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;在 await 之後&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sec</span>(); <span class="comment">//?</span></span><br></pre></td></tr></table></figure><p>在講這段程式之前，先來談談順序的問題。</p><p>一般來說，程式碼看下來的流程，會先去執行同步的程式，因為不會有需要等待排隊的問題，而非同步的因為沒辦法馬上完成，所以要等待後才能執行，等待的時間不知道，但能知道的是一定同步的東西先跑完。</p><p><strong>程式碼的寫法順序</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">同步<span class="number">1</span></span><br><span class="line">非同步<span class="number">1</span></span><br><span class="line">同步<span class="number">2</span></span><br><span class="line">同步<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>實際上的執行順序</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">同步<span class="number">1</span></span><br><span class="line">同步<span class="number">2</span></span><br><span class="line">同步<span class="number">3</span></span><br><span class="line"></span><br><span class="line">...... =&gt; 確保同步都跑完</span><br><span class="line"></span><br><span class="line">非同步<span class="number">1</span></span><br></pre></td></tr></table></figure><p>基本上有兩個概念在執行順序這一塊：</p><ol><li>會由上而下執行</li><li>同步先執行，才是非同步執行</li></ol><p>回到程式碼，照著剛剛的概念來看，應該會是先跑出來<code>在 await 之前</code>之後是<code>在 await 之後</code>，而經由了<code>setTimeout</code>而造成需要等待幾秒才會執行的<code>promise</code>非同步理論上應該是最後才會跑出來，但是如果你把上面那段程式碼拿去執行，你會發現順序是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 <span class="keyword">await</span> 之前</span><br><span class="line">五秒到了</span><br><span class="line">在 <span class="keyword">await</span> 之後</span><br></pre></td></tr></table></figure><p>怎麼跟上面講的不一樣呢？這其實就是<code>async/await</code>的神奇之處，使用了<code>await</code>就會等待，就算它本身是一個非同步的運行，在整體的<code>async function</code>之中，也會逐行的執行，不會有某一行被抓去排隊(事件佇列)而執行跳到下一行的狀況，看起來就可以達成是非同步的，但我用同步的方式去跑。</p><h2 id="錯誤處理"><a href="#錯誤處理" class="headerlink" title="錯誤處理"></a>錯誤處理</h2><p><code>await</code>後面接的<code>promise</code>會直接回傳結果，而結果有兩種可能性。</p><ul><li>成功 &#x3D;&gt; resolve</li><li>失敗 &#x3D;&gt; reject</li></ul><p>在原本使用<code>promise</code>的時候，會使用<code>.then</code>跟<code>.catch</code>去獲取這兩種結果，但是<code>async/await</code>不用。</p><p>我研究之後發現在<code>async/await</code>時會使用<code>try..catch</code>的方式來處理錯誤的結果。</p><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try..catch"></a>try..catch</h3><p>它會分成兩個區塊，一個 try 一個 catch，主要就是正常是 try 區塊，在 try 區塊碰到錯誤，直接跳到 catch 區塊。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 要執行的程式</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 錯誤發生時，上面的就不會執行，改執行這邊</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>舉例時間：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">apple</span>(<span class="string">&quot;apple不是正確的使用方式喔&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我錯了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這段 code 的結果會印出我錯了，如下：<br><img src="https://i.imgur.com/8wTpx1D.png"></p><p>為什麼會發生這樣的結果？這是因為如果 try 區塊裡面的程式碼假如沒有任何的錯誤，就會直接忽略掉<code>catch</code>區塊裡面的程式碼，反之有錯的話，就會以<code>catch</code>裡面的程式碼為主，而錯誤的<code>try</code>就會中斷執行，所以在這個範例來說，因為<code>try</code>寫錯了，所以會以<code>try</code>裡面的程式碼為主。</p><p>另外如果<code>catch</code>區塊如果接受了一個參數，就可以直接利用這個參數獲取錯誤資料，一般都會是直接在後台輸出資料，這邊來試試看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">apple</span>(<span class="string">&quot;apple不是正確的使用方式喔&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;錯誤訊息 :&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這段 code 的結果會印出錯誤資訊，如下：<br><img src="https://i.imgur.com/rqNUD5z.png"></p><h3 id="async-await遇錯時"><a href="#async-await遇錯時" class="headerlink" title="async/await遇錯時"></a><code>async/await</code>遇錯時</h3><p>使用剛剛講的方式，先把全部的<code>async function</code>都用<code>try..catch</code>包起來，然後錯誤的話自然就會跑到<code>catch區塊</code>自動去抓取失敗的結果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promise</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (a) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;五秒到了&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;錯誤發生&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">5000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sec</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;在 await 之前&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">promise</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;在 await 之後&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sec</span>();</span><br></pre></td></tr></table></figure><p>最後結果印出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 <span class="keyword">await</span> 之前</span><br><span class="line">錯誤發生</span><br></pre></td></tr></table></figure><p>第一行的<code>在 await 之前</code>還是會出現，只是經過了下方<code>await</code>的<code>promise</code>，因為裡面帶入的參數是負數，所以是<code>false</code>，結果會跑去<code>else </code>的<code>reject(&quot;錯誤發生&quot;)</code>，而最終會進到<code>catch</code>區塊直到結束，所以<code>try</code>區塊後面的<code>在 await 之後</code>就不會看到。</p><p>要注意一件事情，<code>try</code>區塊可以因為錯誤而進到<code>catch</code>區塊，但沒辦法反向，也就是說無法在失敗之後再度執行原本程式。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p><code>async function</code>的奇妙之處：</p><ol><li>內部可以使用名為<code>await</code>的招式。</li><li>內部最終總是會回傳一個<code>promise</code>。</li><li>整體會變成非同步的狀況。</li></ol><p><code>await</code>這個招式使用之後的兩種下場：</p><ol><li>強制<code>promise</code>等待直到完成。</li><li>有錯誤的話，拋出<code>reject</code>的錯誤結果。</li><li>沒錯誤就直接回傳<code>resolve</code>的成功結果。</li></ol><p>什麼時候可以用？</p><p>基本上當你想要使用<code>promise</code>的<code>.then</code>時，都可以把它改成<code>async/await</code>的方式，就不用一直<code>.then</code>，處理非同步的程式時又多了一種寫法，看完這這篇後，大家也多嘗試用看看<code>async/await</code>來寫 code 吧。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">MDN - async function</a><br>[2] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await">MDN - await</a><br>[3] <a href="https://www.w3schools.com/js/js_async.asp">w3schools - JavaScript Async</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day16 - Promise methods(承諾方法)</title>
      <link href="/2022/10/01/JS16/"/>
      <url>/2022/10/01/JS16/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前幾天講的<code>Promise</code>的 then()、catch()、finally()也是<code>Promise</code>的 methods，從 MDN 的定義上會把這三種 methods 稱之為<code>Instance methods</code>，而今天要講的是<code>Static methods</code>，中文叫做靜態方法，大致上可以分成六種，這些的方法都是為了更好的使用<code>Promise</code>而被發明出來，可能用不到但懂了沒壞處。</p><p>哪六種：</p><ul><li>Promise.all()</li><li>Promise.allSettled()</li><li>Promise.any()</li><li>Promise.race()</li><li>Promise.resolve()</li><li>Promise.reject()</li></ul><p>會嘗試用好理解的方式介紹，let’s go。</p><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>執行很多的<code>Promise</code>會用到，簡單來說，全部都達成才會成功，不然就會失敗。<br>舉一個例子，小白願意去找工作，但他有著前提條件，只要他擁有了一台車，然後有了房子，還擁有 100 萬的存款，他就會去找工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;獲得車&quot;</span>), <span class="number">100</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;獲得房子&quot;</span>), <span class="number">200</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;獲得100萬&quot;</span>), <span class="number">300</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;=&gt; 好! 去工作&quot;</span>), <span class="number">400</span>)),</span><br><span class="line">]).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ &#x27;獲得車&#x27;, &#x27;獲得房子&#x27;, &#x27;獲得100萬&#x27;, &#x27;=&gt; 好! 去工作&#x27; ]</span></span><br></pre></td></tr></table></figure><p>會等到全部的結果都成功，才會全部都<code> resolve</code>， 會發現說它回傳的會是一個 array，這個 array 裝的東西就是所有的結果。</p><p>只要有一個失敗，就直接失敗，就像是只要有一個前提條件沒達成，小白就沒辦法去找工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;獲得車&quot;</span>), <span class="number">100</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;獲得房子&quot;</span>), <span class="number">200</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;沒有一百萬，沒人要給你&quot;</span>)), <span class="number">300</span>)</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;=&gt; 好! 去工作&quot;</span>), <span class="number">400</span>)),</span><br><span class="line">])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: 沒有一百萬，沒人要給你</span></span><br></pre></td></tr></table></figure><p>其中有一個被<code>reject</code>就會導致全部整個<code>Promise.all</code>都被<code>reject</code>，最後的結果就是<code>reject</code>裡面寫好的<code>Error</code>訊息。</p><h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h2><p>情境是使用在都每種<code>Promise</code>都想知道結果的時候。</p><p>代表說成功或是失敗的結果都會被記錄下來，這兩種都會被裝在一個陣列裡面。</p><p><strong>成功</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">status</span>:<span class="string">&quot;fulfilled&quot;</span>, <span class="attr">value</span>:成功的訊息&#125;</span><br></pre></td></tr></table></figure><p><strong>失敗</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">status</span>:<span class="string">&quot;rejected&quot;</span>, <span class="attr">reason</span>:失敗的訊息&#125;</span><br></pre></td></tr></table></figure><p>繼續上方的例子，小白做好準備要出發去找工作，他的策略是履歷海，什麼都投，投完後開心地坐在家中等消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Promise.allSettled([</span><br><span class="line">  // 找工作是一個包著promise的函式，裡面就會放失敗跟成功的訊息</span><br><span class="line"></span><br><span class="line">  找工作(&quot;第一間公司&quot;, 100),</span><br><span class="line">  找工作(&quot;第二間公司&quot;, 200),</span><br><span class="line">  找工作(&quot;第三間公司&quot;, 300),</span><br><span class="line">])</span><br><span class="line">  .then((value) =&gt; console.log(value));</span><br><span class="line">  .catch((err) =&gt; console.log(err));</span><br><span class="line"></span><br><span class="line">// 結果=&gt;</span><br><span class="line">[</span><br><span class="line">  &#123; status: &#x27;fulfilled&#x27;, value: &#x27;第一間公司：發來面試請求！&#x27; &#125;,</span><br><span class="line">  &#123; status: &#x27;rejected&#x27;, reason: &#x27;第二間公司，無聲卡&#x27; &#125;,</span><br><span class="line">  &#123; status: &#x27;fulfilled&#x27;, value: &#x27;第三間公司：發來面試請求！&#x27; &#125;,</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中有一個被<code>reject</code>，也會把其他結果通通跑完，跑完之後會能看到所有的結果，無論結果是如何，都會全部都被<code>settle</code>，所以叫做<code>allSettled</code>。</p><h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h2><p>假如成功就馬上成功，直到全部都失敗。</p><p>而在全部都失敗的狀態下，會回傳一個叫做<code>AggregateError</code>的物件裡面，把失敗的訊息都放進去。</p><p>小白出發前往面試，他只要有上就好，成功了就不會繼續下一間。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;失敗，下一間&quot;</span>)), <span class="number">100</span>)</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;成功找到工作&quot;</span>), <span class="number">200</span>)</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;回家睡覺&quot;</span>), <span class="number">300</span>)),</span><br><span class="line">]).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 成功找到工作</span></span><br></pre></td></tr></table></figure><p>假如完全都沒有任何公司是面試成功的話：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;失敗，下一間&quot;</span>)), <span class="number">100</span>)</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;失敗，下一間&quot;</span>)), <span class="number">200</span>)</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;失敗，下一間&quot;</span>)), <span class="number">300</span>)</span><br><span class="line">  ),</span><br><span class="line">])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">constructor</span>.<span class="property">name</span>, error.<span class="property">errors</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 會出現：</span></span><br><span class="line"><span class="title class_">AggregateError</span> [</span><br><span class="line">  <span class="title class_">Error</span>: 失敗，下一間</span><br><span class="line">  <span class="title class_">Error</span>: 失敗，下一間</span><br><span class="line">  <span class="title class_">Error</span>: 失敗，下一間</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p>跟<code>Promise.any</code>有點像，當一個<code>promise</code>有結果，就回傳跟結束。</p><p>剛剛提到小白找到了工作，他很開心想要慶祝，所以打算去吃一間豪華的餐廳，他還沒想要要吃什麼，抱著不想找太久的心手舞足蹈的前往。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;吃牛排&quot;</span>), <span class="number">200</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;吃拉麵&quot;</span>), <span class="number">300</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;吃火鍋&quot;</span>), <span class="number">400</span>)),</span><br><span class="line">])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 吃牛排</span></span><br></pre></td></tr></table></figure><p>小白看到了牛排，然後裡面就有位子不用排隊，二話不說就直接開吃了。</p><p>到這邊跟<code>Promise.any</code>幾乎一模一樣，有了一個成功，其他都就不會去看直接結束。</p><p>但是要是第一間要去的不是牛排店，而是人很多的燒賣店呢？讓我們看下去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;人太多，不吃了&quot;</span>)), <span class="number">100</span>)</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;吃牛排&quot;</span>), <span class="number">200</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;吃拉麵&quot;</span>), <span class="number">300</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;吃火鍋&quot;</span>), <span class="number">400</span>)),</span><br><span class="line">])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// Error: 人太多，不吃了</span></span><br></pre></td></tr></table></figure><p>小白第一間到了燒賣店，看到了那人山人海的群眾，內心湧入一陣倒胃，突然就沒有吃飯的慾望了，於是就直接回家結束了這回合。</p><p>這就是<code>Promise.race</code>的特性，不管是成功還是失敗，<code>Promise.race</code>都會被解決。</p><h2 id="Promise-race-和-Promise-any-比一比"><a href="#Promise-race-和-Promise-any-比一比" class="headerlink" title="Promise.race() 和 Promise.any() 比一比"></a>Promise.race() 和 Promise.any() 比一比</h2><p>來複習一下這兩者的差別：</p><p><strong>Promise.race</strong>:<br>不管是成功還是失敗，都會直接完成。</p><p><strong>Promise.any</strong>:<br>當成功了，或是全部都失敗，才會完成。</p><p>兩個都會有拒絕的狀況，<code>Promise.race</code>的拒絕狀況是因為碰到了第一個<code>Promise</code>拒絕後就馬上拒絕，而<code>Promise.any</code>是全部都被拒絕後，回傳一個，<code>AggregateError</code>。</p><p>要如何使用它們兩個，要依照情境而定，可以知道的是他們兩個很相似但是依舊是不同的東西。</p><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>我的理解是設定<code>Promise</code>成功後的訊息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p>而<code>reject</code>就是<code>Promise</code>失敗後的訊息，所以要用 catch()去抓。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>每一種方法都有它適合的情境，在使用<code>promise</code>可以試著用用看這些方法～說不定會發現方便又好用，而我個人體感跟爬文看到來說，<code>Promise.all</code>這個方法是實際上會使用最多的，所以可以考慮先從這個開始下手認識，那麼今天就是這些，謝謝明天見。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN - Promise</a><br>[2] <a href="https://stackoverflow.com/questions/61732049/what-is-the-difference-between-promise-any-and-promise-race">What is the difference between Promise.any() and Promise.race()</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day15 - Promise Chain(承諾鏈)</title>
      <link href="/2022/09/30/JS15/"/>
      <url>/2022/09/30/JS15/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有時候很常見會有情況是需要很多的非同步操作，每一個非同步的後續操作都建立在前面的非同步操作的成功，所以會繼續上一步的結果，在使用<code>callback</code>處理這種狀況的時候，就會產生可怕的<code>callback hell</code>，而<code>Promise Chain</code>可以很好的改善這個問題，就讓我們看下去。</p><h2 id="promise-chain-的使用方式"><a href="#promise-chain-的使用方式" class="headerlink" title="promise chain 的使用方式"></a>promise chain 的使用方式</h2><p>​<br>從看一個例子來了解使用方式。<br>​</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">​</span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> result + <span class="number">1</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> result + <span class="number">1</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> result + <span class="number">1</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> result + <span class="number">1</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>​<br>這是使用了<code>promise</code>方式來處理的<code>promise chain</code>，藉由<code>.then</code>會回傳一個新的 <code>promise</code>，讓每一個在<code>promise chain</code>的<code>promise</code>都代表上一個非同步的步驟已經完成。<br>​<br>注意，<code>return</code>之後的東西是新的<code>promise</code>，所以上一個流程已經結束了，就像是有人等烤吐司機烤完吐司，才去啟動微波爐加熱便當，那麼當他已經走到微波爐準備加熱便當時，就代表烤土司機已經烤完吐司了，雖然這兩個步驟都需要等待，但是不會一起等是獨立的，上一個等完才換下一個等。<br>​<br>而在這個例子中，<code>promise chain</code>運行的流程如下：</p><ol><li>初始 promise 會直接把 resolve 結果為 1。</li><li>然後 .then 開始作用，會創建一個新的 promise，以上一個的 return 作為值，在這裡是 1。</li><li>下一個.then 就會獲得上一個.then 的值(2)，再進行處理之後，會將值傳遞給下一個處理階段。</li><li>… 以此類推。<br>​<br>這邊其實會比較沒有非同步的感覺沒有等待，可能用<code>setTimeout</code>的方式似乎比較好，但只要使用<code>promise</code>就一定會使用非同步的方式去進行的，內部的狀態還是會從<code>pending</code>未確認的狀態，變成<code>Fulfilled</code>，而每一次的<code>.then</code>就相當於重新判定一次。<br>​<br>再次強調，這樣做之所以可行的核心是因為每一個 then()後都會回傳一個新的<code>promise</code>。<br>​<br>A 做完後，使用 then()會回傳新的 B，然後再用 B 去做事，做完後再用 then()回傳一個新的 C，這種一層一層傳遞下去，就像是一個鏈子一樣，所以會稱之為<code>Promise Chain</code>。<br>​<br>這裡會引申出一個新的問題，那就是如果把很多的 then()都寫在同一個<code>promise</code>那還叫做<code>Promise Chain</code>嗎？<br>​<br>像是這樣：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="number">1</span>), <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br><span class="line">​</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  <span class="keyword">return</span> result * <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line">​</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  <span class="keyword">return</span> result * <span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line">​</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  <span class="keyword">return</span> result * <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>​<br>這樣的話依舊是<code>Promise</code>，依然使用著非同步的方式，但其實就不是<code>Promise Chain</code>，它們沒有連再一起，就只是各自做各自的事情，互不關聯，沒有延續所以也就不會互相傳遞<code>result</code>，所以在這個例子來說，會發現全部印出來的東西都是 1。<br>​<br>我有想到了一個例子：<br>​<br>​<br><strong>Promise Chain</strong></p><ol><li>如果吃完蘋果的話，休息五分鐘就去吃香蕉</li><li>如果吃完蘋果後跑去吃完香蕉，休息五分鐘就去吃西瓜</li><li>如果吃完蘋果後跑去吃完香蕉又去吃了西瓜，休息五分鐘就準備去廁所<br>​<br>​<br><strong>Promise</strong></li><li>如果吃完蘋果的話，休息五分鐘就去吃香蕉</li><li>如果吃完蘋果的話，休息五分鐘就去吃西瓜</li><li>如果吃完蘋果的話，休息五分鐘去去廁所<br>​<br>​<br>​<br>​<br>​</li></ol><h2 id="回傳解決與拒絕"><a href="#回傳解決與拒絕" class="headerlink" title="回傳解決與拒絕"></a>回傳解決與拒絕</h2><p>前面一直在用 then()來當作<code>Promise Chain</code>的下一個回傳，但其實連接的概念除了 then()之外還有 catch()，差別在於<code>Promise</code>有沒有被拒絕，當一個<code>Promise</code>被解決時，也就是狀態是<code>fulfilled</code>，那麼就會使用 then()返回已經解決的<code>Promise</code>，如果是被拒絕時，也就是狀態<code>rejected</code>，那麼就會使用 catch()來回傳，舉一個例子：<br>​</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promise</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (judge) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">`成功`</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;你失敗了謝謝&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="title function_">promise</span>(<span class="number">1</span>) <span class="comment">// 第一次成功，因為是true</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(number);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">promise</span>(<span class="number">1</span>); <span class="comment">// 第二次成功，因為是true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(number);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">promise</span>(<span class="number">0</span>); <span class="comment">// 失敗，下面的就不會去看，會直接跳catch</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(number);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">promise</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(number);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">promise</span>(<span class="number">1234567890</span>); <span class="comment">// 不會有反應了</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(number);</span><br><span class="line">  &#125;);</span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>首先，要在自己寫的<code>promise</code>同時存在成功跟失敗的結果，要用成判斷式的型態，因為狀態是不可逆的，<code>pending</code>只要到了<code>fulfilled</code>或是<code>rejected</code>其中一個就再也回不去了。<br>​<br>然後這裡我寫的判斷是，要是值是 true 的時候就會成功，false 的話就會你失敗了謝謝，而正數的時候值會是 true，負數時值會是 false，下方的呼叫寫了三個 then()跟一個 catch()，這裡要測試的是當不管是幾個 then()，只要有一個條件不成立，值是 false，那麼就直接會跳到 catch()那裡去，所以會發現這個程式的結果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">成功</span><br><span class="line">成功</span><br><span class="line">你失敗了謝謝</span><br></pre></td></tr></table></figure><p>​<br>第一個 then()那裡回傳出去的值就已經是負數了，代表會是 false，所以後面的 then()都不用看，會直接到最後的 catch()結果，而如果想要再 catch()再開始繼續也是可以，就直接再傳一個新的<code>promise</code>結果即可。<br>​</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">promise</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(r); <span class="comment">// 成功</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>​</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>除了用<code>then</code>來串鏈形成<code>Promise Chain</code>的方式來處理很多個連續的非同步操作外，也有一種<code>Promise</code>的語法糖，叫做 async&#x2F;await 的方式，因為原理還是<code>Promise</code>，所以是語法糖，關於這個以後會專門做一期文章給大家講解。<br>​<br>​</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises"> MDN - Using Promises</a><br>[2] <a href="https://javascript.info/promise-chaining">Promises chaining</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day14 - Promise(承諾)</title>
      <link href="/2022/09/29/JS14/"/>
      <url>/2022/09/29/JS14/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Promise</code>在程式中非常好用，是因為很多操作都需要使用到非同步的概念，而要處理非同步，除了使用<code>callback function</code>之外，就是會使用<code>Promise</code>。</p><p>這篇講述我是如何理解這個概念。</p><p>今天主要講<code>Promise</code>的狀態跟呼叫。</p><p><code>Promise</code>是一個<code>constructor function</code>，假如需要自己寫一個<code>Promise</code>時，語法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(value);</span><br><span class="line">  <span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>它的參數<code>resolve</code>以及<code>reject</code>是它自己所提供的<code>callback</code>，不用自己額外寫，而這兩個的名稱可以自己定義像是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">a</span>();</span><br><span class="line">  <span class="title function_">b</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>效果也一樣，但是不建議這麼做。</p><p>而會設定這兩個參數，是有它的意義存在，從承諾來談吧。</p><h2 id="Promise-狀態"><a href="#Promise-狀態" class="headerlink" title="Promise 狀態"></a>Promise 狀態</h2><p>可以把它想像成一個承諾，答應了某件事情，不管最後有沒有成功，都會有一個結果。</p><p>所以兩個參數的意義在於，成功跟失敗時會獲得什麼結果，所以當程式正在進行一個<code>Promise</code>的非同步時，如果成功就會呼叫<code>resolve</code>如果失敗就會呼叫<code>reject</code>，這裡要注意的是假設已經呼叫成功的結果了，那就回不去還沒決定的狀態，這是不可逆的，成功以及失敗只能選一個，回傳了這個結果之後，<code>Promise</code>就會結束。</p><p>最初的時候，是未確認的狀態，也就是<code>pending</code>，接著成功的話會變成<code>Fulfilled</code>的狀態，失敗就會是<code>Rejected</code>。</p><p>舉例來說，小白跟小紅告白了。</p><p>前情提要，因為<code>promise</code>的特性一定得非同步的方式進行，代表著被告白的時候，就算遇到白馬王子，也沒辦法馬上秒答應，同樣的就算遇到非心儀對象，也不能馬上送出一張好人卡。</p><p>也就代表說，使用了<code>promise</code>的狀態，任何人都會一模一樣的以<code>非同步的方式</code>一致得到結果，像是小白也不會<code>以同步的方式</code>馬上被拒絕，這種藉由讓大家用統一的方式處理非同步就是<code>promise</code>的好處之一，而接下來小白就要開始行動了，讓我們看下去。</p><p>小白： 「我喜歡妳！」 &#x3D;&gt; promise 事件開始，現在狀態是 pending。</p><p>小紅： 「let me think think.」 &#x3D;&gt; 非同步開始排隊等待了，答案醞釀。</p><p>小白： 「你慢慢想！」 &#x3D;&gt; 等待非同步時間結束。</p><p>— 兩天後 —</p><p>小紅： 「deserving of better people.」&#x3D;&gt; 被拒絕，現在狀態是 rejected。</p><p>小白： 「……」 &#x3D;&gt; 小白 catch 到了這個 reject。</p><p>小紅： 「you are friends forever.」&#x3D;&gt; 小紅傳入 rejected 函式。</p><p>小白： 「好吧，那就還是朋友。」 &#x3D;&gt; 小白知道回不去了(狀態不可逆)。</p><h2 id="Promise-呼叫"><a href="#Promise-呼叫" class="headerlink" title="Promise 呼叫"></a>Promise 呼叫</h2><p>當寫好了一個<code>Promise</code>，裡面已經定義好了失敗以及成功的結果後，但要取出這些結果，還需要一些方法，主要如下：</p><ul><li>then()</li><li>catch()</li><li>finally()</li></ul><p>把上面的例子寫成程式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mission = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;you are friends forever&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mission.<span class="title function_">catch</span>(<span class="function">(<span class="params">answer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(answer); <span class="comment">//you are friends forever</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>then</code>會捕獲成功的結果，<code>catch</code>則相反是失敗的，像是在這邊就可以利用<code>catch</code>去抓到<code>reject</code>裡面的函式。</p><p>使用<code>then</code>時會捕獲成功的結果，語法會像這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>第一個參數是成功的結果，第二個參數是失敗的，所以也可以用<code>then</code>去抓失敗的結果，像是這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mission = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;you are friends forever&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mission.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result),</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">); <span class="comment">// you are friends forever</span></span><br></pre></td></tr></table></figure><p>最後一個是<code>Finally</code>，這個方式不會有任何參數，因為不需要，可以用這個方式來確認整個<code>promise</code>已經結束了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mission = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;you are friends forever&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mission</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result),</span><br><span class="line">    <span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;小白:一切都已經結束了&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// you are friends forever</span></span><br><span class="line"><span class="comment">// 小白:一切都已經結束了</span></span><br></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>執行的函式最後一定會回傳值，就算沒有寫也是回傳<code>undefined</code>，而在<code>Promise</code>來說，設計<code>Promise</code>物件最後的結果要不是回傳一個成功的值，不然就是失敗的值，<code> fulfilled</code>或是<code>rejected</code>，最後再複習一次，<code>Promise</code>的狀態只會有這三種。</p><ol><li>pending(等待中)</li><li>fulfilled(已實現)</li><li>rejected(已拒絕)</li></ol><p>就算是非同步，也是有需要一個接著一個執行的狀況，其實<code>Promise</code>後面也是能繼續連著<code>Promise</code>的，就是所謂的<code>Promises chaining</code>，明天的文章主題，明天見。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://marco79423.net/articles/%E6%B7%BA%E8%AB%87-javascript-%E7%9A%84-promise">淺談 JavaScript 的 Promise</a><br>[2] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN - Promise</a><br>[3] <a href="https://5xruby.tw/posts/promise">你今天 Promise 了嗎？</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day13 - Event Loop (事件循環)</title>
      <link href="/2022/09/28/JS13/"/>
      <url>/2022/09/28/JS13/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天提到了<code>JavaScript</code>可以利用「並行的方式」去做到非同步這件事情，而關於這到底是怎麼辦到的，就是今天的主題，然後今天主要的內容都是以這個影片為基礎&#x3D;&gt; <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&ab_channel=JSConf">所以說 event loop 到底是什麼玩意兒？| Philip Roberts | JSConf EU</a>，這影片對於<code>JavaScript</code>如何進行非同步的操作講得很清楚，推薦看。</p><p>出自影片的圖：<br><img src="https://i.imgur.com/volAZAZ.png"></p><p>而以下是我看完影片，研究之後的自己見解。</p><h2 id="Call-Stack"><a href="#Call-Stack" class="headerlink" title="Call Stack"></a>Call Stack</h2><p>每段程式的執行都會有<code>call stack</code>，可以用來紀錄執行的順序，只要函式在呼叫的時候，就會把它丟進去最下面，後面進來的就會再疊上去，而當函式處理完之後，再從最上面去拿走，這是一種後進先出的概念。</p><p>可以想像成一個洋芋片罐，最先放進去的洋芋片，會在洋芋片罐的最下方，當洋芋片都放完要拿的時候，先拿的那片洋芋片就會是洋芋片罐最上方的那個洋芋片。</p><p>之前有提到說<code>JavaScript</code>只有一個執行緒，所以不能做很多事情，其實是因為只有一個<code>Call Stack</code>，因此一次只能做一件事情。</p><h2 id="Web-Apis"><a href="#Web-Apis" class="headerlink" title="Web Apis"></a>Web Apis</h2><p>意思是瀏覽器所提供的 api，我覺得最簡單的話，<code>setTimeout</code>其實就一種 Web Apis，專門做網頁計時器的功能，<code>setTimeout</code>它主要的核心其實就是非同步的概念，它會延遲的特性註定會跟同步不合，要是在同步延遲的話，就一定要一直等在那邊，直接延遲結束才能繼續下去。</p><p>所以在呼叫 Web APIs 時，很常會使用非同步的方式，我呼叫一個請求，但我不一定要馬上得到回覆。</p><h2 id="Callback-Queue"><a href="#Callback-Queue" class="headerlink" title="Callback Queue"></a>Callback Queue</h2><p>我自己把它當作一個等待排隊的地方，它跟<code>Call Stack</code>特性有點不一樣，是一個先進先出的概念，但這也蠻合理的，想像一下先進去排隊的人，因為他比要早去排隊，所以理所當然可以先結束排隊的這個狀態，非常合理。</p><p>為什麼有這個的存在，是因為不可能永遠一次只處理一個<code>callback funtion</code>，當有很多個<code>callback funtion</code>已經丟到<code>Call Stack</code>，時間先結束的就會先丟到<code>Callback Queue</code>等待排隊。</p><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p><code>JavaScript</code>執行非同步的方式，會使用到非同步的<code>callback</code>，假如有很多個，這些很多個的<code>callback funtion</code>就會進去到<code>Callback Queue</code>排隊，然後在執行階段的時候，會去判斷現在的<code>callback</code>裡面有沒有東西，當<code>callback</code>是空的時候，<code>Callback Queue</code>排隊的東西就會被丟進去，一次只能一個。</p><p>所以說，這也是一種一次做一件事情的方式，也是<code>JavaScript</code>如何使用並行的方式來執行非同步。</p><p>而因為非同步的東西會通通給丟去排隊的原因，所以非同步的函式永遠都會比同步的慢，同步的函式在執行<code>call stack</code>時就會把它結束掉，不會有進去到<code>Callback Queue</code>的機會。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>而關於<code>JavaScript</code>難道永遠就只能單執行緒，沒有例外嗎？<br>研究過後，有一種新的技術，它叫做<code>Web Workers</code>，據說是可以使用到其他的執行緒，不過我個人還沒有使用過，有興趣的可以依據這個關鍵字研究看看。</p><p>雖然非同步要用到<code>callback</code>，但之前要提到會有很可怕的<code>callback hell</code>問題，所以關於非同步的用法，<code>JavaScript</code>之後有一種更好的寫法，叫做<code>promise</code>，這個就是下一次要講的主題，我們明天見。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">The event loop</a><br>[2] <a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/eventloop.html">異步程式設計與事件迴圈</a><br>[3] <a href="https://blog.huli.tw/2019/10/04/javascript-async-sync-and-callback/">JavaScript 中的同步與非同步（上）：先成為 callback 大師吧！</a><br>[4] <a href="https://ithelp.ithome.com.tw/articles/10221944">JS 原力覺醒 Day13 - Event Queue &amp; Event Loop 、Event Table</a><br>[5] <a href="https://chanchandev.com/js/Async/async-sync-intro/2534378084/">Javascript 非同步 &amp; Event Loop！10 分鐘輕鬆圖解學習！</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day12 - Asynchronous Programming (非同步程式設計)</title>
      <link href="/2022/09/27/JS12/"/>
      <url>/2022/09/27/JS12/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Asynchronous</code>的中文翻譯是非同步、異步，<code>Synchronous</code>的中文翻譯是同步，以下都會直接用同步、非同步來介紹。</p><span id="more"></span><p>非同步程式設計是<code>JavaScript</code>在學習時一個很大的重點，不光是容易誤解，不好理解，也因為實際上要常常使用到。</p><p>這一篇不講太多專業術語跟程式範例，會試著用很白話的方式把非同步這件事情給講清楚，那就直接開始進入今天的主題！</p><h2 id="JavaScript是單一執行緒"><a href="#JavaScript是單一執行緒" class="headerlink" title="JavaScript是單一執行緒"></a><code>JavaScript</code>是單一執行緒</h2><p>這是我覺得在了解同步跟非同步之前要先理解的第一個點，先完全不要管什麼是同步，什麼是非同步，一開始請先知道這個：</p><p><strong>Javascript 程式執行，一次只能執行一件事情</strong>。</p><p>就像是一家餐廳，就只有一個廚師，那他就只能一次煮一道菜，假如有兩個廚師，就是同時煮兩道菜，很多廚師可以同時煮很多菜那就是多執行緒，可以一次同時進行很多事情。</p><p>無論如何，要記住這家叫做「Javascript」的餐廳，永遠只有一個廚師(執行緒)。</p><h2 id="JavaScript-同步跟非同步"><a href="#JavaScript-同步跟非同步" class="headerlink" title="JavaScript 同步跟非同步"></a><code>JavaScript</code> 同步跟非同步</h2><p>剛開始學習時，同步會讓人感覺是，全部的動作同時開始進行，所以容易誤會(誤會同步&#x3D;同時)。<br>後來去查閱一些資料後發現其實同步是 &#x3D;&gt; 一次做一件事情。<br>既然同步是一次做一件事情，那非同步不就是一次做很多事情？</p><p>所以會發現到說很多教學文章會這樣寫：</p><blockquote><p>同步：一次就只做一件事情<br>非同步：一次同時做很多件事情</p></blockquote><p>使用”同時間”能處理事情的多寡來區分 JS 的同步跟非同步的文章真的很多。<br>可能這講法也沒有錯，但就會發生衝突，對剛學習沒多久的人造成心靈打擊，造成懂的人看得懂，不懂的人看不懂。</p><p>而我的理解 &#x3D;&gt;<br>單執行緒的<code>JavaScript</code>就像是餐廳的只有一個廚師，假如要說非同步是一次同時做很多件事情，就好似說突然冒出一堆廚師一樣，最主要發生的衝突，就是上面說的：</p><p><strong>Javascript 程式執行，一次只能做一件事情</strong>。</p><p>也許可以用很多個廚師，同時做很多事情的方法來做到非同步，但我<code>JavaScript</code>就只有一個廚師，怎麼辦呢？</p><p>先來看看另一個概念吧。</p><h2 id="平行-Parallelism-與並行-Concurrency"><a href="#平行-Parallelism-與並行-Concurrency" class="headerlink" title="平行(Parallelism)與並行(Concurrency)"></a>平行(Parallelism)與並行(Concurrency)</h2><p>這個概念是我從<a href="https://www.ithome.com.tw/voice/91464">執行資料平行處理的效能考量</a>看到的，我覺得可以很好的解釋<code>JavaScript</code>如何在自身只能是單執行緒的情況下，達成到非同步的效果，同時又不會跟單執行緒的特性(一次做一件事情)發生衝突。</p><p>以下節錄文章概念：</p><blockquote><p>平行（Parallelism）與並行（Concurrency）不同，如果兩個任務分配到一個 CPU 核心，在取得的時間片段中交互執行，稱之為並行。如果有兩個核心，兩個任務各分配到其中之一同時執行，稱之為平行。現今開發者對於並行設計應不陌生，利用並行運算處理多個流程，讓客戶端以為任務「同時」執行，或者是某任務被阻斷（Block）之時，切換另一任務執行，避免等待而浪費 CPU 執行時間，用以提升整體任務執行效率。</p></blockquote><p>很好的解釋了一些盲點區域，上面有提到很多教學會講說非同步是一次同時做很多事情，其實那就是一種平行處理，確實也是一種非同步，但卻永遠不可能是<code>JavaScript</code>的非同步。</p><p>因為<code>JavaScript</code>這間餐廳的廚師就只有一個，要有很多人才能平行耶，我畫示意圖比較清楚。</p><p>多人廚師 &#x3D;&gt; 平行處理 &#x3D;&gt; 同時做很多菜 &#x3D;&gt; 大家都很開心：<br><img src="https://i.imgur.com/GBZWDPq.png"></p><p>只有一個廚師 &#x3D;&gt; 平行處理 &#x3D;&gt; 同時做很多菜 &#x3D;&gt; 廚師不開心 ：<br><img src="https://i.imgur.com/5ETGG5M.png"></p><p>那就一個個慢慢做如何？<br><img src="https://i.imgur.com/qH8ox5q.png"><br>客人不開心。<br>而且中間要是過程有一個卡住，之後的菜也就都不用做了。</p><p>欸，那該怎麼辦，我大<code>JavaScript</code>餐廳就是只想請一個廚師，但又不想要廚師只能一個個做，那會花超久時間，聰明的大<code>JavaScript</code>餐廳想到了一個好辦法，剛剛那個是平行處理，那何不來試試並行處理？</p><p><strong>並行處理:</strong><br>交互執行，稱之為並行，要怎麼辦到這件事情，簡單來說就是不卡住，那是什麼意思？比如來說小白今天要做兩件事情，一個是烤土司一個是倒牛奶，而小白今天就只有一個人，所以沒辦法使用平行處理，除非小白會影分身。</p><p>除了慢慢來，先烤完吐司再倒牛奶之外，還有另外一種選擇，你可以先把你的吐司塞到烤土司機之後，不要在那邊傻傻等它，按下按鈕開始烤後，就衝去冰箱拿牛奶出來倒，倒完再看吐司好了沒。</p><p><strong>這種做完後不停留到完全結束，就直接去做下一步的處理方式其實就是並行處理。</strong></p><p>也因為這樣，所以看起來結果會很像是同時開始做，但是並沒有，可以來比較差異時間，請小白為我們示範一下，示意圖有請：</p><p><img src="https://i.imgur.com/gZM3DuZ.png"></p><p>為什麼有一堆人會覺得 JS 非同步就是「同時」做很多事情，我覺得關鍵這就是在這邊，但因為單執行緒的觀念，就勢必不可能同時(平行處理)，所以 JS 所謂的「非同步」操作，其實是比較偏向示意圖的第三種，也就是並行處理，這也是我個人所理解的 Asynchronous Programming (非同步程式設計)。</p><h2 id="阻塞與非阻塞"><a href="#阻塞與非阻塞" class="headerlink" title="阻塞與非阻塞"></a>阻塞與非阻塞</h2><p>根據上面的想法，我認為同步在處理事件的流程會被「卡住」，卡住的意思是說，當遇到沒辦法馬上執行完成的東西，就會整個停住，下一件要做的事情就會停擺。</p><p>而非同步在處理事件的流程不會被「卡住」，所以因為不會被卡住，所以看起來像是「一次同時做很多件事情」，但實際上沒有。</p><p>而這卡住不卡住其實比較跟阻塞(blocking)與非阻塞(non-blocking)有關，詳細的可以去看 Node.js 的官方文件有講到這一塊：<a href="https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/">Overview of Blocking vs Non-Blocking</a></p><p>這邊只簡單介紹：</p><ul><li>阻塞（blocking）&#x3D;&gt; 代表執行時程式會卡在那一行，直到有結果。</li><li>非阻塞（non-blocking）&#x3D;&gt; 代表執行時不會卡住，沒有看到結果也會繼續執行下去。</li></ul><p>很像剛剛在描述同步跟非同步吧？其實在<code>JavaScript</code>當中，可以把兩個劃上等號，剛剛 Node.js 的官方文件有一段是這樣講的：<br><img src="https://i.imgur.com/MVqKzMb.png"><br>圖片來源：<a href="https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/">Node.js 官方文件</a><br>這段的意思就是，阻塞的方法會同步的方式執行，而非阻塞的方法會非同步的方式執行，所以我會把兩種當作是同一種東西，注意僅限於<code>JavaScript</code>，其他語言可能不一定，要是全部都一模一樣那幹嘛分兩個不一樣的名稱對吧？</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>準備要來下結論了，前面有提過到的一次做很多事情，看完上面的文章，相信你已經知道那並不是<code>JavaScript</code>非同步的特色，<code>JavaScript</code>永遠不會一次做很多事情，而實際上是怎麼在<code>JavaScript</code>做到非同步這件事情的，這就是明天要來講的主題，我們明天見啦～</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing">MDN - Introducing asynchronous JavaScript</a><br>[2] <a href="https://www.w3schools.com/js/js_asynchronous.asp">W3Schools - Asynchronous JavaScript</a><br>[3] <a href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/async%20%26%20performance/ch1.md">You Don’t Know JS - Asynchrony</a><br>[4] <a href="https://chanchandev.com/js/Async/async-sync-intro/2534378084/">Javascript 非同步 &amp; Event Loop！10 分鐘輕鬆圖解學習！</a><br>[5] <a href="https://ithelp.ithome.com.tw/articles/10206211">你懂 JavaScript 嗎？#22 非同步：現在和以後</a><br>[6] <a href="https://ithelp.ithome.com.tw/articles/10194569">重新認識 JavaScript: Day 26 同步與非同步</a><br>[7] <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&ab_channel=JSConf">所以說 event loop 到底是什麼玩意兒？| Philip Roberts | JSConf EU</a><br>[8] <a href="https://blog.huli.tw/2019/10/04/javascript-async-sync-and-callback/">JavaScript 中的同步與非同步（上）：先成為 callback 大師吧！</a><br>[9] <a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/eventloop.html">異步程式設計與事件迴圈</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day11 - Callback Funtion(回呼函式)</title>
      <link href="/2022/09/26/JS11/"/>
      <url>/2022/09/26/JS11/</url>
      
        <content type="html"><![CDATA[<p>這其實不是難懂的概念，但卻是非同步程式設計中最基礎的螺絲釘，我自己在學習這 JS 非同步領域這系列的順序是這樣排的：</p><p><code>Callback =&gt; Promise =&gt; Async/Await</code></p><p>確保自己了解之後，再往下一個階段邁進，對於認知非同步反而會顯得更加輕鬆，不然容易變成拆東牆補西牆。</p><p>這個概念是我從 huli 的<a href="https://blog.huli.tw/2019/10/04/javascript-async-sync-and-callback/">JavaScript 中的同步與非同步（上）：先成為 callback 大師吧！</a>學習到的，也是這篇讓我意識到<code>callback</code>的重要性，推薦可以去看。那麼就開始進入今天的主題。</p><h2 id="Callback-Funtion定義"><a href="#Callback-Funtion定義" class="headerlink" title="Callback Funtion定義"></a><code>Callback Funtion</code>定義</h2><p>學習一個新的名詞術語，想知道它究竟是什麼，有很多方式，<code>Callback</code>來說的話我覺得可以看 MDN 文檔的定義，寫的蠻好理解：</p><blockquote><p>A callback function is a function passed into another function as an argument</p></blockquote><p>中文來說的話就是，當一個函數，作為參數傳遞給另一個函數，就是<code>callback</code>。</p><p>舉例來說：<br>小白、小紅、小黃三個人在工作，可以這樣寫。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">whiteWork</span>();</span><br><span class="line"><span class="title function_">redWork</span>();</span><br><span class="line"><span class="title function_">yellowWork</span>();</span><br></pre></td></tr></table></figure><p>雖然程式會確實的從上到下執行，所以看起來沒有問題，但卻不能保證執行的順序，但今天如果使用<code>Callback</code>就可以，像是我想要小白做完後小紅再開始工作，那我就可以把小紅放到小白的<code>Callback</code>裡面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">whiteWork(function () &#123;</span><br><span class="line"> redWork();</span><br><span class="line">&#125;);</span><br><span class="line">yellowWork();</span><br></pre></td></tr></table></figure><p>這樣子的好處，是讓程式的某個函數執行完，再接著執行其他的函式。</p><p>那換來看看 MDN 的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greeting</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processUserInput</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="title function_">prompt</span>(<span class="string">&quot;Please enter your name.&quot;</span>);</span><br><span class="line">  <span class="title function_">callback</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">processUserInput</span>(greeting);</span><br></pre></td></tr></table></figure><p>這段程式執行後會像是這個樣子。</p><ol><li><p>跳出一個視窗詢問名字。<br><img src="https://i.imgur.com/7RYxEFG.png"></p></li><li><p>輸入名字(vic)，按確定<br><img src="https://i.imgur.com/PSdlQqE.png"></p></li><li><p>跳出”Hello,vic”<br><img src="https://i.imgur.com/uqelKM9.png"></p></li></ol><p>正常沒有使用<code>Callback</code>的版本如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greeting</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processUserInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="title function_">prompt</span>(<span class="string">&quot;Please enter your name.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">processUserInput</span>();</span><br><span class="line"><span class="title function_">greeting</span>();</span><br></pre></td></tr></table></figure><p>但會發現跟上面不一樣，輸入名字後，卻找不到名字。<br><img src="https://i.imgur.com/XuxewSF.png"></p><p>這個就是<code>Callback</code>很重要的地方，這種呼叫後順序不一致的狀態，我想要哪個先呼叫，有時候不是先放前面就沒事了，像是在這邊我雖然把<code>processUserInput()</code>放前面，但不代表後面的<code>greeting()</code>就會乖乖的等上面的問題問完才顯示，在<code>JavaScript</code>的世界裡面，會越快完成的事情會先做完，有一件要等待的事情，一件馬上顯示出來的事情時，不管排序都會先去做那馬上可以完成的，那要是有很多件不確定時間的事情，就會完全無法確認順序。</p><p>但是有了<code>Callback</code>就不一樣，可以藉由某個做完再呼叫的機制，確保順序，在這種單執行緒的環境下，<code>JavaScript</code>沒辦法像是其他程式語言可以直接多工去同時做很多事情，所以需要有一種「被呼叫才做事」的功能，這也是我理解為什麼需要一個函數，作為參數傳遞給另一個函數的原因。</p><h2 id="其他比喻"><a href="#其他比喻" class="headerlink" title="其他比喻"></a>其他比喻</h2><p>在其他地方有看到一個用工人來解釋<code>Callback Funtion</code>很好懂的比喻，在<a href="https://whien.medium.com/js20min-day-18-%E9%97%9C%E6%96%BC%E5%9B%9E%E5%91%BC%E7%94%9F%E6%B4%BB%E5%8C%96-callback-1a112db1a788">JS20min Day — 18 關於回呼生活化 (Callback)</a>看到的。</p><p>假如小白跟小黃都是工人。</p><p>小白是一個正在睡覺的工人，被叫時才會起來工作。<br>而小黃是勤奮型工人，他會去工作，也會去叫小白起來工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">whiteWork</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;被小黃叫，來去工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">yellowWork</span>(<span class="params">call</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;先工作，叫小白&quot;</span>);</span><br><span class="line">  <span class="title function_">call</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">yellowWork</span>(whiteWork);</span><br></pre></td></tr></table></figure><p>這樣的執行順序會是： 1.工作，叫小白 2.被小黃叫，來去工作</p><p>就是當一個函數，作為參數傳遞給另一個函數，在這邊小白會作為一個參數去傳遞給小黃這個函數，而本身小白也是一個函數。</p><h2 id="Callback-Hell"><a href="#Callback-Hell" class="headerlink" title="Callback Hell"></a>Callback Hell</h2><p>假如事情一定要一個做完才接著下一個，後面的<code>Callback</code>會需要使用到前面<code>Callback</code>的結果，也就是必須在<code>Callback</code>中再<code>Callback</code>，那整體的架構就勢必沒辦法是平行的，會很複雜，像是這樣。</p><p><img src="https://i.imgur.com/feTzmCc.png"><br>出處：<a href="https://github.com/explooosion/emoji-comment-collection/issues/6">https://github.com/explooosion/emoji-comment-collection/issues/6</a></p><p>就這是多層環環相扣後所產生的波動拳，不只看起來很是複雜，維護起來時也會很麻煩，這也是為什麼後面還需要使用到<code>promise</code>的原因，關於這部分後續幾天會提到，那今天的介紹就到這邊。</p><p>下一篇會講述在<code>JavaScript</code>中的非同步程式設計是怎麼一回事，明天見～</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Glossary/Callback_function">MDN - Callback function</a><br>[2] <a href="https://www.w3schools.com/js/js_callback.asp">W3Schools - JavaScript Callbacks</a><br>[3] <a href="https://javascript.info/callbacks">The Modern JavaScript Tutorial - Introduction: callbacks</a><br>[4] <a href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/async%20%26%20performance/ch2.md">You Don’t Know JS - Callbacks</a><br>[5] <a href="https://ithelp.ithome.com.tw/articles/10206555">你懂 JavaScript 嗎？#23 Callback</a><br>[6] <a href="https://ithelp.ithome.com.tw/articles/10192739">重新認識 JavaScript: Day 18 Callback Function 與 IIFE</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day10 - What is Date ?</title>
      <link href="/2022/09/25/JS10/"/>
      <url>/2022/09/25/JS10/</url>
      
        <content type="html"><![CDATA[<p>一種用來處理特定的日期時間會用到的特殊物件，可以用來印出時間，修改時間或是設定時間。</p><p>要注意的一點是，<code>JavaScript</code>當中，使用<code>Date</code>就會一次把日期跟跟時間創造出來，不能只單獨創造出今天日期。</p><p>最簡單的使用方式就是直接<code>new Date()</code>就能直接創造出當前的時間。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(time); <span class="comment">// 印出當前時間</span></span><br></pre></td></tr></table></figure><p>隨時放入參數的不同可以印出各種不同狀態的時間。<br><code>new Date()</code>是一種，另外還有三種創建時可以創建時的方式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="keyword">new</span> <span class="title class_">Date</span>(milliseconds); <span class="comment">//第二種</span></span><br><span class="line"><span class="keyword">const</span> time = <span class="keyword">new</span> <span class="title class_">Date</span>(dateString); <span class="comment">//第三種</span></span><br><span class="line"><span class="keyword">const</span> time = <span class="keyword">new</span> <span class="title class_">Date</span>(year, month, day, hours, minutes, seconds, milliseconds); <span class="comment">//第四種</span></span><br></pre></td></tr></table></figure><h2 id="獲取時間中某個值"><a href="#獲取時間中某個值" class="headerlink" title="獲取時間中某個值"></a>獲取時間中某個值</h2><p>有一些<code>Date</code>內建的方法，可以幫助獲取時間的某個值，可以分成以下幾種。</p><p>現在時間是 2022 年 9 月 25 日(星期日），使用此時此刻來做舉例，先從取全部開始。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(time); <span class="comment">// 2022-09-25T02:40:23.378Z</span></span><br></pre></td></tr></table></figure><p><strong>getFullYear():</strong><br>可以獲取年份，四位數的那種。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> year = time.<span class="title function_">getFullYear</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(year); <span class="comment">// 2022</span></span><br></pre></td></tr></table></figure><p><strong>getMonth():</strong><br>可以獲取月份，範圍從 1~11(沒有 12)。<br>實際是 9 月，但是顯示抓取會是 8 月，這點要特別注意。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> month = time.<span class="title function_">getMonth</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(month); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p><strong>getDay():</strong><br>可以獲取目前是為一週裡面的第幾天，從星期日開始，所以 0 是星期日，直到 6 是星期六。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> day = time.<span class="title function_">getDay</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(day); <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p><strong>getDate():</strong><br>可以獲取目前是一月裡面的第幾天，從 1 到 31。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> date = time.<span class="title function_">getDate</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date); <span class="comment">//25</span></span><br></pre></td></tr></table></figure><p>比較不直覺的有<code>getMonth()</code>跟<code>getDay()</code>，它們回傳出來的值不能直接是真正的月份跟星期，還需要再透過其他方式來轉換，不過仔細想想也蠻合理，因為月份跟星期在不同地區可能都有不同的規劃，像是說台灣會叫做「星期」其他地方不一定這樣叫，所以<code>Date</code>在這一塊只給一個回傳值，會從 0 開始應該是為了搭配陣列的方式，所以拿到這個回傳值，再搭配自己設定好名字的陣列，就可以取得真正的月份跟星期的值，比如說 1 月&#x3D;&gt;array[0]&#x3D;1 月。</p><p>還有一些要取得更小單位的時間值，像是幾時幾分幾秒，都有相對應的方法，跟上面使用方法都大同小異，如下：</p><ul><li>getHours()</li><li>getMinutes()</li><li>getSeconds()</li><li>getMilliseconds()</li></ul><h2 id="設定時間"><a href="#設定時間" class="headerlink" title="設定時間"></a>設定時間</h2><p>除了獲取時間訊息的「get」之外，有也相對應的「set」，專門用來設定某種時間的格式，例如<code>getDate()</code>是獲取回傳的是第幾天，<code>setDate()</code>就是設定目前時間是第幾天，常用的語法如下：</p><ul><li>setFullYear(year, [month], [date])</li><li>setMonth(month, [date])</li><li>setDate(date)</li><li>setHours(hour, [min], [sec], [ms])</li><li>setMinutes(min, [sec], [ms])</li><li>setSeconds(sec, [ms])</li><li>setMilliseconds(ms)</li><li>setTime(milliseconds)</li></ul><p>設定之外的東西就會維持原來的設定，舉個例子，一樣先用<code>new Date()</code>創造出當前的時間，再用<code>set</code>修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const time = new Date();</span><br><span class="line">time.setFullYear(2000);</span><br><span class="line">console.log(time); //從2022變成2000</span><br></pre></td></tr></table></figure><p>其他方式就大同小異，想改什麼就直接改。</p><h2 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h2><p>本地化的意思，是根據本地的文化或是語言來顯示印出的東西。<br>必要性可以從完全沒經過本地化的案例來看，一樣使用<code>new Date()</code>就能直接創造出當前的時間：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(time); <span class="comment">// 2022-09-25T03:17:31.197Z</span></span><br></pre></td></tr></table></figure><p>直接出來的東西是 2022-09-25T03:17:31.197Z，而使用本地化的方式像是<code>console.log(date.toLocaleString()) </code>就會是：<code>2022/9/25 上午11:18:54</code>。</p><p>看起來會更好辨認，日期，時間，貨幣都可以使用這種本地化的方式，但今天主要聚焦在<code>Date</code>這一塊。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleString</span>()); <span class="comment">// 2022/9/25 上午11:22:28</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleDateString</span>()); <span class="comment">// 2022/9/25</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleTimeString</span>()); <span class="comment">//上午11:22:28</span></span><br></pre></td></tr></table></figure><h2 id="Autocorrection"><a href="#Autocorrection" class="headerlink" title="Autocorrection"></a>Autocorrection</h2><p>當不小心把時間使用<code>set</code>的方式設定超過範圍，<code>Date</code>就會自動進行一個<code>Autocorrection</code>的動作，也就是自動校準，這非常實用。</p><p>也不會需要主動去使用，因為這是一個<code>Date</code>的特性。</p><p>比如說：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> time = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2022</span>, <span class="number">0</span>, <span class="number">50</span>); <span class="comment">// 原本 2022 01 50</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(time); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p>一個月不可能有那麼多天，就會把剩餘超過的<code>Autocorrection</code>到下一個月，所以最後出來的結果會是<code>2022-02-18</code>。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在<code>JavaScript</code>中要處理到時間跟日期就會碰到<code>Date</code>，像是可能網頁上需要做一個時鐘，或是倒數計時器，使用方法上看起來都蠻直覺，但還有很多小地方需要注意，今天其實還有蠻多<code>Date</code>部分還沒講到，像是<code>Date.now()</code>、<code> Date.parse</code>，或是一堆還沒講到方法，有興趣可以再去看 MDN 的文檔，連結有放最下面。</p><p>最後有一個蠻有趣的現象，就是可以試試看<code>new Date() + 1</code>跟<code>new Date() - 1</code>這兩種方式個別印出來的結果，我個人是一頭霧水，知道原因的高手可以在下方留言告訴我，那我們明天見。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="number">1</span>); <span class="comment">// ??</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>() - <span class="number">1</span>); <span class="comment">// ??</span></span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date">MDN - Date</a><br>[2] <a href="https://javascript.info/date">Date and time</a><br>[3] <a href="https://www.w3schools.com/js/js_dates.asp">JavaScript Date Objects</a><br>[4] <a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part3/datetime.html">日期與時間</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day09 - What is Map ?</title>
      <link href="/2022/09/24/JS09/"/>
      <url>/2022/09/24/JS09/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天把<code>set</code>講完，今天換<code>Map</code>，首先要注意不要跟<code>array</code>的方法<code>Array.prototype.map()</code>搞混，這是不一樣的東西，那就 let’s go 今天的主題。</p><p><code>Map</code>跟<code>object</code>一樣都是<code>key-value pairs</code>，不同的是<code>Map</code>的<code>key</code>可以是任意類型。</p><h2 id="map-的基本方法跟屬性"><a href="#map-的基本方法跟屬性" class="headerlink" title="map 的基本方法跟屬性"></a>map 的基本方法跟屬性</h2><ul><li>new Map() &#x3D;&gt; 創造 map。</li><li>set() &#x3D;&gt; 為 map 裡面設定 key 跟 value。</li><li>get() &#x3D;&gt; 取出 map 裡面的 key 跟 value。</li><li>delete() &#x3D;&gt; 刪除 map 裡面的 key。</li><li>has() &#x3D;&gt; map 裡存在指定的 key。</li><li>clear() &#x3D;&gt; 刪除 map 裡面所有東西。</li><li>size &#x3D;&gt; 會回傳 map 裡面元素的數量。</li></ul><p>有些其實跟<code>set</code>來使用看看吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map); <span class="comment">// Map(0) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ↑一開始創建出來，map裡面是空的</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map); <span class="comment">// Map(3) &#123; 1 =&gt; &#x27;a&#x27;, 2 =&gt; &#x27;b&#x27;, 3 =&gt; &#x27;c&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ↑幫map新設定了三組key跟value</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="number">1</span>)); <span class="comment">// a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ↑從map裡面取出key是1的value</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map); <span class="comment">// Map(2) &#123; 2 =&gt; &#x27;b&#x27;, 3 =&gt; &#x27;c&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ↑把map裡面key是1的那一個key-value pairs刪除</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">has</span>(<span class="number">1</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">has</span>(<span class="number">2</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ↑判斷map裡面有沒有叫做1跟2的key</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ↑map裡面數量有兩個</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">clear</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map); <span class="comment">// Map(0) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ↑把map裡面所有東西都清空</span></span><br></pre></td></tr></table></figure><h2 id="除了用set-添加元素外，也能透過array添加"><a href="#除了用set-添加元素外，也能透過array添加" class="headerlink" title="除了用set()添加元素外，也能透過array添加"></a>除了用<code>set()</code>添加元素外，也能透過<code>array</code>添加</h2><p>先創立一個<code>Map</code>的空間出來，再<code>set()</code>是比較直覺添加元素的方式，但其實也可以直接在創建時就添加完畢，只要最開始創建的<code>new Map()</code>就直接塞<code>array</code>就可以達成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;apple&quot;</span>, <span class="number">10</span>],</span><br><span class="line">  [<span class="string">&quot;banana&quot;</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="string">&quot;orange&quot;</span>, <span class="number">10</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits);</span><br><span class="line"><span class="comment">// Map(3) &#123; &#x27;apple&#x27; =&gt; 10, &#x27;banana&#x27; =&gt; 5, &#x27;orange&#x27; =&gt; 10 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="set-除了可以添加元素外，也可以重新設置現有元素"><a href="#set-除了可以添加元素外，也可以重新設置現有元素" class="headerlink" title="set()除了可以添加元素外，也可以重新設置現有元素"></a><code>set()</code>除了可以添加元素外，也可以重新設置現有元素</h2><p><code>set()</code>在完全沒有東西時，是添加元素的功能，但在已經有東西的地方上，假如又在使用<code>set()</code>添加在同一個<code>key</code>東西上去，會直接覆蓋上一個<code>key</code>的<code>value</code>，因為同一組<code>key</code>只能同時擁有一組<code>value</code>，而這種方式也能達到重新設置現有元素的功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">fruits.<span class="title function_">set</span>(<span class="string">&quot;apple&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits); <span class="comment">// Map(1) &#123; &#x27;apple&#x27; =&gt; 10 &#125;</span></span><br><span class="line"></span><br><span class="line">fruits.<span class="title function_">set</span>(<span class="string">&quot;apple&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits); <span class="comment">// Map(1) &#123; &#x27;apple&#x27; =&gt; 5 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="創立-map-是使用new-Map-，那我不想new行不行？"><a href="#創立-map-是使用new-Map-，那我不想new行不行？" class="headerlink" title="創立 map 是使用new Map()，那我不想new行不行？"></a>創立 map 是使用<code>new Map()</code>，那我不想<code>new</code>行不行？</h2><p>不行，<code>Map</code>一定只能用<code>new operator</code>來建立，<code>JavaScript</code>就是這樣規定的，不這樣做就會送你報錯。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//TypeError: Constructor Map requires &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure><p>可以理解成一些特別的內建物件會需要用構造函數的方式來進行物件的實體化。<br>順帶一提，<code>Set</code>也是一定要用<code>new operator</code>，不然會送報錯。</p><h2 id="Map-用途"><a href="#Map-用途" class="headerlink" title="Map 用途"></a>Map 用途</h2><p>當希望物件的<code>key</code>不會重複時，可以使用<code>Map</code>，或者是想要讓物件的<code>key</code>是各種型別的時候。</p><p>還有順序如果很重要的話，就會考慮使用<code>Map</code>，因為使用<code>Map</code>時元素的使用順序會被保留。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">MDN - Map</a><br>[2] <a href="https://hackmd.io/5MY4uwR2TUOQmTLmk1f8xQ">W3Schools - JavaScript Maps</a><br>[3] <a href="https://javascript.info/map-set">The Modern JavaScript Tutorial - Map and Set</a><br>[4] <a href="https://www.muji.dev/2020/01/05/iron30-29">JS 原力覺醒 Day29 - Set &#x2F; Map</a><br>[5] <a href="https://pjchender.dev/javascript/js-map/">PJCHENder -JavaScript Map</a><br>[6] <a href="https://ithelp.ithome.com.tw/articles/10214746">前端工程師用 javaScript 學演算法 - Map</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day08 - What is Set ?</title>
      <link href="/2022/09/23/JS08/"/>
      <url>/2022/09/23/JS08/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這兩天會來講<code>Set/Map</code>，這是<code>ES6</code>後才新增的兩種資料結構，主要是用來處理一些<code>array</code>跟<code>object</code>沒辦法完全顧及的領域，也因如此，其實許多地方跟<code>array</code>跟<code>object</code>非常相似，那今天就從<code>set</code>開始吧！</p><p><code>set</code>是集合的意思，在<code>JavaScript</code>裡是唯一值的集合，意思就是說，<code>set</code>裡面的每一個值都只能出現一次。</p><h2 id="什麼是集合？"><a href="#什麼是集合？" class="headerlink" title="什麼是集合？"></a>什麼是集合？</h2><p>set 的中文翻譯是集合的意思，在 JavaScript 裡這個語法是唯一值的集合，而數學上的集合定義，去爬了維基百科，得到以下結論：</p><blockquote><p>指具有某種特定性質的事物的母體，集合裡的事物稱作元素。</p></blockquote><p>下圖就是一個有一些多邊形的集合。關於集合我的理解是可以把它當作一堆類型差不多的東西，而在<code>JavaScript</code>就是一堆值，而在<code>array</code>確實就只有一大堆值，跟<code>Set</code>的差別就在於，JS 的<code>Set</code>值是獨一無二的。</p><p><img src="https://i.imgur.com/l69soAK.png"></p><h6 id="出處-https-zh-wikipedia-org-zh-tw-E9-9B-86-E5-90-88-28-E6-95-B0-E5-AD-A6-29"><a href="#出處-https-zh-wikipedia-org-zh-tw-E9-9B-86-E5-90-88-28-E6-95-B0-E5-AD-A6-29" class="headerlink" title="出處: https://zh.wikipedia.org/zh-tw/%E9%9B%86%E5%90%88_%28%E6%95%B0%E5%AD%A6%29"></a>出處: <a href="https://zh.wikipedia.org/zh-tw/%E9%9B%86%E5%90%88_%28%E6%95%B0%E5%AD%A6%29">https://zh.wikipedia.org/zh-tw/%E9%9B%86%E5%90%88_%28%E6%95%B0%E5%AD%A6%29</a></h6><h2 id="set常用方法與屬性"><a href="#set常用方法與屬性" class="headerlink" title="set常用方法與屬性"></a><code>set</code>常用方法與屬性</h2><ul><li>new Set() &#x3D;&gt; 創建一個<code>set</code></li><li>add() &#x3D;&gt; 往<code>set</code>裡面新增一個元素</li><li>delete() &#x3D;&gt; 從<code>set</code>裡面刪除一個元素</li><li>has() &#x3D;&gt; 判斷<code>set</code>有沒有存在指定的元素</li><li>clear() &#x3D;&gt; 刪除<code>set</code>裡面所有東西</li><li>size &#x3D;&gt; 回傳整個<code>set</code>裡面元素的種類量</li></ul><p>以下簡單實作一次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const vicSet = new Set([1, 2, 2, 3]);</span><br><span class="line">console.log(vicSet); // Set(3) &#123; 1, 2, 3 &#125;</span><br><span class="line"></span><br><span class="line">// ↑一開始創建出來，set裡面是空的</span><br><span class="line"></span><br><span class="line">set.add(4);</span><br><span class="line">console.log(vicSet); // Set(4) &#123; 1, 2, 3, 4 &#125;</span><br><span class="line"></span><br><span class="line">// ↑幫set新增加了4這個元素進去</span><br><span class="line"></span><br><span class="line">set.delete(1);</span><br><span class="line">console.log(vicSet); // Set(3) &#123; 2, 3, 4 &#125;</span><br><span class="line"></span><br><span class="line">// ↑把1這個元素從set完整的刪除</span><br><span class="line"></span><br><span class="line">console.log(vicSet.has(1), vicSet.has(2)); // false true</span><br><span class="line"></span><br><span class="line">// ↑判斷set裡面有沒有這些指定的元素</span><br><span class="line"></span><br><span class="line">console.log(vicSet.size); // 3</span><br><span class="line"></span><br><span class="line">// ↑這個屬性將會找出set裡面元素的種類</span><br><span class="line"></span><br><span class="line">set.clear();</span><br><span class="line">console.log(vicSet); // Set(0) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// ↑把map裡面所有東西都清空</span><br></pre></td></tr></table></figure><h2 id="拿不出的值，跟沒有-index-的Set"><a href="#拿不出的值，跟沒有-index-的Set" class="headerlink" title="拿不出的值，跟沒有 index 的Set"></a>拿不出的值，跟沒有 index 的<code>Set</code></h2><p>我嘗試從<code>set</code>裡面拿到值，但發現拿不出來，why?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vicSet = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cicSet[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>因為<code>set</code>實際上就沒有 index，所以沒有辦法從<code>set</code>獲取值，可能也沒有必要，不然就會發明出一個叫做 get()的方法對吧？</p><p>我想只需要知道，某一個值是不是還存在於集合裡面，所以有 has()的方法可以檢查，畢竟<code>set</code>的特點是獨一無二的值，都是唯一的，順序沒有意義。</p><p>沒有必要在<code>set</code>獲取值的原因是，如果目的是為了按照順序存取值，然後去獲取它，**那就應該要去用<code>array</code>，而不是<code>Set</code>**。</p><p>可以想像成是，假如我有五顆蘋果要塞入一個盤子集合裡面：</p><p>用<code>set</code>的方式 &#x3D;&gt; 盤子裡有一個種類 - 蘋果 (不知道誰先誰後)。<br>用<code>array</code>的方式 &#x3D;&gt; 蘋果陸陸續續地進到了盤子裡面 (知道誰先誰後)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plate = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;apple&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(plate[<span class="number">3</span>]); <span class="comment">// apple, 第四顆進去的蘋果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plate2 = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">plate2.<span class="title function_">add</span>([<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;apple&quot;</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(plate2); <span class="comment">//Set(1), 一個種類 蘋果</span></span><br></pre></td></tr></table></figure><h3 id="那我又想要有set的特性，又想要有array的-index-使用方式要怎麼做？"><a href="#那我又想要有set的特性，又想要有array的-index-使用方式要怎麼做？" class="headerlink" title="那我又想要有set的特性，又想要有array的 index 使用方式要怎麼做？"></a>那我又想要有<code>set</code>的特性，又想要有<code>array</code>的 index 使用方式要怎麼做？</h3><p>用<code>set</code>把資料都處理完後，再轉成<code>array</code>，就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vicSet = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrVicSet = <span class="title class_">Array</span>.<span class="title function_">from</span>(vicSet);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrVicSet[<span class="number">0</span>]); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="Set-可以被迭代"><a href="#Set-可以被迭代" class="headerlink" title="Set 可以被迭代"></a>Set 可以被迭代</h2><p>這代表著使用 <code>for..of</code> 或 <code>forEach</code> 来遍歷 <code>Set</code>。<br>基本上跟<code>array</code>都一樣，因為都是 Iterable(可迭代)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;vic&quot;</span>, <span class="string">&quot;book&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> order <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;for..of 方法: &quot;</span> + order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">order</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;forEach: &quot;</span> + order);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for..of 方法: apple</span></span><br><span class="line"><span class="comment">// for..of 方法: vic</span></span><br><span class="line"><span class="comment">// for..of 方法: book</span></span><br><span class="line"><span class="comment">// forEach: apple</span></span><br><span class="line"><span class="comment">// forEach: vic</span></span><br><span class="line"><span class="comment">// forEach: book</span></span><br></pre></td></tr></table></figure><h3 id="Set迭代方法"><a href="#Set迭代方法" class="headerlink" title="Set迭代方法"></a><code>Set</code>迭代方法</h3><ul><li>set.keys() &#x3D;&gt; 遍歷 set</li><li>set.values() &#x3D;&gt; 遍歷 set</li><li>entries() &#x3D;&gt; 遍歷 set 後再返回一個實體</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const vicSet = new Set([1, 2, 2, 3, 4, 5]);</span><br><span class="line"></span><br><span class="line">console.log(vicSet.keys()); //[Set Iterator] &#123; 1, 2, 3, 4, 5 &#125;</span><br><span class="line"></span><br><span class="line">console.log(vicSet.values()); //[Set Iterator] &#123; 1, 2, 3, 4, 5 &#125;</span><br><span class="line"></span><br><span class="line">console.log(vicSet.entries()); //[Set Entries] &#123; [ 1, 1 ], [ 2, 2 ], [ 3, 3 ], [ 4, 4 ], [ 5, 5 ] &#125;</span><br></pre></td></tr></table></figure><h2 id="Set-實際上使用時機-x3D-gt-刪除-arr-的重複值"><a href="#Set-實際上使用時機-x3D-gt-刪除-arr-的重複值" class="headerlink" title="Set 實際上使用時機&#x3D;&gt; 刪除 arr 的重複值"></a>Set 實際上使用時機&#x3D;&gt; 刪除 arr 的重複值</h2><p>這邊會用到一個概念 <code>Spread Operator</code>(展開運算符)。</p><h3 id="Spread-Operator"><a href="#Spread-Operator" class="headerlink" title="Spread Operator"></a>Spread Operator</h3><p>es6 才出來的一個新語法，來介紹一下它的作用。<br>其實就是展開的概念，看下面我寫的簡單範例應該就能了解。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> B = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...A];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(B); <span class="comment">//[ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure><p><code>...</code>在當<code>Spread Operator</code>時，後面一定接著一個陣列，然後功用就是會把這個陣列給展開，像是上面範例那樣，常常用於來連接陣列，但是還有另外一種方法。</p><p>只要<code>...</code>前面沒東西時，後面也是會展開，但因為前面沒東西，就像是直接複製的感覺，所以也可以來當作陣列的淺拷貝(淺拷貝意思是改 arr2 不會影響到 arr)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [...arr];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>使用剛剛前面講到的<code>Spread Operator</code>，搭配<code>set</code>的特性，先把陣列裡面的值都變成<code>set</code>獨一無二的值之後，再用<code>Spread Operator</code>複製起來到一個新的陣列，大功告成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newValues = <span class="title function_">unique</span>(values);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newValues); <span class="comment">// [ 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>首先要先了解<code>Array.from</code>是什麼，在這裡要知道的是它可以把<code>set</code>的東西轉成陣列，所以一樣是先把陣列裡面的值都變成<code>set</code>獨一無二的值之後，再轉成一個新的陣列，完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newValues = <span class="title function_">unique</span>(values);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newValues); <span class="comment">// [ 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>最後來講講跟<code>Set</code>長得很像的<code>WeakSet</code>，其實不會差太多，但還是有一些差異。</p><p>像是會習慣在<code>Set</code>使用<code>array</code>但是在<code>WeakSet</code>使用時會報錯，這是因為在<code>WeakSet</code>只能增加<code>object</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">WeakSet</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set); <span class="comment">//TypeError: Invalid value used in weak set</span></span><br></pre></td></tr></table></figure><p>而跟<code>WeakSet</code>一樣的地方是會保留<code>Set</code>的一些方法：</p><ul><li>add()</li><li>delete()</li><li>has()</li></ul><p>但是<code>size</code>就沒辦法使用要特別注意。</p><p>那<code>Set</code>要變成<code>WeakSet</code>的用意在哪裡？從字面意思上來看，<code>weak</code>是虛弱的意思，而虛弱的<code>Set</code>也沒辦法讓人直覺想到東西。</p><p>從 MDN 的解釋來看：</p><blockquote><p>The WeakSet is weak, meaning references to objects in a WeakSet are held weakly. If no other references to an object stored in the WeakSet exist, those objects can be garbage collected.</p></blockquote><p>來源：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet">MDN</a></p><p>後面那段大意是說如果不存在對儲存在物件的其他引用，就可以把這些物件進行垃圾回收。</p><p>意思是如果有個物件使用<code> WeakSet</code>之後，如果其他物件都不再引用這個物件，那就會有一個垃圾回收的機制，這個機制可能就是把這個對象所佔用的內存通通消滅掉，丟到垃圾桶。</p><p>這樣做有一些好處，首先變成<code>Weak</code>(弱)狀態的同時，可以想像成多了一個空間，可以拿來檢查，同時因為有<code>Set</code>的特性，獨一無二沒辦法重複。</p><p>主要用來判斷是跟否，而不是拿來做使用，所以是沒辦法拿出來獲取的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> weakSet = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> c = &#123; <span class="attr">c</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">weakSet.<span class="title function_">add</span>(a);</span><br><span class="line">weakSet.<span class="title function_">add</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(weakSet); <span class="comment">// WeakSet &#123; &lt;items unknown&gt; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(weakSet.<span class="title function_">has</span>(a)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(weakSet.<span class="title function_">has</span>(c)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>要直接清除掉只要再使用<code>null</code>就好。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(weakSet.<span class="title function_">has</span>(a)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>簡單來說，<code>WeakSet</code>可以做的幾件事情：</p><ol><li>幫其他地方的物件做一個額外的存取空間(集合)。</li><li>將物件弱連結(weak)到集合中 &#x3D;&gt; add() 。</li><li>判斷這個物件有沒有成功有連結(佔用)了 &#x3D;&gt; true、false。</li><li>從集合中刪除這個物件 &#x3D;&gt; null 。</li></ol><p>什麼情境會使用到呢？<br>個人覺得是很怕犯錯，需要避免錯誤時，可以在這個被「隔離」的集合內做檢查。</p><p>而 MDN 上面有提到說，可以用來檢測循環引用，這個我看起來也因為需要避免錯誤(迭代時涉及循環引用的錯誤)，有興趣可以去研究看看。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">MDN - Set</a><br>[2] <a href="https://www.w3schools.com/js/js_object_sets.asp">W3Schools - JavaScript Sets</a><br>[3] <a href="https://javascript.info/map-set">The Modern JavaScript Tutorial - Map and Set</a><br>[4] <a href="https://www.muji.dev/2020/01/05/iron30-29">JS 原力覺醒 Day29 - Set &#x2F; Map</a><br>[5] <a href="https://pjchender.dev/javascript/js-set/">PJCHENder -JavaScript 集合（Set）</a><br>[6] <a href="https://ithelp.ithome.com.tw/articles/10214228">前端工程師用 javaScript 學演算法 - 集合 Set</a><br>[7] <a href="https://zh.wikipedia.org/zh-tw/%E9%9B%86%E5%90%88_(%E6%95%B0%E5%AD%A6)">維基百科 - 集合 (數學)</a><br>[8] <a href="https://stackoverflow.com/questions/44715210/how-to-get-index-based-value-from-set">How to get index based value from Set</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day07 - 語法糖Class(下)</title>
      <link href="/2022/09/22/JS07/"/>
      <url>/2022/09/22/JS07/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天會來繼續介紹語法糖<code>Class</code>的語法部分，會介紹到的分別為:</p><ul><li>「extends」、「super」 keywords</li><li>static properties and methods</li></ul><h2 id="extends-and-super"><a href="#extends-and-super" class="headerlink" title="extends and super"></a>extends and super</h2><p>首先昨天已經知道了，<code>class</code>可以依靠<code>constructor</code>跟<code>prototype</code>的原理來去實作出像是其他程式語言的繼承效果，但是<code>class</code>以及<code>class</code>之間的繼承還是一個問題，為了這件事情，<code>JavaScript</code>有提供在<code>class</code>中可以使用<code>extends</code>跟<code>super</code>來解決這件事情。</p><p>原本單純使用<code>class</code>來寫會是長這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br></pre></td></tr></table></figure><p>使用<code>extends</code>關鍵字的語法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span></span><br></pre></td></tr></table></figure><p>這邊使用 MDN 上面的範例修改過後來做講解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>說話了。`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name); <span class="comment">// call the super class constructor and pass in the name parameter</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>正在叫。`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Mitzie&quot;</span>);</span><br><span class="line">a.<span class="title function_">speak</span>(); <span class="comment">// Mitzie barks.</span></span><br></pre></td></tr></table></figure><p>一步步去拆分<code>extends</code>跟<code>super</code>做了哪些事情。</p><ol><li>會發現說 Dog 使用 <code>extends</code> 指定 Animal <code>class</code></li></ol><p>Dog 這個新的<code>class</code>想要獲得 Animal 這個舊的<code>class</code>的繼承，相當於就直接繼承了 Animal 裡面所有的<code>Properties</code> 和 <code>Method</code>，那這邊會有一個問題出現，那<code>super</code>的作用何在？</p><ol start="2"><li>用 <code>super</code> 呼叫 <code>extends</code> 指定的 Animal <code>class</code></li></ol><p>沒有加<code>super</code>直接把<code>super(name);</code>給刪掉的話，會報錯，訊息如下：</p><blockquote><p>ReferenceError: Must call super constructor in derived class before accessing ‘this’ or returning from derived constructor</p></blockquote><p>但如果是把:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="variable language_">super</span>(name);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>這段完全刪掉的話，不會報錯，然後結果也看起來一模一樣。<br>這是因為今天如果不需要透過 Dog 去新增屬性(就是寫在<code>constructor</code>裡面的東西)，只是增加方法，或是使用繼承而來的方法，那就可以把<code>super</code>省略掉也可以。</p><p>簡單來說，用到<code>super</code>可以讓<code>JavaScript</code>判斷說 <code>extends</code> 過的那個 class，有沒有需要替換掉那個繼承的東西，示意圖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    // 現在這個裡面的東西會被當成 Dog.stop()</span><br><span class="line">    // 而不是被當成來自於 class Animal 的 speak()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JavaScript</code>沒辦法判斷到底要以誰的為準，所以創造出了叫做<code>super</code>的關鍵字，主要的功能如下：</p><ul><li>使用 supe(…)的方式，來指定可以使用繼承的<code>constructor</code></li><li>使用 super.method(…)的方式來直接呼叫那個方法</li></ul><p>假如說，我想要讓 Dog 創造出來的實例在說話<code>speak()</code>時，多說一句你好<code>sayHi()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.speed = 0;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(`$&#123;this.name&#125;說話了。`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    console.log(&quot;hi&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    super.speak();</span><br><span class="line">    this.sayHi();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const a = new Dog(&quot;dog&quot;);</span><br><span class="line">a.speak(); //dog說話了。 hi</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>這樣的話，就是讓 Dog 在繼承了 Animal 這個 class 所有的屬性之外，也可以去使用 Animal 的 speak()方法，然後在這個基礎之外，再去新增新的功能也是沒有問題。</p><p>透過這種使用<code>extends</code>跟<code>super</code>的搭配就可以做到讓彼此 class 之間的繼承。</p><h2 id="static-methods-and-properties"><a href="#static-methods-and-properties" class="headerlink" title="static methods and properties"></a>static methods and properties</h2><p><code>static methods</code>中文是叫做靜態方法，就是我可以在 class 裡面的<code>constructor</code>去進行呼叫靜態方法，但創造出來的實例是無法去取用的，舉例來說：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">sayHello</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span>,How are you`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">sayHello</span>(<span class="string">&quot;vic&quot;</span>);</span><br></pre></td></tr></table></figure><p>假如使用<code>static</code>這個關鍵字在 class 內的 Method 中，那個 Method 就會變成<code>static method</code>，像這邊來說，<code>Person</code>就變得可以使用<code>sayHello</code>這個方法，但同時創造出來的實例就將會變得無法執行，可以來試試看。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> apple = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"></span><br><span class="line">apple.<span class="title function_">sayHello</span>(); <span class="comment">// TypeError: apple.sayHello is not a function</span></span><br></pre></td></tr></table></figure><p>會報錯，找不到無法使用。</p><p>可以理解成，一般狀態下是動態的，創建出來的實例可以隨著自身的<code>class</code>動態使用它，可以用<code>static</code>使其變成靜態，在靜態時可以直接從<code>class</code>取用方法。</p><p>而關於靜態時候的屬性也是可以做得到的，靜態就屬性就代表可以直接從<code>class</code>取用的屬性，舉例來說：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Apple &#123;</span><br><span class="line">  static color = &quot;red&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Apple.color); // red</span><br></pre></td></tr></table></figure><p>加上了<code>static</code>的屬性就可以直接在<code>class</code>去使用的，像上面就可以直接用 Apple 去取得 color 的屬性，就其實就相當於直接給 Apple 做一個賦值的動作。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>今天介紹了一些<code>Class</code>語法糖的使用方式，可能就算不會寫<code>class</code>也一樣可以寫<code>JavaScript</code>，但是學會了這個技巧可以幫助成為自己成為一個更棒的工程師，基本的 class 就先介紹到這邊～</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">MDN - Classes</a><br>[2] <a href="https://medium.com/enjoy-life-enjoy-coding/javascript-es6-%E4%B8%AD%E6%9C%80%E5%AE%B9%E6%98%93%E8%AA%A4%E6%9C%83%E7%9A%84%E8%AA%9E%E6%B3%95%E7%B3%96-class-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-23e4a4a5e8ed">JavaScript | ES6 中最容易誤會的語法糖 Class - 基本用法</a><br>[3] <a href="https://javascript.info/class-inheritance">Class inheritance</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day06 - 語法糖Class(上)</title>
      <link href="/2022/09/21/JS06/"/>
      <url>/2022/09/21/JS06/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在介紹完<code>prototype</code>之後，該是來理解<code>JavaScript</code>的<code>class</code>，之前有提到說，<code>JavaScript</code>的繼承依靠的是<code>Prototypal inheritance</code>，但並不是所有的程式語言都是如此，我覺得要理解<code>class</code>的話要從這裡下手，那就開始吧。</p><h2 id="其他程式語言的繼承"><a href="#其他程式語言的繼承" class="headerlink" title="其他程式語言的繼承"></a>其他程式語言的繼承</h2><p>之前有提到過繼承，其實道理差不多，一個物件可以將自己的屬性跟方法給其他人使用，換句話說，一個物件可以去取用別人物件的屬性跟方法。</p><p>在<code>JavaScript</code>中，這種可以被取用屬性跟方法的物件是原型物件，透過原型鏈來找到跟綁定，但是在其他語言中，像是<code>java</code>或是<code>c++</code>就會直接把這個可以被取用屬性跟方法的物件視為<code>class</code>，一個類別的概念。</p><p>關於類別的比喻，有一個我覺得很不錯，出處是在：<a href="https://www.tenlong.com.tw/products/9789864347575">JavaScript 概念三明治</a>。</p><p><code>class</code>其實就是像建築物的設計圖一樣，而建築物就可以透過裡面所描述的概念來寫現做出來。</p><p><code>class</code>(類別) &#x3D;&gt; 設計圖。<br><code>object</code>(物件) &#x3D;&gt; 建築物。</p><p>然後有了 class(類別)就可以創造出許多的<code>instance</code>(實例)，透過用<code>new</code>的方式，非常合理，但是<code>JavaScript</code>做不到。</p><p>原因如下：</p><p><strong><code>JavaScript</code> 完全沒有設計<code> class</code> 的概念。</strong></p><h2 id="此-class-非彼-class"><a href="#此-class-非彼-class" class="headerlink" title="此 class 非彼 class"></a>此 <code>class</code> 非彼 <code>class</code></h2><p>書上看到有這樣寫，不過沒寫原因不太懂，為了探究真相，我開始上網 google，下了一些像是<code>what javascript no class？</code>或是<code>What are classes in Javascript?</code>的關鍵字。</p><p>其中有一篇在 stackoverflow 上的<a href="https://stackoverflow.com/questions/2752868/does-javascript-have-classes">Does JavaScript have classes?</a>看到很多高手在談論這個議題，最後的結論是確實在<code>JavaScript</code>是沒有實作<code>class</code>的機制的。</p><p>對，然後你會發現今天的主題也是<code>class</code>，但這其實沒有衝突，因為都沒有錯，確實是沒有<code>class</code>但因為想要模擬其他程式語言可以使用<code>class</code>的特性，所以在 es6 之後，<code>JavaScript</code>特別添加了叫做<code>class</code>的關鍵字。</p><p>所以難道這就代表著<code>JavaScript</code>就此獲得了<code>class</code>?<br>我的答案是否定的，沒有的東西就是沒有，<code>JavaScript</code>從來就沒辦法靠著類別的方式來繼承東西，是依靠原型的，所以就算 es6 之後有了 class 的關鍵字，那也是用原型的實作，來看起來很像類別的實作而已，還是不一樣的。</p><p>而別的程式語言都用類別方式繼承好好的，為什麼<code>JavaScript</code>要特立獨行，使用跟別人不一樣的方式(原型)，我的猜測是作者最初開始在設計<code>JavaScript</code>不想要把它設計的太難，這也是它為什麼看起來這麼不嚴謹的原因，這點從 JavaScript 僅用了 10 天就創造出來就可以看出。</p><p>雖然因為不想要弄的太複雜所以沒有引入 class 的機制，但還是需要有東西去把所有的物件連接再一起去運作，為此依舊得需要「繼承」的概念。</p><p>而上面有提到說，其他很多的程式語言，都是透過 new 的方式把一個 class 的東西給創造出來變成 instance。</p><p>但是<code>JavaScript</code>沒有 class，但是它想到了一個辦法。</p><p>那就是使用我們昨天才講到的 Constructor Function(構造函式)，利用 constructor 當作像是 class 一樣，然後藉由去 new 它一樣可以創造出 instance。</p><p>可是不會完全跟 class 繼承一樣，會非常的不完全，因為利用 constructor 所創造的 instance 根本沒有辦法共享所有的 properies 跟 methods。</p><p>所以才會後來才會創造出，原型這個概念，藉由讓 constructor 獲得原型的這個屬性，真正的讓 constructor 所創造的每一個 instance 都可以共享這個原型物件裡面所有的 properies 跟 methods。</p><p>剛剛在那篇高手討論<code>JavaScript</code>到底有沒有 class 的文章中，最佳回答是這樣回答的，我覺得蠻合理的：</p><blockquote><p>echnically, the statement “JavaScript has no classes” is correct.</p><p>Although JavaScript is object-oriented language, it isn’t a class-based language—it’s a prototype-based language. There are differences between these two approaches, but since it is possible to use JavaScript like a class-based language, many people (including myself) often simply refer to the constructor functions as “classes”.</p></blockquote><p>大意是說，雖然<code>JavaScript</code>是一種 oop 的程式語言，但是不是基於<code>class</code>的語言，而是基於<code>prototype</code>的語言，雖然這兩種的方式有著差異的存在，但是其實可以把<code>JavaScript</code>也當作是基於<code>class</code>的語言(實際上不是)，因此許多人也會把<code>constructor</code>簡單的看做是<code>class</code>。</p><p>小結：<code>JavaScript</code>沒有<code>class</code>但是有<code>object</code>，大家所說在<code>JavaScript</code>的「<code>class</code>」實際上是<code>object</code>(<code>constructor</code>)。</p><p>好，那開始進入這篇文章的主題，Class(類別) &#x3D;&gt; es6 新增關鍵字。</p><h2 id="class-與語法糖"><a href="#class-與語法糖" class="headerlink" title="class 與語法糖"></a>class 與語法糖</h2><p>第一件事情，<code>JavaScript</code>中的<code>Class</code>是一個語法糖，然後語法糖其實我第一次聽到也不知道，所以我有去研究，先來解釋這個部分。</p><p>根據維基百科上面的解釋，語法糖是：</p><blockquote><p>語法糖（英語：Syntactic sugar）是由英國電腦科學家彼得·蘭丁發明的一個術語，指電腦語言中添加的某種語法，這種語法對語言的功能沒有影響，但是更方便程式設計師使用。語法糖讓程式更加簡潔，有更高的可讀性。<br>出處： <a href="https://zh.m.wikipedia.org/zh-tw/%E8%AF%AD%E6%B3%95%E7%B3%96">https://zh.m.wikipedia.org/zh-tw/%E8%AF%AD%E6%B3%95%E7%B3%96</a></p></blockquote><p>好的，其實就是一個可以用更簡單的方式來表達語法的做法，所以話拉回來，Class 這個語法糖確實也可以做到原型繼承的部分，但是它的原理依舊是使用原型的方式，然後其實也會使用到 Constructor 的概念，很高興這些前幾天都講過了，還沒看的可以回去前幾天複習再往下看，那馬上開始今天的介紹！</p><p>直接來做例子來了解其原理。</p><p>由於<code>ES6</code>之後才有<code>Class</code>，所以之前沒有<code>Class</code>時，會比較常使用<code>Constructor</code>來實現原型繼承，<code>ES6</code>之後有了<code>Class</code>會用<code>Class</code>，畢竟是語法糖，方便直覺很多，接下來就來兩種都做做看。</p><h2 id="Constructor-VS-Class"><a href="#Constructor-VS-Class" class="headerlink" title="Constructor VS Class"></a>Constructor VS Class</h2><p>由<code>Constructor</code>先攻：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Food</span>(<span class="params">fruit, color</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">fruit</span> = fruit;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Food</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">saySell</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;快來買蘋果！！！&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apple = <span class="keyword">new</span> <span class="title class_">Food</span>(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line"></span><br><span class="line">apple.<span class="title function_">saySell</span>();</span><br><span class="line"><span class="comment">//快來買蘋果！！！</span></span><br></pre></td></tr></table></figure><p>我首先寫了一個準備要被<code>new</code>建立的函式，第一個英文字母記得大寫(細節)，然後透過原型的方式，把方法指定給<code>Food</code>這個原型裡面，接著用<code>new</code>來建立構造函式，讓我的<code>apple</code>這個新的變數，也可以使用<code>saySell</code>這個方法 &#x3D;&gt; 快來買蘋果！！！</p><p>換<code>Class</code>的回合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">fruit, color</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fruit</span> = fruit;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">saySell</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;快來買蘋果！！！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apple = <span class="keyword">new</span> <span class="title class_">Food</span>(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line"></span><br><span class="line">apple.<span class="title function_">saySell</span>();</span><br></pre></td></tr></table></figure><p>這是一個使用了<code>ES6</code> <code>Class</code>的神奇方法，跟上面差不多，不過仔細上可以發現許多優點。</p><p>先來說明使用<code>Class</code>的流程，一開始使用<code>Class</code>這個關鍵字來創，然後<code>Class</code>後面是名稱，一樣要細節大寫，不同的是，內部就會直接塞一個<code>constructor</code>的函式，而這個函式的方法，就直接寫在了裡面。</p><p>需要方法的話，就直接把方法給塞進去<code>Class</code>裡面就好了，就在<code>constructor</code>的函式下方。</p><p>這是一件十分酷的事情，因為我就不需要自己再寫什麼.<code>prototype</code>把方法塞進去，<code>Class</code>就會自動幫我完成這件事情，語法糖，讚。</p><p>因為實驗精神的關係，來證明吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(apple.<span class="property">__proto__</span> === <span class="title class_">Food</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>結果是 ture，確實有原型繼承到。</p><p>這一切都跟單純使用<code>Constructor</code>的方法差不多，但是使用<code>Class</code>會簡單一些，直覺一些，乾淨一些，結論就是多多使用<code>Class</code>。</p><h2 id="基本-Class-要知道"><a href="#基本-Class-要知道" class="headerlink" title="基本 Class 要知道"></a>基本 Class 要知道</h2><p>今天的部分來做一個小總結，由上面可以知道，其實<code>Class</code>的語法有一個固定模式，把它列出來的話會長這個樣子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="comment">//就是你想的那個構造函式</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//這邊直接寫class的方法</span></span><br><span class="line">  <span class="title function_">method1</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  <span class="title function_">method2</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  <span class="title function_">method3</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">//剛new就會自動調用constructor()</span></span><br><span class="line">  <span class="keyword">const</span> vic = <span class="keyword">new</span> <span class="title class_">MyClass</span>( ... );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法要用自己new後再調用</span></span><br><span class="line">  vic.<span class="title function_">method1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>class</code>後面的名字不用()，它是用來創造<code>instance</code>不是用來執行的。</li><li>不用()但是名字要大寫，跟之前<code>constructor</code>差不多概念。</li><li>new 之後會自動調用 constructor()裡的方法，所以可以藉由 constructor()初始化所創造出來新的<code>instance</code>。</li><li>其他的方法不會自動調用，要用自己再 new 之後去調用它。</li></ol><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/prototype.html">原型基礎物件導向</a><br>[2] <a href="https://zh.wikipedia.org/zh-tw/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1#%E7%BB%A7%E6%89%BF">維基百科 - 物件導向程式設計</a><br>[3] <a href="https://codetrace.com/interview-questions/5d30565d4ccf4c0010333c36/what-is-the-difference-between-classical-and-prototypal-inheritance">What is the difference between classical and prototypal inheritance?</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day05 - Constructor Function(構造函式)</title>
      <link href="/2022/09/20/JS05/"/>
      <url>/2022/09/20/JS05/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Constructor Function</code>也是<code>Function</code>，那它跟一般的<code>Function</code>差在哪裡，有什麼特別之處，就是今天主要介紹的部分。</p><h2 id="構造函式"><a href="#構造函式" class="headerlink" title="構造函式"></a>構造函式</h2><p>剛剛有提到其實跟<code>Function</code>差不多，所以正常來說為了要區分這兩者的差別，構造函式在命名上都會以<strong>大寫字母</strong>來寫，而構造函式的誕生，是要經過一個叫做<code>new</code>這個關鍵字來創立。</p><p>意味著，使用<code>new</code>來生成的函式就是構造函式。<br>沒有使用<code>new</code>來生成，可以直接呼叫執行的，就是普通函式。</p><p>那什麼是<code>new</code>？</p><h2 id="new關鍵字"><a href="#new關鍵字" class="headerlink" title="new關鍵字"></a><code>new</code>關鍵字</h2><p><code>new</code>這個關鍵字其實是<code>new operator</code>，在 mdn 的解釋是：</p><blockquote><p>The new operator lets developers create an instance of a user-defined object type or of one of the built-in object types that has a constructor function.</p></blockquote><p>我自己翻起來是：<code>new</code>可以創建一個定義物件類型，或者是具有構造函式的內置物件類型，它們的實例。</p><p>我的理解是<code>new</code>只可以拿來創造構造函式，沒有用<code>new</code>來創造就只會是普通函式。</p><p>接下來就來證明這件事情。</p><h2 id="new從原理下手"><a href="#new從原理下手" class="headerlink" title="new從原理下手"></a><code>new</code>從原理下手</h2><p><img src="https://i.imgur.com/O5QYgD6.png"><br>圖片來源：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new">MDN</a></p><p>假如有個程式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Food</span> = <span class="keyword">function</span> (<span class="params">fruit, color</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">fruit</span> = fruit;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apple = <span class="keyword">new</span> <span class="title class_">Food</span>(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(apple);</span><br><span class="line"><span class="comment">// Food &#123; fruit: &#x27;apple&#x27;, color: &#x27;red&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>很明顯，我們後來可以創一個變數，使用<code>new</code>的方式把 apple 跟 red 的資訊，傳遞給上面構造函式，就可以成功創造一個實例。</p><p>照著 MDN 上面的解釋，一步步來解析 new 幫忙做了什麼事情：</p><p>首先一開始 new 會幫忙創造一個空的物件，可以當作是{}。</p><p>然後把 {} 的 <code>__proto__</code> 指向 Food 的 prototype，這邊就是前幾篇講過的原型概念，這樣的方式是為了要繼承原型鏈。</p><p>接著下一步是呼叫這個構造函式，綁定{}是 this 的 context，<br>可以理解成 this 就會指向這個空物件，構造函式裡面的 this 是什麼，這裡就會是什麼 &#x3D;&gt; this&#x3D;{}。</p><p>所以在這個例子來看，現在這個 context 裡面就會有兩個新的屬性。</p><p>最後那個一開始創建出來的物件，就會自動回傳，回傳一個有兩個屬性的物件，這就會是<code>new Food(&quot;apple&quot;, &quot;red&quot;)</code>最後結果，它將會儲存在<code>apple</code>這個變數裡面。</p><p>以上就是<code>new</code>會在背後幫忙做的事情。</p><p>有一個蠻好理解的方式，我從這邊看來的 <a href="https://javascript.info/constructor-new%E3%80%82">https://javascript.info/constructor-new。</a></p><p>先看這個程式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isAdmin</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>);</span><br></pre></td></tr></table></figure><p>這裡的 <code>new User(...)</code> 可以理解成這樣運行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// this = &#123;&#125;;（隱式創建）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加屬性到 this</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isAdmin</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return this;（隱式返回）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最後返回的結果都是相同的物件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">  <span class="attr">isAdmin</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外，從這裡還可以衍生一件事情，上面有提到說，在創造<code>new</code>時就已經把所有重要的東西都放入 this 裡面，所以不會需要再<code>return</code>回傳結果，所以在這裡可以再做一個劃分：</p><ul><li>普通函式會使用<code>return</code></li><li>構造函式不會使用<code>return</code></li></ul><h2 id="什麼情況不能用new？"><a href="#什麼情況不能用new？" class="headerlink" title="什麼情況不能用new？"></a>什麼情況不能用<code>new</code>？</h2><p><strong>不是 function 的時候</strong>:<br>我個人測試沒有 function 就會拋出異常：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Apple</span> = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> newApple = <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newApple);</span><br><span class="line"><span class="comment">//TypeError: Apple is not a constructor</span></span><br></pre></td></tr></table></figure><p>Apple is not a constructor，我明明已經弄成物件了，卻還是不行，那假如用 function：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Apple</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> newApple = <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newApple);</span><br><span class="line"><span class="comment">//Apple &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>改成用 function 就不會報錯。<br>我的理解是，空的也不會報錯，基本上全部的函式都可以當作構造函式來使用，除了箭頭函式之外(它沒有 this)，除此之外，都可以通過用 new 的方式來變成構造函式。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>語法的產生都有其原因的存在，而構造函式的產生是來自於有許多情境會需要創造很多相似的物件。</p><p>在創造其他物件時，只需要 new ABC(“abc”)，除了更好閱讀之外，也可以少寫許多東西，讓整個程式變得乾淨許多。</p><p>這種寫一次就可以反覆使用，就是構造函式的精髓所在，大家也多使用構造函式來優化自己的程式碼吧。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor">MDN - constructor</a><br>[2] <a href="https://javascript.info/constructor-new">Constructor, operator “new”</a><br>[3] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new">MDN - new operator</a><br>[4] <a href="https://www.cnblogs.com/aaronjs/archive/2012/07/04/2575570.html">JS 对象机制深剖——new 运算符</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day04 - Prototypal Inheritance(原型繼承)</title>
      <link href="/2022/09/19/JS04/"/>
      <url>/2022/09/19/JS04/</url>
      
        <content type="html"><![CDATA[<p><code>Array Methods</code>繁多，許多人常常使用時會在去 MDN 看文檔，但如果你仔細看會發現奇怪地方，比如說你想要去查<code>map</code>的語法，你實際會看到<code>Array.prototype.map()</code>。</p><p><img src="https://i.imgur.com/ouVXT8L.png"></p><p>更奇怪的地方是，有些會有<code>.prototype</code>，有些沒有，當初我初學時百思不得其解。</p><p><img src="https://i.imgur.com/MuzJgJ3.png"></p><p>其實這就跟今天主題的<code>Prototypal inheritance</code>有關，讓我們從一開始提到的<code>map</code>的<code>Array Methods</code>開始看起，寫一個簡單的例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2);</span><br></pre></td></tr></table></figure><p>會發現說，我明明沒有寫這個方法，但是我可以用，why?<br>arr 裡面明明就只有 12345。這就是原型繼承的奧妙之處。</p><p><code>arr = [1, 2, 3, 4, 5]</code>其實可以看成是<code>arr = new Array([1, 2, 3, 4, 5])</code></p><p>其中<code>Array</code>就是內建的一個 Constructor Function，它自身的<code>prototype</code>會指向一個帶有 map(方法)跟其他一堆的方法的超大物件。</p><p>在這邊<code>arr.map</code>其實就會等於<code>Array.prototype</code>。<br><img src="https://i.imgur.com/OQvaGQX.png"></p><p>意味著<code>arr</code>會連結到它的原型物件，所以它可以使用它的原型物件所有的方法，就是剛剛提到的超大物件，如下圖：<br><img src="https://i.imgur.com/HYdicex.png"></p><p>可以理解成，這個<code>arr</code>的<code>array</code>繼承了<code>map</code>方法，在<code>arr</code>的<code>array</code>本身其實是沒有去定義方法的，全部都在它的原型物件上了，我們可以確認這件事情是不是真的，來驗證吧。</p><h2 id="證明這件事情-x3D-gt-原型繼承"><a href="#證明這件事情-x3D-gt-原型繼承" class="headerlink" title="證明這件事情 &#x3D;&gt; 原型繼承"></a>證明這件事情 &#x3D;&gt; 原型繼承</h2><p>第一步是看<code>arr.__proto__</code>會不會跟<code>Array.prototype</code>相等</p><p><code>arr.__proto__</code>代表的是 arr 這個 array 它的原型物件。<br><code>Array.prototype</code>是 Array 這個 constructor 的原型。<br>結果是 true 那其實就代表他們是相同的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// ture</span></span><br></pre></td></tr></table></figure><p>第二步是看<code>arr.map</code>是不是跟<code>Array.prototype.map</code>相同。</p><p>這邊是為了要證明我上面所講的，<code>arr.map</code>其實就會等於<code>Array.prototype</code>這件事情。<br>結果是 true 那其實就代表他們是相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">map</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span>);</span><br></pre></td></tr></table></figure><p>第三步是看<code>arr.map</code>會不會跟<code>arr__proto__.map</code>一樣。<br>繼承的概念，就是當這個物件找不到了，它會從它的上層原型物件去尋找，所以理論上當 arr 找不到它的 map 方法時，應該可以從<code>arr__proto__</code>這個 arr 的上層原型物件去拿到 map 方法。</p><p>結果還是 true，代表上面想法沒有錯誤。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">map</span> === arr.<span class="property">__proto__</span>.<span class="property">map</span>);</span><br></pre></td></tr></table></figure><p>最後得出了一個結論，arr 確實成功了繼承了原型。</p><h2 id="那些沒有-prototype的方法"><a href="#那些沒有-prototype的方法" class="headerlink" title="那些沒有.prototype的方法"></a>那些沒有<code>.prototype</code>的方法</h2><p>剛剛是講有的，現在來講沒有的。<br>這邊用<code>Array.isArray()</code>來舉例。<br><img src="https://i.imgur.com/WTjljNe.png"><br>圖片來源：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray">MDN</a></p><p>為什麼不是<code>Array.prototype.isArray()</code>，其實道理很間單，我的理解是因為不能確定我使用的對象是不是 Array，所以我不能使用 Array 的原型物件來繼承。</p><p>像是<code>Array.isArray()</code>這個方法就是用來判斷這個東西是不是 Array 的，所以結果可能是也可能不是，所以沒辦法斷定說就是 Array。</p><p>所以必須在寫的時候，不能使用<code>.prototype</code>的方式，要直接把 Array 給寫出來，我們來做個差異化比較：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有.prototype =&gt; Array.prototype.map()</span></span><br><span class="line"><span class="keyword">const</span> test = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// test.map就會等於Array.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="title function_">map</span>(<span class="function">(<span class="params">a</span>) =&gt;</span> a * <span class="number">2</span>)); <span class="comment">// [2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 沒有寫.prototype =&gt; Array.isArray()</span></span><br><span class="line"><span class="keyword">const</span> test2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 判斷的東西，是放在參數裡面的概念。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(test2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h2><p>原型繼承還有一個有趣的地方，就是剛剛講解的那個是<code>Array</code>的原型，但就算是<code>Array</code>，它的頂點原型也不是<code>Array.prototype</code>，而是<code>Object.prototype</code>。</p><p>也不只是<code>Array</code>而已，全部的內建原型的頂點通通都是<code>Object.prototype</code>。</p><p>所謂的頂點就是，上面已經沒有東西，高處不勝寒，想要再繼續往上的話只看的到<code>null</code>而已。</p><p>所以我會理解成，在<code>JavaScript</code>中所有的繼承都是由<code>Object.prototype</code>繼承而來，然後我去查詢相關爬文，也有一些人這麼說:</p><blockquote><p>All objects inherit the properties and methods of Object</p></blockquote><p>這句話出處:<a href="https://www.freecodecamp.org/news/prototypes-and-inheritance-in-javascript/">JavaScript Prototypes and Inheritance – and Why They Say Everything in JS is an Object</a></p><p>意思是其實所有的物件都是繼承了 object 的屬性跟方法，null 不算，因為它沒有原型，只是充當原型鏈的最後一環。</p><h2 id="增加更改原型繼承"><a href="#增加更改原型繼承" class="headerlink" title="增加更改原型繼承"></a>增加更改原型繼承</h2><p>除了昨天講到不要用<code>Object.setPrototypeOf</code>以及<code>obj.__proto__</code>去指定變換原型物件之外，還有也不要去增加更改原型繼承。</p><p>像是上面有提到的<code>Array.prototype.map()</code>方法，它是內建寫好的，但其實也可以自己寫一個方法塞進去，像是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">good</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> + <span class="string">&quot;good&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;apple&quot;</span>.<span class="title function_">good</span>(); <span class="comment">// apple good</span></span><br></pre></td></tr></table></figure><p>這好嗎？ 這不好。</p><p>原因有幾個：</p><ul><li>假如是在跟別人協作，你弄了一個自己寫的方法放入自己的原型物件，然後自己繼承用的很開心，但是別人看到會一頭霧水，不知從何而來。</li><li>因為原型物件是 global 的，很容易造成衝突，像是說有兩個函式庫都添加了 String.prototype.good 這個方法，就會造成前面蓋後面。</li></ul><p>自己需要用的話，那就直接寫一個方法給自己用就好，其實不太需要把這個方法，弄給全部人都能繼承，因為大部分<code>javascript</code>覺得你需要的方法都已經幫忙內建寫好了。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>希望大家看完這篇有比較懂為什麼大部分方法都有加上<code>.prototype</code>，以及對於原型繼承的部分有更實務上的理解，之前比較偏向講原理，而實際有運用到原型繼承的我想就是這些族繁不及備載的內建方法了吧，以上就是今天的介紹。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">Inheritance and the prototype chain</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day03 - Prototype Chain(原型鏈)</title>
      <link href="/2022/09/18/JS03/"/>
      <url>/2022/09/18/JS03/</url>
      
        <content type="html"><![CDATA[<p>昨天<code>Prototype</code>世界的例子中，小白這種打電話讓別人再去打電話找的方式，其實就是一種<code>Prototype Chain</code>的概念。</p><p>畫一張示意圖會比較清楚一些，用一個空的陣列來做舉例。</p><p><img src="https://i.imgur.com/eFnHLqm.png"></p><p>首先，陣列也是一種物件，空陣列代表裡面什麼都沒有，不過不代表不能從空陣列去獲取東西。</p><p>當我要從物件裡面找一個不存在的屬性，JavaScript 就會直接從它的原型物件去找，要是它的原型物件沒有，就會再往上找它的原型物件，直到最上面，都沒有那就是找不到。</p><p>而這個最上面的原型物件就稱作叫<code>Object.prototype</code>。<br>真的就最上面了，再往上找就是<code>null</code>。</p><p>而這一個由下往最上尋找的過程，一層一層相依尋找，就是原型鏈。</p><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h2><p>這個可以拿來創造出一個擁有原型物件的新空物件，裡面的參數就帶要被繼承的原型物件，比如說:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> food = &#123;</span><br><span class="line">  <span class="attr">eat</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apple = <span class="title class_">Object</span>.<span class="title function_">create</span>(food);</span><br></pre></td></tr></table></figure><p>這個新被創造出來的物件其實原型物件就會自動綁定是 food 了，所以現在的 apple 也可以去看 eat 的這個屬性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(apple.<span class="property">eat</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>除此之外，<code>Object.create</code>還有一個很厲害的地方，它可以藉由放第二個參數，直接為新的物件增加額外的屬性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> food = &#123;</span><br><span class="line">  <span class="attr">eat</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apple = <span class="title class_">Object</span>.<span class="title function_">create</span>(food, &#123;</span><br><span class="line">  <span class="attr">red</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(apple.<span class="property">red</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><p>昨天只講到如何設定原型，其實還可以獲取原型，那就是使用<code>Object.getPrototypeOf()</code>，這個語法會回傳物件中的原型物件。</p><p>用上面的例子來舉例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> food = &#123;</span><br><span class="line">  <span class="attr">eat</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> apple = <span class="title class_">Object</span>.<span class="title function_">create</span>(food);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(apple) === food); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>apple 的原型物件就是 food，所以答案是 true，證明沒想錯。</p><p><code>__proto__</code>其實也能做到相同的事情，不過使用<code>__proto__</code>來進行設定或是獲取都是件不太好的事情(詳情請看昨天)，所以請記得，現在主流的設定跟獲取方式:</p><ul><li>Object.getPrototypeOf() &#x3D;&gt; 獲取</li><li>Object.setPrototypeOf() &#x3D;&gt; 設定</li></ul><p>但是<code>__proto__</code>真的就一無可取之處嗎?那倒也不是，有一個用法的情境是不會被反對的。</p><h2 id="proto-當作屬性時"><a href="#proto-當作屬性時" class="headerlink" title="__proto__當作屬性時"></a><code>__proto__</code>當作屬性時</h2><p><img src="https://i.imgur.com/52aTKfw.png"><br>圖片來源: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto">MDN</a></p><p>看起來 MDN 裡面比較偏向說，不要使用<code>. __proto__</code>的方式，但把<code>__proto__</code>當作屬性時算是一個還蠻 OK 的方式。</p><p>也有查到其他地方也有這種說法:</p><blockquote><p>The only usage of <strong>proto</strong>, that’s not frowned upon, is as a property when creating a new object: { <strong>proto</strong>: … }.<br>說法出處:<a href="https://javascript.info/prototype-methods">https://javascript.info/prototype-methods</a></p></blockquote><p>讓我們來看看這方法是怎麼實作的吧。</p><p>創建一個新物件時，可以把<code>__proto__</code>當作是屬性，然後它的 value 直接設定成所想要的原型物件。</p><p>有一個重點是，<code>__proto__</code>的值必須是物件或是 null，比如說值是字串就無法，其實蠻合理的，因為字串不能變成一個原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> food = &#123;</span><br><span class="line">  <span class="attr">eat</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apple = &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">  <span class="attr">__proto__</span>: food,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> coconut = &#123;</span><br><span class="line">  <span class="attr">hardness</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">__proto__</span>: apple,</span><br><span class="line">  <span class="comment">// 怕大家不知道所以講一下，coconut是椰子</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在這邊有三個新創的物件，我利用<code>__proto__</code>當屬性設定的方式，讓這三個物件形成一個原型鏈，藉由把 apple 的<code>__proto__</code>設定成 food，再把 coconut 的<code>__proto__</code>屬性設定成 apple，這樣一來，理論上應該可以在 coconut 使用到 food 的屬性，我們來測試看看。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(coconut.<span class="property">eat</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>看來結果沒有錯，確實已經藉由<code>__proto__</code>當屬性的方式，把這三個物件串個原型鏈。</p><h2 id="不要做的事情"><a href="#不要做的事情" class="headerlink" title="不要做的事情"></a>不要做的事情</h2><p>現在已經提到了<code>Object.setPrototypeOf</code>以及<code>obj.__proto__</code>都可以直接的去更改原型物件，影響整體的<code>Prototype Chain</code>，但這是一件好的事情嗎？</p><p>關於這點去研究後，發現有些文章會說這個行為其實不是一件很好的事情，如下：<br><img src="https://i.imgur.com/UAd8nXO.png"><br>圖片來源：<a href="https://javascript.info/prototype-methods">https://javascript.info/prototype-methods</a></p><p>大意就是，如果你今天覺得，速度很重要，就不要去修改已經存在的原型了，昨天有提到說，物件只能指定一種原型物件，要是去修改它，就會去覆蓋掉原本的原型物件，而這種行為，照那篇文章說，會去破壞掉<code>object property access operations</code>的內部優化，簡單說就會會讓<code>javascript</code>的執行速度變得很慢。</p><p>除非修改的重要程度比運行的速度還要重要，不然通常在創建物件時，就只會設置那麼一次，就不會再修改了，確實設計上是想改就改，但是除非有很確定自己在做什麼，不然我的理解是避免去做這件事情。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>可能其它程式語言並不是如此，但在<code>javascript</code>中就是透過<code>Prototype Chain</code>來把上下關係給連接起來，藉此來達到繼承的方式，推薦大家可以去看 huli 的 <a href="https://blog.huli.tw/2017/08/27/the-javascripts-prototype-chain/">該來理解 JavaScript 的原型鍊了</a>，裡面講的很清楚好懂，那麼今天就是這些，我們明天見！</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf">Object.getPrototypeOf()</a><br>[2] <a href="https://javascript.info/native-prototypes">Native prototypes</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day02 - Prototype (原型)</title>
      <link href="/2022/09/17/JS02/"/>
      <url>/2022/09/17/JS02/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我相信每個語法的發明都有它意義存在，以我看來<code>Prototype</code>的存在，是為了要讓<code>JavaScript</code> 也能實現物件導向，準確點來說，可以用來做到物件的繼承，透過<code>Prototype</code>的方式。</p><h2 id="Prototype-的產生是為了-JavaScript-的繼承"><a href="#Prototype-的產生是為了-JavaScript-的繼承" class="headerlink" title="Prototype 的產生是為了 JavaScript 的繼承"></a>Prototype 的產生是為了 JavaScript 的繼承</h2><p>而所謂物件的繼承，就是可以從其他地方拿到本身沒有的方法或是屬性，藉由去繼承有方法跟屬性的物件，來獲得使用那些方法跟屬性的權利。</p><p>在<code>JavaScript</code>中，每個<code>object</code>都會去連結到<code>Prototype object</code> &#x3D;&gt; 每個<code>object</code>都可以看得到裡面有<code>Prototype</code>(<code>null</code>是例外～)。</p><p>這個<code>Prototype</code>是<code>[[prototype]]</code>也是原型物件。</p><p>舉例來說，創造一個空物件，會看見[[Prototype]]:<br><img src="https://i.imgur.com/drDGvpF.png"></p><p>但是用<code>Object.create</code>使用<code>null</code>當原型的這個新物件是會看到<code>no properties</code>，很乾淨的那種。<br><img src="https://i.imgur.com/ipd0TFv.png"></p><h2 id="Prototype-object-包含了-properties-屬性-跟-methods-方法"><a href="#Prototype-object-包含了-properties-屬性-跟-methods-方法" class="headerlink" title="Prototype object 包含了 properties(屬性) 跟 methods(方法)"></a>Prototype object 包含了 properties(屬性) 跟 methods(方法)</h2><p>簡單解釋一下什麼是<code>properties</code>跟<code>methods</code>。<br>首先要先知道物件會有<code>key-value pairs</code>，接著看下方程式碼：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruit = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;apple&quot;</span>, <span class="comment">// name =&gt; properties</span></span><br><span class="line">  <span class="attr">weight</span>: <span class="string">&quot;300g&quot;</span>, <span class="comment">// weight =&gt; properties</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">callSell</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;好吃的蘋果，快來給我買&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;; <span class="comment">// callSell =&gt; methods</span></span><br></pre></td></tr></table></figure><p><code>value</code> 是一般值 &#x3D;&gt; <code>properties</code><br><code>value</code> 是一個函式 &#x3D;&gt; <code>methods</code></p><p>意思是連結到這個<code>Prototype</code>的所有<code> object</code>，都可以去使用這個<code>Prototype object</code>的<code>properties</code>以及<code>methods</code>，這就是<code>Prototype</code>的奇妙之處，我沒有但我可以還是用。</p><p>再說一次，這種我沒有，但是我還是可以用的行為，其實是一種繼承的概念，因為是用原型來達成的，所以會把它稱為原型繼承。</p><h2 id="如何設定Prototype"><a href="#如何設定Prototype" class="headerlink" title="如何設定Prototype"></a>如何設定<code>Prototype</code></h2><p>為什麼要設定，要如何設定，讓我用一個例子來舉例：</p><p><code>Prototype</code>世界的小白家有餅乾，小紅家有花朵，他們住在不同的地方，要去拿到小白的餅乾，就沒辦法拿到小紅的花朵，反之也是一樣。</p><p>想要從小白那邊獲得餅乾，又能拿到花朵，這時候需要電話，比如説小白吃著餅乾，又想要手上拿著花朵，但這時候小白家沒有花朵，但是可以打電話給小紅，叫她把花給速速送過來。</p><p>這個電話號碼其實就是<code>Object.setPrototypeOf</code>。</p><p>這個語法會需要兩個參數，如下用 A 跟 B 來表示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf(A, B)</span><br></pre></td></tr></table></figure><p>第一個參數 A 代表的是要設定原型的物件，第二個參數 B 代表的是參數 A 的新原型物件。</p><p>所以在這邊可以藉由小白獲得了小紅的電話號碼，獲得可以拿到小紅花朵這個概念，拿來比擬小白透過 Object.setPrototypeOf() 將「小紅指定為原型」。</p><p>用這個例子的範例來說，程式會長這樣:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小白擁有很多餅乾</span></span><br><span class="line"><span class="keyword">const</span> white = &#123; <span class="attr">cookies</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="comment">// 小紅擁有很多花朵</span></span><br><span class="line"><span class="keyword">const</span> red = &#123; <span class="attr">flowers</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小白獲得了可以打給小紅的電話號碼</span></span><br><span class="line"><span class="comment">// 指定 red 為 white 的 Prototype</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(white, red);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真是太好了，現在去找小白也能獲得花朵</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;flowers&quot;</span> <span class="keyword">in</span> white); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//這是不太嚴謹的例子，因為現實中可能多試幾次後小白那邊就拿不到花朵，因為電話打太多次小紅會把小白封鎖。</span></span><br></pre></td></tr></table></figure><p>在上面的程式裡面，小白就是物件，小紅就是原型物件，小白可以指定原型物件(打電話)，來獲得原型物件的東西。</p><p>那假如我今天又想要在小白家拿到披薩呢? 現在知道說，小綠家有很多披薩，一樣把他的電話新增到小白手機裡，讓小白打電話給他。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> white = &#123; <span class="attr">cookies</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> red = &#123; <span class="attr">flowers</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(white, red);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小綠擁有很多披薩 (小知識:pizza是不可數名詞，可以不用加s)</span></span><br><span class="line"><span class="keyword">const</span> green = &#123; <span class="attr">pizza</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(white, green);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 又多一個朋友，今晚我想來點餅乾+花朵+披薩</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;cookies&quot;</span> <span class="keyword">in</span> white); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;flowers&quot;</span> <span class="keyword">in</span> white); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pizza&quot;</span> <span class="keyword">in</span> white); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 從小白家竟然拿不到小紅的花朵，難道小紅生氣了嗎?</span></span><br></pre></td></tr></table></figure><p>小白家拿不到小紅的花朵，其實是因為<code>Prototype</code>世界的電話，一次只能存取一個電話號碼，小白手機裡面原本是存小紅電話號碼，但後來新增了小綠電話號碼，小紅的就消失了。</p><p>小白沒有在記別人電話號碼的，手機裡號碼不見了就不見了，現在只剩下小綠電話號碼，所以只能從小白家獲取小綠披薩。</p><p><strong>重點 : 物件只能指定一種原型物件。</strong></p><p>小白苦思著，竟然一次只能存取一個電話號碼，突然，小白靈光乍現，他想到了，只要叫小綠去用他的手機存取小紅電話不就好了嗎?</p><p>他打電話給小綠，小綠再打電話給小紅，之後再全部拿到小白家。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> white = &#123; <span class="attr">cookies</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> red = &#123; <span class="attr">flowers</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> green = &#123; <span class="attr">pizza</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(white, green);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小綠獲得了小紅的電話號碼，可以打電話給小紅</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(green, red);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 太好了，現在從小白家就能拿到花朵跟披薩，大家都很開心</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;cookies&quot;</span> <span class="keyword">in</span> white); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;flowers&quot;</span> <span class="keyword">in</span> white); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pizza&quot;</span> <span class="keyword">in</span> white); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/MfBLfcH.png"></p><p>透過這個友善的故事，希望能讓大家對於原型這個概念有個初步的理解，另外我還有在學習時看到一些不錯的比喻，寫得很棒歡迎去看 :</p><ol><li>藉由洛克人打贏 boss 就會獲得 boss 新武器的機制來做原型的比喻。<br>來自於<a href="https://ithelp.ithome.com.tw/articles/10194154">重新認識 JavaScript: Day 24 物件與原型鏈</a></li><li>藉由猜謎問問題，遇到不會的問題就問其他人，來做原型的比喻。<br>來自於<a href="https://www.tenlong.com.tw/products/9789864342525">忍者：JavaScript 開發技巧探秘, 2&#x2F;e</a></li></ol><h2 id="設定Prototype其他方式"><a href="#設定Prototype其他方式" class="headerlink" title="設定Prototype其他方式"></a>設定<code>Prototype</code>其他方式</h2><p>除了<code>setPrototypeOf()</code>之外其實也有一個方法可以去設定原型物件，就是<code>__proto__</code>，一樣可以讓小白拿到小紅的花:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> white = &#123; <span class="attr">cookies</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> red = &#123; <span class="attr">flowers</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">white.<span class="property">__proto__</span> = red;</span><br><span class="line"><span class="comment">// 設定 小白的原型物件是小紅</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;flowers&quot;</span> <span class="keyword">in</span> white); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>雖然它可以也可以拿來設定，不過我們一般不會使用它，因為它已經被認為過時以及超級不推薦使用，現在都會建議使用<code>setPrototypeOf()</code>，我會發現是因為研究時 MDN 上看到，要是你在 MDN 上面有查過<code>__proto__</code>這個語法的話，你會發現點開映入眼簾的是很多的警告，很可怕，有興趣可以研究。<br><img src="https://i.imgur.com/oKWBoht.png"><br>圖片來源:<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto">MDN</a></p><h2 id="構造函式的原型"><a href="#構造函式的原型" class="headerlink" title="構造函式的原型"></a>構造函式的原型</h2><p>我快寫不完，最後簡單介紹一下構造函式的原型，構造函式創個一個新的物件時，這個新的物件會被設定原型，原型物件就是構造函式，可能有些人不知道什麼是構造函式，但今天再詳細解釋會有點太長，所以關於這個以後會專門做一期文章給大家講解。</p><p>簡單一個小範例介紹:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Food</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> apple = <span class="keyword">new</span> <span class="title class_">Food</span>(<span class="string">&quot;apple&quot;</span>);</span><br></pre></td></tr></table></figure><p>Food 就是建構函式，然後藉由 new 去實例出 apple，這個新創造出來的物件，會被存到這個變數 apple 裡面。</p><p>然後這個 apple 它的原型物件就會是 Food，我們可以來驗證一下這件事情。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(apple.<span class="property">__proto__</span> === <span class="title class_">Food</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>結果沒錯，相當於就是這個新的物件會繼承構造函式的原型。</p><hr><p>明天會繼續接著講原型鏈的<img src="/images/emoticon/emoticon06.gif" alt="/images/emoticon/emoticon06.gif"></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes">MDN - Object prototypes</a><br>[2] <a href="https://www.w3schools.com/js/js_object_prototypes.asp">W3Schools - JavaScript Object Prototypes</a><br>[3] <a href="https://ithelp.ithome.com.tw/articles/10225205https://ithelp.ithome.com.tw/articles/10225205">JS 原力覺醒 Day21 - 原型</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS之路 Day01 - 開始與結束的序言</title>
      <link href="/2022/09/16/JS01/"/>
      <url>/2022/09/16/JS01/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Vic，目前在台南的好想工作室學習，已經在這裡自學了幾個月時間。鐵人賽的開始，代表著我的 JS 學習的路也已經學到了一個段落，這一個階段要挑戰的就是三十天連續的技術發文，挑戰短時間內對<code>JavaScript</code>的理解程度，學習了三、四個月也是一段不短的時間，該來突破自我了！</p><p>這段時間自學看了許多網路上資源跟書籍，列出一些我自己覺得很不錯的(各列前三個)。</p><p><strong>學習網站：</strong></p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">JS MDN</a><br>提供了很多語法的說明跟相關的技術文件，正確性很高，而且每個語法都有很清晰的範例，是一個我後來當作 JS 字典的地方，會天天看天天查。</li><li><a href="https://www.w3schools.com/js/">JS w3schools</a><br>跟 MDN 是同個性質的學習網站，但相對來說會簡單些，優點是版面很乾淨，會讓人看了覺得很舒服，我覺得也很適合初學者去看。</li><li><a href="https://lidemy.com/">Lidemy 鋰學院</a><br>號稱是一個為初學者而生的線上程式課程平台，我覺得當之無愧，滿完整又便宜，就算不花錢上面也有一些免費的課程。之前花了一個月去訂閱，然後把想看的學習影片全部看完，我覺得很划算。</li></ul><p><strong>學習書籍：</strong></p><ul><li><a href="https://www.tenlong.com.tw/products/9789864347575">JavaScript 概念三明治：基礎觀念、語法原理一次帶走！</a><br>簡稱三明治，看完後個人認為超適合初學者，裡面淺白好懂，去年才出的內容也很新，最棒的是還是全彩的，但可能內容不會很深入，有好有壞，不過是很棒的書。</li><li><a href="https://www.tenlong.com.tw/products/9789864344130?list_name=rd">0 陷阱！0 誤解！8 天重新認識 JavaScript！</a><br>簡稱 008，很厲害的書，不過我看完後覺得對於完全新手的人會有些吃力，因為蠻多部分書裡面當作你已經知道然後省略掉，所以可能會需要邊看邊去查 MDN 幫忙理解，但有一定深度，是一本好書。</li><li><a href="https://www.tenlong.com.tw/products/9789864342525?list_name=srh">忍者：JavaScript 開發技巧探秘, 2&#x2F;e</a><br>簡稱忍者，完全不適合新手看的書，我覺得可能要上面兩本三明治跟 008 讀完再來挑戰，一本高手境界的書，要記得它，當你未來要更上一層樓時，閱讀忍者是一個好的方法，目前我正在看，還沒看完。</li></ul><h2 id="我的預想"><a href="#我的預想" class="headerlink" title="我的預想"></a>我的預想</h2><p>預想這次的系列會從個人認為 JS 最難的部分開始寫，系列文章順序理論上就是從困難&#x3D;&gt;簡單，後面假如沒東西想法寫，就會開始挑戰當日找新東西馬上學馬上寫。目前還沒開始寫所以沒什麼概念，所以詳細的大綱會根據我個人寫的速度而跟著變化著。</p><h2 id="開始與結束"><a href="#開始與結束" class="headerlink" title="開始與結束"></a>開始與結束</h2><p>就如標題所講的，這是一段開始與結束的序言，鐵人賽開始的同時，一些事情也隨之跟著結束，而我要做的就是把握當下，用心的把我這階段該完成的事情給完成，這會是一段難忘的回憶，因為一些原因，我鐵人賽期間會有點忙，不過相信這也是練習同時應付多種重要狀況的好機會。</p><p>這次會抱持著鐵人就應該要現學現賣的精神，在能力所及的狀態之下，去選擇最困難的那條路，想辦法做到最好。</p><p>那就開始吧，三十天的 JS 之路 GOGOGO!!!</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac的esc沒有反應問題</title>
      <link href="/2022/08/23/Esc%20key%20does%20not%20work/"/>
      <url>/2022/08/23/Esc%20key%20does%20not%20work/</url>
      
        <content type="html"><![CDATA[<p>這個一直困擾我很久的問題，有時候用一用就突然失效，而到最近更是連 F3 也無法使用，三指往上滑也沒辦法，可惡這是剛買沒有到一年的 mac m1 呀，不過我最終找到了解決方式，記錄一下。</p><h2 id="1-重新開機"><a href="#1-重新開機" class="headerlink" title="1. 重新開機"></a>1. 重新開機</h2><p>重新開機就能恢復正常，缺點就是每次發生失效就得一直重新開關機。</p><h2 id="2-重啟-dock"><a href="#2-重啟-dock" class="headerlink" title="2. 重啟 dock"></a>2. 重啟 dock</h2><p>在終端機或是其他命令提示的地方下這一個指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall Dock</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 軟體與操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的throw用法</title>
      <link href="/2022/06/14/javascript%20throw/"/>
      <url>/2022/06/14/javascript%20throw/</url>
      
        <content type="html"><![CDATA[<p>js 在拋出錯誤的時候會使用到 throw</p><p>提到<code>throw</code>之前要先來介紹一下相同性質的<code>try</code>, <code>catch</code></p><span id="more"></span><h2 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h2><p>它會分成兩個區塊，一個 try 一個 catch</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 要執行的程式</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 錯誤發生時，上面的就不會執行，改執行這邊</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>舉例時間：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">apple</span>(<span class="string">&quot;apple不是正確的使用方式喔&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我錯了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這段 code 的結果會印出我錯了，如下：<br><img src="https://i.imgur.com/8wTpx1D.png"></p><p>為什麼會發生這樣的結果？這是因為如果<code>try</code>區塊裡面的程式碼假如沒有任何的錯誤，就會直接忽略掉<code>catch</code>區塊裡面的程式碼，反之有錯的話，就會以<code>catch</code>裡面的程式碼為主，而錯誤的<code>try</code>就會中斷執行，所以在這個範例來說，因為<code>try</code>寫錯了，所以會以<code>try</code>裡面的程式碼為主</p><p>另外如果<code>catch</code>區塊如果接受了一個參數，就可以直接利用這個參數獲取錯誤資料，一般都會是直接在後台輸出資料，這邊來試試看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">apple</span>(<span class="string">&quot;apple不是正確的使用方式喔&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;錯誤訊息 :&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這段 code 的結果會印出錯誤資訊，如下：<br><img src="https://i.imgur.com/rqNUD5z.png"></p><h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><p>接下來介紹這次的主題<code>throw</code>，它常常用於上面提到的<code>try…catch</code>結構，<code>throw</code>這個語句只要一出現就會直接中斷程式執行，代表說在它之後的語句都不會再被執行，簡單來說，在<code>try</code>的區塊時碰到<code>throw</code>就會直接中斷執行並且把控制權交給<code>catch</code>的區塊，所以說要是沒有<code>catch</code>的區塊，程式就會立刻停止</p><p>就如同最前面說的，<code>throw</code>可以拋出一個錯誤，這樣的好處是可以很清楚的知道說錯誤的具體位置，可以很方便去做判斷</p><p>舉例時間：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;這邊很多蘋果，準備開始賣給顧客！&quot;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;等等有壞蘋果！終止交易！&quot;</span>; <span class="comment">// throw 會中斷進行</span></span><br><span class="line">  <span class="comment">// 故意製造壞蘋果</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title class_">BadApple</span>(<span class="string">&quot;壞蘋果x5&quot;</span>);</span><br><span class="line">  <span class="comment">// 假如沒有被中斷，可以正常賣蘋果的世界線</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;好吃蘋果，大賣特賣，大家快來買！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;有壞蘋果不准你賣！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這段 code 的結果順序會是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 這邊很多蘋果，準備開始賣給顧客！</span><br><span class="line"><span class="number">2.</span> 等等有壞蘋果！終止交易！</span><br><span class="line"><span class="number">3.</span> 有壞蘋果不准你賣！</span><br></pre></td></tr></table></figure><p>如下：<br><img src="https://i.imgur.com/dTgafCo.png"></p><p>首先，因為<code>throw</code>會中斷後面所有語句執行的特性，所以上面那段範例中還沒遇到<code>壞蘋果x5</code>就會直接跳到<code>catch</code>區塊的<code>有壞蘋果不准你賣！</code>，這邊我故意把<code>壞蘋果x5</code>弄成製造錯誤的方式，但是一樣被中斷跳過，於是可以發現一件事情：</p><blockquote><p><code>throw</code>中斷了後面所有語句，包括了錯誤也一樣</p></blockquote><p>所以這邊衍伸出了一個問題，如果錯誤是發生在<code>throw</code>語句之前，那會發生什麼事情呢，我們來試試看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;這邊很多蘋果，準備開始賣給顧客！&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title class_">BadApple</span>(<span class="string">&quot;壞蘋果x5&quot;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;等等有壞蘋果！終止交易！&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;好吃蘋果，大賣特賣，大家快來買！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;有壞蘋果不准你賣！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>結果如下：<br><img src="https://i.imgur.com/hep0E8x.png"></p><p>從結果可以發現說，假如錯誤發生在<code>throw</code>語句之前，那麼錯誤還是會被正常的顯示出來，而<code>throw</code>語句傳送的東西就不會出現，所以就可以利用像是這種模式，慢慢的交替把程式碼錯誤的位置給尋找出來</p><br><p>以上是我在學習<code>throw</code>時研究的紀錄，有任何問題都歡迎指教～</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/try...catch">MDN try…catch</a></li><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Control_flow_and_error_handling">MDN 流程控制與例外處理</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo 有部署沒顯示問題</title>
      <link href="/2022/05/30/blog%20not%20showing/"/>
      <url>/2022/05/30/blog%20not%20showing/</url>
      
        <content type="html"><![CDATA[<h2 id="狀況問題如下："><a href="#狀況問題如下：" class="headerlink" title="狀況問題如下："></a>狀況問題如下：</h2><p>我的其中一篇”Selector Combinators 中的+跟~差別”，已經部署上去的文章，明明已經成功部署了，但是點進去看時會出現這個畫面</p><p><img src="https://i.imgur.com/TIukMIU.png"></p><p>剛看到時毫無頭緒，後來思考了幾種拯救的方式來試試看能不能救回來</p><h2 id="重新做部署的動作"><a href="#重新做部署的動作" class="headerlink" title="重新做部署的動作"></a>重新做部署的動作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g // 建立靜態頁面</span><br><span class="line">hexo d // 部署到github</span><br></pre></td></tr></table></figure><p>還是沒辦法</p><h2 id="修改-code"><a href="#修改-code" class="headerlink" title="修改 code"></a>修改 code</h2><p>那我在想有可能是因為 code 的部分有寫錯的問題，仔細檢查了程式碼之後的確有不尋常的地方</p><p><img src="https://i.imgur.com/YwpD9qx.png"></p><p>試試看把標題裡那個有藍色波浪號拿到後，是不是就正常了</p><p>也不是這個問題，排除</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>經過多次的比對之後，發現了原因<br>source 裡 posts 文件的命名中我有使用到～及＋<br>看來名稱的使用上要注意一些符號<br>雖然本地端預覽使用 hexo server 看都沒問題，不過推到遠端就會發生 404</p><p>最後改過後就又恢復正常了～</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>grid的不同解讀</title>
      <link href="/2022/05/19/grid%20explanation/"/>
      <url>/2022/05/19/grid%20explanation/</url>
      
        <content type="html"><![CDATA[<p>繼 css flex 佈局出來之後，後來又出現了 css grid 的佈局方式，不過 grid 這個詞不是被新發明出來的，是之前就有的東西。</p><span id="more"></span><p>假如你想跟別人討論說要使用 grid，但沒講清楚是哪種「grid」的話，可能溝通上就會造成許多問題，這篇會提到有三種解讀方式：</p><h2 id="格線系統-grid-system-的-grid"><a href="#格線系統-grid-system-的-grid" class="headerlink" title="格線系統(grid system)的 grid"></a>格線系統(grid system)的 grid</h2><p>一種 ui 設計會使用到的概念，可以幫助設計師更好的在畫面上安排，另外前端框架 Bootstrap 也會使用到 grid system，這邊要注意到並不是指 css 裡面的那個 grid</p><h2 id="css-佈局方式的-grid"><a href="#css-佈局方式的-grid" class="headerlink" title="css 佈局方式的 grid"></a>css 佈局方式的 grid</h2><p>屬於 css 裡面的佈局方式，使用時 display 會先變成 grid，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display:grid</span><br></pre></td></tr></table></figure><p>使用之後，這個使用的區塊元素就都會變成「grid」，只需再搭配一堆 grid 系列的語法，就能利用 gird 讓網頁排成自己想要的形狀～</p><h2 id="簡寫屬性的-grid"><a href="#簡寫屬性的-grid" class="headerlink" title="簡寫屬性的 grid"></a>簡寫屬性的 grid</h2><p>剛剛上面提到，把區塊設成「grid」物件後，就能利用一堆的 gird 系列語法來完成佈局，這邊提到的簡寫屬性的 grid 就是它裡面的其中一種寫法，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid: auto-flow / 1fr 1fr 1fr;</span><br><span class="line">grid: auto-flow dense / 40px 40px 1fr;</span><br><span class="line">grid: repeat(3, 80px) / auto-flow;</span><br></pre></td></tr></table></figure><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>一個 grid 各種解讀，蠻容易搞混的，就像我當初學習 Bootstrap 以為它的 grid system 主要是用 css 的 grid，但是並沒有，反而還跟 css 的 flex 相關度比較大。</p>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> grid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切版中的學習書單</title>
      <link href="/2022/04/14/cut%20study%20book%20list/"/>
      <url>/2022/04/14/cut%20study%20book%20list/</url>
      
        <content type="html"><![CDATA[<p>現在練習切版中，這些是我現在正在看跟準備看完的書，做個整理。</p><p>金魚都能懂的 CSS 選取器<br><a href="https://www.books.com.tw/products/0010863222">https://www.books.com.tw/products/0010863222</a></p><p>從自學到成功轉職軟體工程師：自主學習讓我重拾人生的發球權<br><a href="https://www.books.com.tw/products/0010914782">https://www.books.com.tw/products/0010914782</a></p><p>為你自己學 git<br><a href="https://www.tenlong.com.tw/products/9789864342662?utm_source=gitbook&utm_medium=site">https://www.tenlong.com.tw/products/9789864342662?utm_source=gitbook&amp;utm_medium=site</a></p><p>Github 創辦人親自指導你精通 Git<br><a href="https://www.books.com.tw/products/0010813105">https://www.books.com.tw/products/0010813105</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端相關 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>css position 小心得</title>
      <link href="/2022/04/09/css%20position/"/>
      <url>/2022/04/09/css%20position/</url>
      
        <content type="html"><![CDATA[<p>原文連結: <a href="https://appcs342.blogspot.com/2022/04/css-position.html">https://appcs342.blogspot.com/2022/04/css-position.html</a><br>移植時的最後更新日期: 2022-04-08T21:36:10.985-07:00</p><span id="more"></span><p></p><blockquote>&nbsp;最近有在研究position，在css中這算是一個非常重要的屬性，網頁中的定位全要靠它，在此整理一些研究時的筆記跟我的小小心得～</blockquote><p></p><p><br /></p><h2 style="text-align: left;">首先，是我對position作用的理解</h2><div>對網頁上物件的屬性添加了position就可以改變物件的排列方式，改變其在網頁上位置，但其實就算都沒有添加，原本物件間也會有自己的排列，所以我會覺得說，position它其實是在對網頁上的物件做一個「改變定位參考對象」的動作，預設狀態下參考對象會是原本物件資料自己本身的排列狀態，position的值會改變定位參考對象，從而改變物件排列方式。</div><p><br /></p><h2 style="text-align: left;">position主要有的值大致分成以下五種：</h2><p></p><ul style="text-align: left;"><li>static</li><li>relative</li><li>fixed</li><li>absolute</li><li>sticky</li></ul><div><br /></div><h3 style="text-align: left;">static</h3><div>這個值是假如都沒設position，預設就會是satic。</div><div>幾個我覺得重要的點</div><div><ol style="text-align: left;"><li>使用了這個值，其他的定位方式都會失效</li><li>很少用到，因為預設就是static，我想要預設那我就不下就好</li></ol><h3 style="text-align: left;">relative</h3></div><div>相對定位，它的定位參考位置還是原本預設狀態的，但是可以讓顯示位子去做偏移，意思就是能在不改變網頁佈局的狀態下去改變物件位子，假如去做偏移的話，會依造原本預設狀態的基礎下再去改變</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgup_EY1m4hQZh4lC0khq0ixwuNMDGGDcjVXD8rdXXaI8JxzDcvpdNo2G9HRV0a7Q0VEyq4vw5PS9HCPHowr4VZpv580PTaxmGBjIsVR-Lbgo534O0kMspgU7X2YgBRkZ6_aX9tByi-jZ29osmARJcw__uKneQnIx4JIptutCOYJqshSg9giHWomQnSGg/s1394/%E6%88%AA%E5%9C%96%202022-04-09%20%E4%B8%8A%E5%8D%8810.43.25.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" data-original-height="626" data-original-width="1394" height="285" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgup_EY1m4hQZh4lC0khq0ixwuNMDGGDcjVXD8rdXXaI8JxzDcvpdNo2G9HRV0a7Q0VEyq4vw5PS9HCPHowr4VZpv580PTaxmGBjIsVR-Lbgo534O0kMspgU7X2YgBRkZ6_aX9tByi-jZ29osmARJcw__uKneQnIx4JIptutCOYJqshSg9giHWomQnSGg/w672-h285/%E6%88%AA%E5%9C%96%202022-04-09%20%E4%B8%8A%E5%8D%8810.43.25.png" width="672" /></a></div><br /><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><h3 style="text-align: left;">absolute</h3><div>絕對定位，它的定位參考位置就直接脫離原本預設狀態，所以讓設定的物件做偏離之外，就不會佔據任何空間 ＝ 其他沒被absolute且還是原本預設狀態的物件也會被跟著影響。另外，它的參考對象會是最近的非static設定的父層空間，所以常常在使用absolute時它的父層會在設定一個relative就是此道理，除了relative之外，fixed跟sticky也可以作為定位參考對象</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgKXxKVnTbraU2PsMsqYNDyH_fUpumjZ62kDVM3TPKxUvu_NAQ08pb9MUf-IJpxIG4b35strAyxZm1CN7431ei5A8oa5YOX4PhnecLOdE7MjwufI9vLr9D5xlHu3VGsRdsqN61EPBmpuzH4dUu8TTtSWYANNg2f-wL7paYsvFy9I3BRdlnPGDPKKH4p4A/s1316/%E6%88%AA%E5%9C%96%202022-04-09%20%E4%B8%8A%E5%8D%8811.14.25.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" data-original-height="772" data-original-width="1316" height="235" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgKXxKVnTbraU2PsMsqYNDyH_fUpumjZ62kDVM3TPKxUvu_NAQ08pb9MUf-IJpxIG4b35strAyxZm1CN7431ei5A8oa5YOX4PhnecLOdE7MjwufI9vLr9D5xlHu3VGsRdsqN61EPBmpuzH4dUu8TTtSWYANNg2f-wL7paYsvFy9I3BRdlnPGDPKKH4p4A/w642-h235/%E6%88%AA%E5%9C%96%202022-04-09%20%E4%B8%8A%E5%8D%8811.14.25.png" width="642" /></a></div><br /><div><br /></div><div><div class="separator" style="clear: both; text-align: center;"><br /></div><h3 style="text-align: left;">fixed</h3><div>固定定位，它的定位參考對象一樣會脫離原本的預設狀態，不過跟absolute不同的是，所定位參考對象會是當前視窗，意思就是當在滑動視窗捲軸時，不管怎麼滾動，被設定了fixed的物件都能一直固定在相同位置，等等講完sticky會一起用示意圖來跟abosolute做比較</div><div><br /></div><h3 style="text-align: left;"><span style="font-size: 18.72px;">sticky</span></h3><div>黏貼定位，擁有剛剛所講述的relative和fixed的特性，關於定位參考對象可以成在跨過特定值前為相對定位，之後為固定定位，那什麼是特定值呢？ 這就要來說到為什麼要使用黏貼定位：</div><div><br /></div><div>簡單來說，是想要在網頁畫面上有著固定的效果，但是滑到一定地方之後，就不想繼續固定時，就會使用sticky，關於上述所提到的特別值，也就是在設定黏貼定位，必須要指定top、right、 bottom 、left 這四個屬性值其中之一，否則sticky的行為就會變得跟相對定位一樣</div><div><br /></div><h2 style="text-align: left;">三者示意圖比較時間</h2><div><br /></div><div><br /></div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiCDO7u65eLUgtmwMTCCqHgM2noqiMG7jvZTc0M_nfai-mQGTxFzAS2_VTsF3AlL22yrVsLue_K1Y_m5HW6VU4PWHE7wsMxCGJP_1HHdx9q9w83jD6UXLE8L7mksXk8VKlUHZhWDV4nB4IG-AYoiYFs1C529zgSyTvHXnb9iymc5ZhUi6HXN-4J7vcStg/s2570/%E6%88%AA%E5%9C%96%202022-04-09%20%E4%B8%8B%E5%8D%8812.01.11.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" data-original-height="1518" data-original-width="2570" height="394" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiCDO7u65eLUgtmwMTCCqHgM2noqiMG7jvZTc0M_nfai-mQGTxFzAS2_VTsF3AlL22yrVsLue_K1Y_m5HW6VU4PWHE7wsMxCGJP_1HHdx9q9w83jD6UXLE8L7mksXk8VKlUHZhWDV4nB4IG-AYoiYFs1C529zgSyTvHXnb9iymc5ZhUi6HXN-4J7vcStg/w668-h394/%E6%88%AA%E5%9C%96%202022-04-09%20%E4%B8%8B%E5%8D%8812.01.11.png" width="668" /></a></div></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><h2>最後來講一些我自己覺得在學習position時一些重要的地方</h2><div><ul><li>position有什麼值&nbsp; 為什麼要分這些值</li><li>預設時跟有了position之後的狀態改變</li><li>不同值所參照的容器層也不同，哪裡不同</li></ul></div><div><br /></div></div><h2 style="text-align: left;">研究position的資料來源</h2><div><a href="https://www.w3.org/TR/css-position-3/">position org規範</a><br /></div><div><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position">position mdn</a><br /></div><div><a href="https://ithelp.ithome.com.tw/articles/10253500">position - 金魚都能懂的CSS必學屬性</a><br /></div><div><a href="https://ithelp.ithome.com.tw/articles/10194075?sc=pt">前端新手村 Position 定位</a><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiYx12xvirOAD_SaZAoa95r2yCJq8eAslTQD2Glx2bZHgtxMrAyjZZc-VOZyCgjo8KYRQ5sBfyvEjuyOjG9-Htu48LbtFmePKdlOWZIBsfcRaojLm-vXItkpBjYwXMDce6lXfOptbOfSbxLveuuDgwVBnaxHb21_M3kDUW7sLZkS6M5BW-D54B1vDB0nQ/s2570/%E6%88%AA%E5%9C%96%202022-04-09%20%E4%B8%8B%E5%8D%8812.01.11.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><br /></a></div></div><p></p>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Selector Combinators 中的+跟~差別</title>
      <link href="/2022/04/04/Adjacent%20and%20General%20Sibling%20Selector/"/>
      <url>/2022/04/04/Adjacent%20and%20General%20Sibling%20Selector/</url>
      
        <content type="html"><![CDATA[<p>原文連結: <a href="https://appcs342.blogspot.com/2022/04/selector-combinators.html">https://appcs342.blogspot.com/2022/04/selector-combinators.html</a><br>移植時的最後更新日期: 2022-04-04T05:40:13.467-07:00</p><div><span style="font-family: inherit;">介紹兩個很類似的選擇器，</span></div><span style="font-family: inherit;">全名是Next-sibling combinator，簡稱加號(+)</span><div><span style="font-family: inherit;">全名是Subsequent-sibling combinator，簡稱波浪號(~)</span></div><div><span style="font-family: inherit;"><br /></span></div><div><ul style="text-align: left;"><li><span style="font-family: inherit;">加號是會影響到後方同層級的首次遇到元素</span></li><li><span style="font-family: inherit;">波浪號則是影響後方同層級的全部元素</span></li></ul><div><span style="font-family: inherit;"><br /></span></div></div><div><span style="font-family: inherit;">加號跟波浪號都是目標為要影響後方同層級，語法使用方式也都差不多</span></div><div><span style="font-family: inherit;">[選取對象A + 選取對象B] 及 [選取對象A ~ 選取對象B]。</span></div><div><span style="font-family: inherit;"><br /></span></div><div><span style="font-family: inherit;"><br /></span></div><div><span style="font-family: inherit;">看起來非常的像，不過有一些差別：</span></div><div><ul style="text-align: left;"><li>加號是只能選到A後面那一個B</li><li>波浪號是選到A後面整串同層的B</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搞懂 width / max-width / min-width 差異</title>
      <link href="/2022/03/27/width%20%20max-width%20%20min-width/"/>
      <url>/2022/03/27/width%20%20max-width%20%20min-width/</url>
      
        <content type="html"><![CDATA[<p>原文連結: <a href="https://appcs342.blogspot.com/2022/03/width-max-width-min-width.html">https://appcs342.blogspot.com/2022/03/width-max-width-min-width.html</a><br>移植時的最後更新日期: 2022-03-27T01:59:21.653-07:00</p><span id="more"></span><p>原本自己以為是很簡單的觀念，不過最近被問後發現其實並沒有很了解，像是我沒去思考過假如width跟max-width都設定數值，互相衝突後會發生什麼事情。所以我打算重新研究後，整理筆記出來。<br /><br /></p><h2 style="text-align: left;">width(寬度）</h2><div><ul style="text-align: left;"><li>用來設定物件的寬</li><li>網頁頁面一定會用到的屬性</li></ul><br /></div><h2 style="text-align: left;">max-width(最大寬度值）</h2><div><ul style="text-align: left;"><li>用來給物件設定最大寬度值</li><li>適用於尺寸限制時</li></ul><br /></div><div><h2>min-width(最小寬度值）</h2><div><ul><li>用來給物件設定最小寬度值</li><li>適用於尺寸限制時</li></ul><br /></div></div><h2 style="text-align: left;">衝突時的狀況</h2><div>結論：會以更加明確的那個狀況為優先。</div><div>舉例來說，假如給一個物件10單位的寬度（width)，又指定給這個物件最小寬度為20單位(min-width)，這時候就會產生衝突的狀況。最後的結果會是最小寬度更為優先，所以是20單位。</div><div><span style="color: red;">在這狀況下，min-width會覆蓋width的值，我自己是理解成</span><span style="color: red;">min-width意味著最少就是需要這樣的寬度值，所以假如width設定的寬度值少於</span><span style="color: red;">min-width就會失去效果。</span></div><div><span style="color: red;"><br /></span></div><div><span style="color: red;"><br /></span></div><h2 style="text-align: left;">小結</h2><div><span style="font-family: inherit;">寬度通常都會擇一使用，很少會遇到&nbsp;width / max-width / min-width 同時混再一起使用，因為這樣不只可讀性變得怪怪的，邏輯也會不太通。然後還有width因為比較基本，所以通常混用時，常常會被&nbsp;max-width / min-width 覆蓋效果，所以要讓width<span style="background-color: white;">正常發揮它的作用，最簡單的方式就是只下</span>width就好。</span><br /><br /></div><h2 style="text-align: left;">參考資料</h2><div><a href="https://ithelp.ithome.com.tw/articles/10252194">https://ithelp.ithome.com.tw/articles/10252194</a><br /></div><div><br /></div><div><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width">https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width</a><br /></div><div><br /></div>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什麼時候會用img , 什麼時候會用background-image</title>
      <link href="/2022/03/26/img%20and%20background-image/"/>
      <url>/2022/03/26/img%20and%20background-image/</url>
      
        <content type="html"><![CDATA[<p>原文連結: <a href="https://appcs342.blogspot.com/2022/03/img-background-image.html">https://appcs342.blogspot.com/2022/03/img-background-image.html</a><br>移植時的最後更新日期: 2022-03-26T01:01:42.352-07:00</p><span id="more"></span><p>一個是html標籤的img，一個是css的background-image，兩個都能讓網頁中顯示出圖片。</p><p>我自己目前個人遇到的狀況會使用img &gt; background-image 。</p><p><br /></p><h2 style="text-align: left;"><span style="font-size: large;"><b>img:</b></span></h2><p>會使用img的情況通常是：</p><p></p><ul style="text-align: left;"><li>網頁不只是需要單純的一張圖片而已，還需要像是超連結的功能，或是想讓圖片能夠縮小放大。</li><li>有需要使用動畫的時候，因為img的動畫表現會比background-image更好。</li><li>影印頁面時，圖片也想跟著被印出來。<br /><br /></li></ul><p></p><h2 style="text-align: left;"><span>&nbsp;</span>background-image:</h2><div>簡單來說，是像是網頁中當背景圖片的感覺，意味著background-image其實並沒有自己本身的意義存在，它沒有辦法去代表網頁中內容的任何事情。<br /><br /></div><div>會使用的狀況：</div><div><ul style="text-align: left;"><li>圖片不是內容的一部分（設計考量）。<br /></li><li>網頁需要有圖片當背景。<br /></li><li>影印頁面時，圖片不想跟著被印出來。<br /><br /><br /></li></ul><h2 style="text-align: left;">小結：</h2></div><div>img是屬於頁面內容的一部分，它是擁有含義的圖片。<br />background-image則是不屬於頁面內容的一部分，它是沒有含義，可以拿來單純當作背景的圖片。<br /></div>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
